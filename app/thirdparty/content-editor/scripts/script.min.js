// https://tc39.github.io/ecma262/#sec-array.prototype.find
//source: https://github.com/Modernizr/Modernizr/wiki/HTML5-Cross-Browser-Polyfills


/*
compiled by <sunils@ilimi.in> Sunil A S

Polyfill for Array:
1. find
2. filter
3. forEach
4. every
5. indexOf
6. map
7. lastIndexOf
8. reduce
9. reduceRight
10. isArray

*/
if (!Array.prototype.find) {
  Object.defineProperty(Array.prototype, 'find', {
    value: function(predicate) {
     // 1. Let O be ? ToObject(this value).
      if (this == null) {
        throw new TypeError('"this" is null or not defined');
      }

      var o = Object(this);

      // 2. Let len be ? ToLength(? Get(O, "length")).
      var len = o.length >>> 0;

      // 3. If IsCallable(predicate) is false, throw a TypeError exception.
      if (typeof predicate !== 'function') {
        throw new TypeError('predicate must be a function');
      }

      // 4. If thisArg was supplied, let T be thisArg; else let T be undefined.
      var thisArg = arguments[1];

      // 5. Let k be 0.
      var k = 0;

      // 6. Repeat, while k < len
      while (k < len) {
        // a. Let Pk be ! ToString(k).
        // b. Let kValue be ? Get(O, Pk).
        // c. Let testResult be ToBoolean(? Call(predicate, T, « kValue, k, O »)).
        // d. If testResult is true, return kValue.
        var kValue = o[k];
        if (predicate.call(thisArg, kValue, k, o)) {
          return kValue;
        }
        // e. Increase k by 1.
        k++;
      }

      // 7. Return undefined.
      return undefined;
    }
  });
}

if (!Array.prototype.filter) {
  Array.prototype.filter = function(fun/*, thisArg*/) {
    'use strict';

    if (this === void 0 || this === null) {
      throw new TypeError();
    }

    var t = Object(this);
    var len = t.length >>> 0;
    if (typeof fun !== 'function') {
      throw new TypeError();
    }

    var res = [];
    var thisArg = arguments.length >= 2 ? arguments[1] : void 0;
    for (var i = 0; i < len; i++) {
      if (i in t) {
        var val = t[i];

        // NOTE: Technically this should Object.defineProperty at
        //       the next index, as push can be affected by
        //       properties on Object.prototype and Array.prototype.
        //       But that method's new, and collisions should be
        //       rare, so use the more-compatible alternative.
        if (fun.call(thisArg, val, i, t)) {
          res.push(val);
        }
      }
    }

    return res;
  };
}

// Production steps of ECMA-262, Edition 5, 15.4.4.18
// Reference: http://es5.github.io/#x15.4.4.18
if (!Array.prototype.forEach) {

  Array.prototype.forEach = function(callback/*, thisArg*/) {

    var T, k;

    if (this == null) {
      throw new TypeError('this is null or not defined');
    }

    // 1. Let O be the result of calling toObject() passing the
    // |this| value as the argument.
    var O = Object(this);

    // 2. Let lenValue be the result of calling the Get() internal
    // method of O with the argument "length".
    // 3. Let len be toUint32(lenValue).
    var len = O.length >>> 0;

    // 4. If isCallable(callback) is false, throw a TypeError exception. 
    // See: http://es5.github.com/#x9.11
    if (typeof callback !== 'function') {
      throw new TypeError(callback + ' is not a function');
    }

    // 5. If thisArg was supplied, let T be thisArg; else let
    // T be undefined.
    if (arguments.length > 1) {
      T = arguments[1];
    }

    // 6. Let k be 0
    k = 0;

    // 7. Repeat, while k < len
    while (k < len) {

      var kValue;

      // a. Let Pk be ToString(k).
      //    This is implicit for LHS operands of the in operator
      // b. Let kPresent be the result of calling the HasProperty
      //    internal method of O with argument Pk.
      //    This step can be combined with c
      // c. If kPresent is true, then
      if (k in O) {

        // i. Let kValue be the result of calling the Get internal
        // method of O with argument Pk.
        kValue = O[k];

        // ii. Call the Call internal method of callback with T as
        // the this value and argument list containing kValue, k, and O.
        callback.call(T, kValue, k, O);
      }
      // d. Increase k by 1.
      k++;
    }
    // 8. return undefined
  };
}


if (!Array.prototype.every) {
  Array.prototype.every = function(callbackfn, thisArg) {
    'use strict';
    var T, k;

    if (this == null) {
      throw new TypeError('this is null or not defined');
    }

    // 1. Let O be the result of calling ToObject passing the this 
    //    value as the argument.
    var O = Object(this);

    // 2. Let lenValue be the result of calling the Get internal method
    //    of O with the argument "length".
    // 3. Let len be ToUint32(lenValue).
    var len = O.length >>> 0;

    // 4. If IsCallable(callbackfn) is false, throw a TypeError exception.
    if (typeof callbackfn !== 'function') {
      throw new TypeError();
    }

    // 5. If thisArg was supplied, let T be thisArg; else let T be undefined.
    if (arguments.length > 1) {
      T = thisArg;
    }

    // 6. Let k be 0.
    k = 0;

    // 7. Repeat, while k < len
    while (k < len) {

      var kValue;

      // a. Let Pk be ToString(k).
      //   This is implicit for LHS operands of the in operator
      // b. Let kPresent be the result of calling the HasProperty internal 
      //    method of O with argument Pk.
      //   This step can be combined with c
      // c. If kPresent is true, then
      if (k in O) {

        // i. Let kValue be the result of calling the Get internal method
        //    of O with argument Pk.
        kValue = O[k];

        // ii. Let testResult be the result of calling the Call internal method
        //     of callbackfn with T as the this value and argument list 
        //     containing kValue, k, and O.
        var testResult = callbackfn.call(T, kValue, k, O);

        // iii. If ToBoolean(testResult) is false, return false.
        if (!testResult) {
          return false;
        }
      }
      k++;
    }
    return true;
  };
}


// Production steps of ECMA-262, Edition 5, 15.4.4.14
// Reference: http://es5.github.io/#x15.4.4.14
if (!Array.prototype.indexOf) {
  Array.prototype.indexOf = function(searchElement, fromIndex) {

    var k;

    // 1. Let o be the result of calling ToObject passing
    //    the this value as the argument.
    if (this == null) {
      throw new TypeError('"this" is null or not defined');
    }

    var o = Object(this);

    // 2. Let lenValue be the result of calling the Get
    //    internal method of o with the argument "length".
    // 3. Let len be ToUint32(lenValue).
    var len = o.length >>> 0;

    // 4. If len is 0, return -1.
    if (len === 0) {
      return -1;
    }

    // 5. If argument fromIndex was passed let n be
    //    ToInteger(fromIndex); else let n be 0.
    var n = fromIndex | 0;

    // 6. If n >= len, return -1.
    if (n >= len) {
      return -1;
    }

    // 7. If n >= 0, then Let k be n.
    // 8. Else, n<0, Let k be len - abs(n).
    //    If k is less than 0, then let k be 0.
    k = Math.max(n >= 0 ? n : len - Math.abs(n), 0);

    // 9. Repeat, while k < len
    while (k < len) {
      // a. Let Pk be ToString(k).
      //   This is implicit for LHS operands of the in operator
      // b. Let kPresent be the result of calling the
      //    HasProperty internal method of o with argument Pk.
      //   This step can be combined with c
      // c. If kPresent is true, then
      //    i.  Let elementK be the result of calling the Get
      //        internal method of o with the argument ToString(k).
      //   ii.  Let same be the result of applying the
      //        Strict Equality Comparison Algorithm to
      //        searchElement and elementK.
      //  iii.  If same is true, return k.
      if (k in o && o[k] === searchElement) {
        return k;
      }
      k++;
    }
    return -1;
  };
}

// Production steps of ECMA-262, Edition 5, 15.4.4.19
// Reference: http://es5.github.io/#x15.4.4.19
if (!Array.prototype.map) {

  Array.prototype.map = function(callback/*, thisArg*/) {

    var T, A, k;

    if (this == null) {
      throw new TypeError('this is null or not defined');
    }

    // 1. Let O be the result of calling ToObject passing the |this| 
    //    value as the argument.
    var O = Object(this);

    // 2. Let lenValue be the result of calling the Get internal 
    //    method of O with the argument "length".
    // 3. Let len be ToUint32(lenValue).
    var len = O.length >>> 0;

    // 4. If IsCallable(callback) is false, throw a TypeError exception.
    // See: http://es5.github.com/#x9.11
    if (typeof callback !== 'function') {
      throw new TypeError(callback + ' is not a function');
    }

    // 5. If thisArg was supplied, let T be thisArg; else let T be undefined.
    if (arguments.length > 1) {
      T = arguments[1];
    }

    // 6. Let A be a new array created as if by the expression new Array(len) 
    //    where Array is the standard built-in constructor with that name and 
    //    len is the value of len.
    A = new Array(len);

    // 7. Let k be 0
    k = 0;

    // 8. Repeat, while k < len
    while (k < len) {

      var kValue, mappedValue;

      // a. Let Pk be ToString(k).
      //   This is implicit for LHS operands of the in operator
      // b. Let kPresent be the result of calling the HasProperty internal 
      //    method of O with argument Pk.
      //   This step can be combined with c
      // c. If kPresent is true, then
      if (k in O) {

        // i. Let kValue be the result of calling the Get internal 
        //    method of O with argument Pk.
        kValue = O[k];

        // ii. Let mappedValue be the result of calling the Call internal 
        //     method of callback with T as the this value and argument 
        //     list containing kValue, k, and O.
        mappedValue = callback.call(T, kValue, k, O);

        // iii. Call the DefineOwnProperty internal method of A with arguments
        // Pk, Property Descriptor
        // { Value: mappedValue,
        //   Writable: true,
        //   Enumerable: true,
        //   Configurable: true },
        // and false.

        // In browsers that support Object.defineProperty, use the following:
        // Object.defineProperty(A, k, {
        //   value: mappedValue,
        //   writable: true,
        //   enumerable: true,
        //   configurable: true
        // });

        // For best browser support, use the following:
        A[k] = mappedValue;
      }
      // d. Increase k by 1.
      k++;
    }

    // 9. return A
    return A;
  };
}

// Production steps of ECMA-262, Edition 5, 15.4.4.15
// Reference: http://es5.github.io/#x15.4.4.15
if (!Array.prototype.lastIndexOf) {
  Array.prototype.lastIndexOf = function(searchElement /*, fromIndex*/) {
    'use strict';

    if (this === void 0 || this === null) {
      throw new TypeError();
    }

    var n, k,
      t = Object(this),
      len = t.length >>> 0;
    if (len === 0) {
      return -1;
    }

    n = len - 1;
    if (arguments.length > 1) {
      n = Number(arguments[1]);
      if (n != n) {
        n = 0;
      }
      else if (n != 0 && n != (1 / 0) && n != -(1 / 0)) {
        n = (n > 0 || -1) * Math.floor(Math.abs(n));
      }
    }

    for (k = n >= 0 ? Math.min(n, len - 1) : len - Math.abs(n); k >= 0; k--) {
      if (k in t && t[k] === searchElement) {
        return k;
      }
    }
    return -1;
  };
}

// Production steps of ECMA-262, Edition 5, 15.4.4.21
// Reference: http://es5.github.io/#x15.4.4.21
// https://tc39.github.io/ecma262/#sec-array.prototype.reduce
if (!Array.prototype.reduce) {
  Object.defineProperty(Array.prototype, 'reduce', {
    value: function(callback /*, initialValue*/) {
      if (this === null) {
        throw new TypeError( 'Array.prototype.reduce ' + 
          'called on null or undefined' );
      }
      if (typeof callback !== 'function') {
        throw new TypeError( callback +
          ' is not a function');
      }

      // 1. Let O be ? ToObject(this value).
      var o = Object(this);

      // 2. Let len be ? ToLength(? Get(O, "length")).
      var len = o.length >>> 0; 

      // Steps 3, 4, 5, 6, 7      
      var k = 0; 
      var value;

      if (arguments.length >= 2) {
        value = arguments[1];
      } else {
        while (k < len && !(k in o)) {
          k++; 
        }

        // 3. If len is 0 and initialValue is not present,
        //    throw a TypeError exception.
        if (k >= len) {
          throw new TypeError( 'Reduce of empty array ' +
            'with no initial value' );
        }
        value = o[k++];
      }

      // 8. Repeat, while k < len
      while (k < len) {
        // a. Let Pk be ! ToString(k).
        // b. Let kPresent be ? HasProperty(O, Pk).
        // c. If kPresent is true, then
        //    i.  Let kValue be ? Get(O, Pk).
        //    ii. Let accumulator be ? Call(
        //          callbackfn, undefined,
        //          « accumulator, kValue, k, O »).
        if (k in o) {
          value = callback(value, o[k], k, o);
        }

        // d. Increase k by 1.      
        k++;
      }

      // 9. Return accumulator.
      return value;
    }
  });
}

// Production steps of ECMA-262, Edition 5, 15.4.4.22
// Reference: http://es5.github.io/#x15.4.4.22
if ('function' !== typeof Array.prototype.reduceRight) {
  Array.prototype.reduceRight = function(callback /*, initialValue*/) {
    'use strict';
    if (null === this || 'undefined' === typeof this) {
      throw new TypeError('Array.prototype.reduce called on null or undefined');
    }
    if ('function' !== typeof callback) {
      throw new TypeError(callback + ' is not a function');
    }
    var t = Object(this), len = t.length >>> 0, k = len - 1, value;
    if (arguments.length >= 2) {
      value = arguments[1];
    } else {
      while (k >= 0 && !(k in t)) {
        k--;
      }
      if (k < 0) {
        throw new TypeError('Reduce of empty array with no initial value');
      }
      value = t[k--];
    }
    for (; k >= 0; k--) {
      if (k in t) {
        value = callback(value, t[k], k, t);
      }
    }
    return value;
  };
}

if (!Array.isArray) {
  Array.isArray = function(arg) {
    return Object.prototype.toString.call(arg) === '[object Array]';
  };
}
/* Simple JavaScript Inheritance
 * By John Resig http://ejohn.org/
 * MIT Licensed.
 */
// Inspired by base2 and Prototype
(function() {
    /* istanbul ignore next */
    var initializing = false,
        fnTest = /xyz/.test(function() {
            xyz;
        }) ? /\b_super\b/ : /.*/;

    // The base Class implementation (does nothing)
    this.Class = function() {};

    // Create a new Class that inherits from this class
    Class.extend = function(prop) {
        var _super = this.prototype;

        // Instantiate a base class (but only create the instance,
        // don't run the init constructor)
        initializing = true;
        var prototype = new this();
        initializing = false;

        // Copy the properties over onto the new prototype
        for (var name in prop) {
            // Check if we're overwriting an existing function
            prototype[name] = typeof prop[name] == "function" &&
                typeof _super[name] == "function" && fnTest.test(prop[name]) ?
                (function(name, fn) {
                    return function() {
                        var tmp = this._super;

                        // Add a new ._super() method that is the same method
                        // but on the super-class
                        this._super = _super[name];

                        // The method only need to be bound temporarily, so we
                        // remove it when we're done executing
                        var ret = fn.apply(this, arguments);
                        this._super = tmp;

                        return ret;
                    };
                })(name, prop[name]) :
                prop[name];
        }

        // The dummy class constructor
        function Class() {
            // All construction is actually done in the init method
            if (!initializing && this.init)
                this.init.apply(this, arguments);
        }

        // Populate our constructed prototype object
        Class.prototype = prototype;

        // Enforce the constructor to be what we expect
        Class.prototype.constructor = Class;

        // And make this class extendable
        Class.extend = arguments.callee;

        return Class;
    };
})();

(function(root,factory){if(typeof exports==="object"&&typeof module==="object")module.exports=factory();else if(typeof define==="function"&&define.amd)define("EventBus",[],factory);else if(typeof exports==="object")exports["EventBus"]=factory();else root["EventBus"]=factory()})(this,function(){var EventBusClass={};EventBusClass=function(){this.listeners={}};EventBusClass.prototype={addEventListener:function(type,callback,scope){var args=[];var numOfArgs=arguments.length;for(var i=0;i<numOfArgs;i++){args.push(arguments[i])}args=args.length>3?args.splice(3,args.length-1):[];if(typeof this.listeners[type]!="undefined"){this.listeners[type].push({scope:scope,callback:callback,args:args})}else{this.listeners[type]=[{scope:scope,callback:callback,args:args}]}},removeEventListener:function(type,callback,scope){if(typeof this.listeners[type]!="undefined"){var numOfCallbacks=this.listeners[type].length;var newArray=[];for(var i=0;i<numOfCallbacks;i++){var listener=this.listeners[type][i];if(listener.scope==scope&&listener.callback==callback){}else{newArray.push(listener)}}this.listeners[type]=newArray}},hasEventListener:function(type,callback,scope){if(typeof this.listeners[type]!="undefined"){var numOfCallbacks=this.listeners[type].length;if(callback===undefined&&scope===undefined){return numOfCallbacks>0}for(var i=0;i<numOfCallbacks;i++){var listener=this.listeners[type][i];if((scope?listener.scope==scope:true)&&listener.callback==callback){return true}}}return false},dispatch:function(type,target){var numOfListeners=0;var event={type:type,target:target};var args=[];var numOfArgs=arguments.length;for(var i=0;i<numOfArgs;i++){args.push(arguments[i])}args=args.length>2?args.splice(2,args.length-1):[];args=[event].concat(args);if(typeof this.listeners[type]!="undefined"){var numOfCallbacks=this.listeners[type].length;for(var i=0;i<numOfCallbacks;i++){var listener=this.listeners[type][i];if(listener&&listener.callback){var concatArgs=args.concat(listener.args);listener.callback.apply(listener.scope,concatArgs);numOfListeners+=1}}}},getEvents:function(){var str="";for(var type in this.listeners){var numOfCallbacks=this.listeners[type].length;for(var i=0;i<numOfCallbacks;i++){var listener=this.listeners[type][i];str+=listener.scope&&listener.scope.className?listener.scope.className:"anonymous";str+=" listen for '"+type+"'\n"}}return str}};var EventBus=new EventBusClass;return EventBus});
/* mousetrap v1.6.0 craig.is/killing/mice */
(function(r,t,g){function u(a,b,h){a.addEventListener?a.addEventListener(b,h,!1):a.attachEvent("on"+b,h)}function y(a){if("keypress"==a.type){var b=String.fromCharCode(a.which);a.shiftKey||(b=b.toLowerCase());return b}return k[a.which]?k[a.which]:p[a.which]?p[a.which]:String.fromCharCode(a.which).toLowerCase()}function D(a){var b=[];a.shiftKey&&b.push("shift");a.altKey&&b.push("alt");a.ctrlKey&&b.push("ctrl");a.metaKey&&b.push("meta");return b}function v(a){return"shift"==a||"ctrl"==a||"alt"==a||
"meta"==a}function z(a,b){var h,c,e,g=[];h=a;"+"===h?h=["+"]:(h=h.replace(/\+{2}/g,"+plus"),h=h.split("+"));for(e=0;e<h.length;++e)c=h[e],A[c]&&(c=A[c]),b&&"keypress"!=b&&B[c]&&(c=B[c],g.push("shift")),v(c)&&g.push(c);h=c;e=b;if(!e){if(!n){n={};for(var l in k)95<l&&112>l||k.hasOwnProperty(l)&&(n[k[l]]=l)}e=n[h]?"keydown":"keypress"}"keypress"==e&&g.length&&(e="keydown");return{key:c,modifiers:g,action:e}}function C(a,b){return null===a||a===t?!1:a===b?!0:C(a.parentNode,b)}function c(a){function b(a){a=
a||{};var b=!1,m;for(m in n)a[m]?b=!0:n[m]=0;b||(w=!1)}function h(a,b,m,f,c,h){var g,e,k=[],l=m.type;if(!d._callbacks[a])return[];"keyup"==l&&v(a)&&(b=[a]);for(g=0;g<d._callbacks[a].length;++g)if(e=d._callbacks[a][g],(f||!e.seq||n[e.seq]==e.level)&&l==e.action){var q;(q="keypress"==l&&!m.metaKey&&!m.ctrlKey)||(q=e.modifiers,q=b.sort().join(",")===q.sort().join(","));q&&(q=f&&e.seq==f&&e.level==h,(!f&&e.combo==c||q)&&d._callbacks[a].splice(g,1),k.push(e))}return k}function g(a,b,m,f){d.stopCallback(b,
b.target||b.srcElement,m,f)||!1!==a(b,m)||(b.preventDefault?b.preventDefault():b.returnValue=!1,b.stopPropagation?b.stopPropagation():b.cancelBubble=!0)}function e(a){"number"!==typeof a.which&&(a.which=a.keyCode);var b=y(a);b&&("keyup"==a.type&&x===b?x=!1:d.handleKey(b,D(a),a))}function k(a,c,m,f){function e(c){return function(){w=c;++n[a];clearTimeout(r);r=setTimeout(b,1E3)}}function h(c){g(m,c,a);"keyup"!==f&&(x=y(c));setTimeout(b,10)}for(var d=n[a]=0;d<c.length;++d){var p=d+1===c.length?h:e(f||
z(c[d+1]).action);l(c[d],p,f,a,d)}}function l(a,b,c,f,e){d._directMap[a+":"+c]=b;a=a.replace(/\s+/g," ");var g=a.split(" ");1<g.length?k(a,g,b,c):(c=z(a,c),d._callbacks[c.key]=d._callbacks[c.key]||[],h(c.key,c.modifiers,{type:c.action},f,a,e),d._callbacks[c.key][f?"unshift":"push"]({callback:b,modifiers:c.modifiers,action:c.action,seq:f,level:e,combo:a}))}var d=this;a=a||t;if(!(d instanceof c))return new c(a);d.target=a;d._callbacks={};d._directMap={};var n={},r,x=!1,p=!1,w=!1;d._handleKey=function(a,
c,e){var f=h(a,c,e),d;c={};var k=0,l=!1;for(d=0;d<f.length;++d)f[d].seq&&(k=Math.max(k,f[d].level));for(d=0;d<f.length;++d)f[d].seq?f[d].level==k&&(l=!0,c[f[d].seq]=1,g(f[d].callback,e,f[d].combo,f[d].seq)):l||g(f[d].callback,e,f[d].combo);f="keypress"==e.type&&p;e.type!=w||v(a)||f||b(c);p=l&&"keydown"==e.type};d._bindMultiple=function(a,b,c){for(var d=0;d<a.length;++d)l(a[d],b,c)};u(a,"keypress",e);u(a,"keydown",e);u(a,"keyup",e)}if(r){var k={8:"backspace",9:"tab",13:"enter",16:"shift",17:"ctrl",
18:"alt",20:"capslock",27:"esc",32:"space",33:"pageup",34:"pagedown",35:"end",36:"home",37:"left",38:"up",39:"right",40:"down",45:"ins",46:"del",91:"meta",93:"meta",224:"meta"},p={106:"*",107:"+",109:"-",110:".",111:"/",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'"},B={"~":"`","!":"1","@":"2","#":"3",$:"4","%":"5","^":"6","&":"7","*":"8","(":"9",")":"0",_:"-","+":"=",":":";",'"':"'","<":",",">":".","?":"/","|":"\\"},A={option:"alt",command:"meta","return":"enter",
escape:"esc",plus:"+",mod:/Mac|iPod|iPhone|iPad/.test(navigator.platform)?"meta":"ctrl"},n;for(g=1;20>g;++g)k[111+g]="f"+g;for(g=0;9>=g;++g)k[g+96]=g;c.prototype.bind=function(a,b,c){a=a instanceof Array?a:[a];this._bindMultiple.call(this,a,b,c);return this};c.prototype.unbind=function(a,b){return this.bind.call(this,a,function(){},b)};c.prototype.trigger=function(a,b){if(this._directMap[a+":"+b])this._directMap[a+":"+b]({},a);return this};c.prototype.reset=function(){this._callbacks={};this._directMap=
{};return this};c.prototype.stopCallback=function(a,b){return-1<(" "+b.className+" ").indexOf(" mousetrap ")||C(b,this.target)?!1:"INPUT"==b.tagName||"SELECT"==b.tagName||"TEXTAREA"==b.tagName||b.isContentEditable};c.prototype.handleKey=function(){return this._handleKey.apply(this,arguments)};c.addKeycodes=function(a){for(var b in a)a.hasOwnProperty(b)&&(k[b]=a[b]);n=null};c.init=function(){var a=c(t),b;for(b in a)"_"!==b.charAt(0)&&(c[b]=function(b){return function(){return a[b].apply(a,arguments)}}(b))};
c.init();r.Mousetrap=c;"undefined"!==typeof module&&module.exports&&(module.exports=c);"function"===typeof define&&define.amd&&define(function(){return c})}})("undefined"!==typeof window?window:null,"undefined"!==typeof window?document:null);

/**
 * @author Santhosh Vasabhaktula <santhosh@ilimi.in>
 */

// Declare Namespace
window.org = { ekstep: {} }

var plugin_framework = function() {};
plugin_framework.prototype.initialize = function(config) {
    config = config || {};
    org.ekstep.pluginframework.config = org.ekstep.pluginframework.config || {};
    if (!config.env) throw "Framework should be initialized with environment!";
    org.ekstep.pluginframework.env = config.env;
    org.ekstep.pluginframework.jQuery = config.jQuery || window.$;
    org.ekstep.pluginframework.async = config.async || window.async;
    org.ekstep.pluginframework.config.build_number = config.build_number || 'BUILD_NUMBER';
    org.ekstep.pluginframework.config.pluginRepo = config.pluginRepo || '/content-plugins';
};

window.org.ekstep.pluginframework = new plugin_framework();
plugin_framework = undefined;

var services_framework = function() {};
window.org.ekstep.services = new services_framework();
services_framework = undefined;
/**
 * @author Harish kumar Gangula<harishg@ilimi.in>
 */
org.ekstep.pluginframework.resourceManager = new(Class.extend({
    init: function() {},
    buildNumber: undefined,
    registeredRepos: [],    
    discoverManifest: function(pluginId, pluginVer, cb, publishedTime) {
        var ayncTasks = [];
        
        if (typeof pluginVer === "number") pluginVer = pluginVer.toFixed(1);

        this.registeredRepos.forEach(function(repo, index) {
            var Fns = function() {
                if (index == 0) {
                    return function(callback) {
                        repo.discoverManifest(pluginId, pluginVer, callback, publishedTime);
                    }
                } else {
                    return function(data, callback) {
                        if (data.manifest == undefined) {
                            repo.discoverManifest(pluginId, pluginVer, callback, publishedTime);
                        } else {
                            callback(null, data);
                        }
                    }
                }
            };

            ayncTasks.push(Fns());
        });

        org.ekstep.pluginframework.async.waterfall(ayncTasks, function(err, result) {
            if (result && result.manifest !== undefined)
                cb(undefined, result);
            else
                cb('Plugin not found in any repo or manifest', undefined);
        });

    },
    addRepo: function(repo, position) {
        var repoFound = this.registeredRepos.find(function(rp) {
            return rp.id == repo.id;
        });

        if (!repoFound) {
            if (typeof position === 'number') this.registeredRepos.splice(position, 0, repo)
            else this.registeredRepos.push(repo);
        } else {
            console.error(repo.id + ': Repo already registered!');
        }
    },
    getResource: function(pluginId, pluginVer, src, dataType, repo, callback, publishedTime) {
        var resource = repo.resolveResource(pluginId, pluginVer, src);
        this.loadResource(resource, dataType, callback, publishedTime);
    },
    loadExternalPluginResource: function(type, pluginId, pluginVer, src, repo, publishedTime, callback) {
        var resource = repo.resolveResource(pluginId, pluginVer, src);
        this.loadExternalResource(resource, type, publishedTime, callback);
    },
    loadExternalResource: function(resource, type, publishedTime, callback) {
        switch (type) {
            case 'js':
                if (callback)
                    this.loadResource(resource, 'script', callback, publishedTime);
                else
                    org.ekstep.pluginframework.jQuery("body").append($("<script type='text/javascript' src=" + resource + "?" + org.ekstep.pluginframework.config.build_number + "&" + (publishedTime || "") + ">"));
                break;
            case 'css':
                org.ekstep.pluginframework.jQuery("head").append("<link rel='stylesheet' type='text/css' href='" + resource + "?" + org.ekstep.pluginframework.config.build_number + "&" + (publishedTime || "") + "'>");
                if (callback) callback();
                break;
            default:
                if (callback) callback();
        }
    },
    loadResource: function(url, dataType, callback, publishedTime) {
        url = url + "?" + (org.ekstep.pluginframework.config ? org.ekstep.pluginframework.config.build_number : '');
        if (publishedTime) {
            url = url + "&" + publishedTime;
        }
        org.ekstep.pluginframework.jQuery.ajax({
            async: false,
            url: url,
            dataType: dataType
        }).done(function(data) {
            callback(null, data);
        }).fail(function(jqXHR, textStatus, errorThrown) {
            if(jqXHR.statusText === 'OK') {
                console.log('Unable to load resource:', url, 'error:', errorThrown);
            }
            callback(errorThrown)
        });
    }
}));

/**
 * @author Santhosh Vasabhaktula <santhosh@ilimi.in>
 */
org.ekstep.pluginframework.eventManager = new (Class.extend({
	enableEvents: true,
	addEventListener: function(type, callback, scope) {
		EventBus.addEventListener(type, callback, scope)
	},
	dispatchEvent: function(type, data, target) {
		if(this.enableEvents) EventBus.dispatch(type, target, data);
	},
	removeEventListener: function(type, callback, scope) {
		EventBus.removeEventListener(type, callback, scope);
	}
}));
/**
 * @author Santhosh Vasabhaktula <santhosh@ilimi.in>
 */
org.ekstep.pluginframework.pluginManager = new(Class.extend({
    pluginManifests: {},
    plugins: {},
    pluginObjs: {},
    pluginInstances: {},
    errors: [],
    init: function() {        
        console.log("Plugin manager initialized");        
    },
    _registerPlugin: function(pluginId, pluginVer, plugin, manifest, repo) {
        this.plugins[pluginId] = { p: plugin, m: manifest, repo: repo };
        this._registerNameSpace(pluginId, plugin);
        if (manifest) this.pluginManifests[manifest.id] =  { m: manifest, repo: repo };
        org.ekstep.pluginframework.eventManager.dispatchEvent('plugin:load', { plugin: pluginId, version: pluginVer });
        org.ekstep.pluginframework.eventManager.dispatchEvent(pluginId + ':load');
        var p = new plugin(manifest); 
        if (manifest) this.pluginObjs[manifest.id] = p;        
    },
    registerPlugin: function(manifest, plugin, repo) {
        repo = repo || org.ekstep.pluginframework.publishedRepo;
        this._registerPlugin(manifest.id, manifest.ver, plugin, manifest, repo);        
    },
    loadCustomPlugin: function(dependency, callback, publishedTime) {
        var instance = this;
        org.ekstep.pluginframework.resourceManager.loadResource(dependency.src, 'text', function(err, data) {
            if (err) {
                org.ekstep.pluginframework.eventManager.dispatchEvent('plugin:error', { plugin: dependency.id, version: dependency.ver, action: "load", err: err });                
                console.error('Unable to load editor plugin', 'plugin:' + dependency.id + '-' + dependency.ver, 'resource:', 'Error:', err);
            } else {
                try {
                    if (!instance.isPluginDefined(dependency.id)) {
                        data = eval(data);
                        instance._registerPlugin(dependency.id, undefined, data, undefined, undefined);
                    } else {
                        console.info("Plugin is already registered: ", dependency.id);
                    }
                } catch (e) {
                    org.ekstep.pluginframework.eventManager.dispatchEvent('plugin:error', { plugin: dependency.id, version: dependency.ver, action: "load", err: e });
                    console.error("Error while loading plugin", 'plugin:' + dependency.id + '-' + dependency.ver, 'Error:', e);
                }
            }
            callback && callback();
        }, publishedTime);
    },
    loadPluginByManifest: function(manifest, repo, pluginType, publishedTime) {
        var instance = this;
        var scope = org.ekstep.pluginframework.env;        
        if(manifest[scope] && manifest[scope].main) org.ekstep.pluginframework.resourceManager.getResource(manifest.id, manifest.ver, manifest[scope].main, 'text', repo, function(err, data) {
            if (err) {
                org.ekstep.pluginframework.eventManager.dispatchEvent('plugin:error', { plugin: manifest.id, version: manifest.ver, action: "load", err: err });
                console.error('Unable to load editor plugin', 'plugin:' + manifest.id + '-' + manifest.ver, 'resource:' + manifest[scope].main, 'Error:', err);
            } else {
                try {
                    if (!instance.isPluginDefined(manifest.id)) {
                        if (pluginType == 'library') {
                            org.ekstep.pluginframework.jQuery.globalEval(data);
                        } else {
                            if (data) instance.registerPlugin(manifest, eval(data), repo);
                        }
                    } else {
                        console.info("Plugin is already registered: ", manifest.id);
                    }
                } catch (e) {
                    org.ekstep.pluginframework.eventManager.dispatchEvent('plugin:error', { plugin: manifest.id, version: manifest.ver, action: "load", err: e });
                    console.error("Error while loading plugin", 'plugin:' + manifest.id + '-' + manifest.ver, 'Error:', e);
                }
            }
        }, publishedTime);
    },
    _registerNameSpace: function(pluginId, clazz) {
        console.info("Registering namespace for plugin:", pluginId);
        var names = pluginId.split('.')
        var baseNameSpace = names[0];
        var lastKey = names[names.length-1];
        names.splice(0, 1);

        var pluginClazz = (org.ekstep.pluginframework.env === 'editor') ? Class.extend({
            init: function(data, parent, override) {
                org.ekstep.pluginframework.pluginManager.invoke(pluginId, data, parent, override);
            }
        }) : Class.extend({
            init: function(data, parent, stage, theme) {
                org.ekstep.pluginframework.pluginManager.invokeRenderer(pluginId, data, parent, stage, theme);
            }
        });
        pluginClazz.extend = function(subClazz) {
            return clazz.extend(subClazz);
        }

        if(names.length > 0) {
            if (!window[baseNameSpace]) {
                window[baseNameSpace] = {};
            }
            names.reduce(function(o, s) {
                var val = ((s === lastKey) ? pluginClazz : {});
                return (o[s] === undefined) ? o[s] = val : o[s] 
            }, window[baseNameSpace]);
        } else {
            if(window[baseNameSpace] === undefined) window[baseNameSpace] = pluginClazz;
        }
    },
    loadAndInitPlugin: function(pluginId, version, publishedTime, parent) {
        this.loadPluginWithDependencies(pluginId, version, undefined, publishedTime, [], function() {});
        if (this.isPluginDefined(pluginId)) {
            var pluginManifest = this.getPluginManifest(pluginId);
            if (pluginManifest.type && (pluginManifest.type.toLowerCase() === "widget")) {
                this.invoke(pluginId, JSON.parse(JSON.stringify(pluginManifest[org.ekstep.pluginframework.env]['init-data'] || {})), parent);
            }
            return 0;
        } else {
            return 1;
        }
    },
    loadPluginWithDependencies: function(pluginId, pluginVer, pluginType, publishedTime, parents, callback) {
        var instance = this;
        if (this.plugins[pluginId]) {
            console.info('A plugin with id "' + pluginId + '" and ver "' + pluginVer + '" is already loaded');
            callback && callback();
            return;
        }

        if(parents.indexOf(pluginId) != -1) {
            console.warn('Detected a cyclic dependency with the plugin: "' + pluginId + '". Breaking the chain...');
            callback && callback();
            return;
        }

        parents.push(pluginId);
        org.ekstep.pluginframework.resourceManager.discoverManifest(pluginId, pluginVer, function(err, data) {
            if (err || (data == undefined)) {
                org.ekstep.pluginframework.eventManager.dispatchEvent('plugin:error', { plugin: pluginId, version: pluginVer, action: "load", err: err });
                console.error('Unable to load plugin manifest', 'plugin:' + pluginId + '-' + pluginVer, 'Error:', err);
                callback && callback(); // TODO: probably pass the error
            } else {
                instance.loadManifestDependencies(data.manifest.dependencies, publishedTime, parents, function() {
                    if (!data.manifest.editor || Object.keys(data.manifest.editor).length === 0) {
                        instance.pluginManifests[data.manifest.id] = { m: data.manifest, repo: data.repo };                        
                    }                    
                    var queue = instance.queueDependencies(data.manifest, data.repo, publishedTime, parents);
                    if (queue.length() > 0) {
                        queue.drain = function() {
                            instance.loadPluginByManifest(data.manifest, data.repo, pluginType, publishedTime);
                            callback && callback();
                        };
                    } else {
                        instance.loadPluginByManifest(data.manifest, data.repo, pluginType, publishedTime);
                        callback && callback();
                    }
                });
            }
        }, publishedTime);
    },
    queueDependencies: function(manifest, repo, publishedTime, parents) {
        var scope = org.ekstep.pluginframework.env;
        var queue = org.ekstep.pluginframework.async.queue(function(task, callback) {
            if (task.type == 'plugin') {
                if (org.ekstep.pluginframework.env == 'renderer') {
                    instance.loadCustomPlugin({id: task.plugin, src: task.repo.resolveResource(task.id, task.ver, task.src)}, callback, undefined);
                } else {
                    instance.loadPluginWithDependencies(task.plugin, task.ver, task.type, publishedTime, parents, callback);
                }
            } else {
                org.ekstep.pluginframework.resourceManager.loadExternalPluginResource(task.type, task.id, task.ver, task.src, task.repo, task.publishedTime, callback);
            }
        }, 1);
        var instance = this;
        if (manifest[scope] && Array.isArray(manifest[scope].dependencies)) {
            manifest[scope].dependencies.forEach(function(dependency) {
                if (dependency.type == 'plugin') {
                    if (org.ekstep.pluginframework.env == 'renderer') {
                        queue.push({
                            type: dependency.type,
                            id: manifest.id,
                            ver: manifest.ver,
                            src: dependency.src,
                            repo: repo,
                            plugin: dependency.id
                        }, function() {});
                    } else {
                        queue.push(dependency, function() {});
                    }
                } else if(dependency.type == 'js' || dependency.type == 'css') {
                    queue.push({
                        type: dependency.type,
                        id: manifest.id,
                        ver: manifest.ver,
                        src: dependency.src,
                        repo: repo,
                        publishedTime: publishedTime
                    }, function() {});
                }
            });
        }
        return queue;
    },
    loadManifestDependencies: function(dependencies, publishedTime, parents, callback) {
        var instance = this;
        if (Array.isArray(dependencies) && dependencies.length > 0) {
            var queue = org.ekstep.pluginframework.async.queue(function(plugin, pluginCallback) {
                instance.loadPluginWithDependencies(plugin.id, plugin.ver, plugin.type, plugin.pt, parents, pluginCallback);
            }, 1);
            dependencies.forEach(function(dep) {
                if (org.ekstep.pluginframework.env == 'renderer') {
                    if (dep.scope == org.ekstep.pluginframework.env || dep.scope == 'all') {
                        queue.push({ 'id': dep.plugin, 'ver': dep.ver, 'type': dep.type, 'pt': publishedTime }, function(err) {});
                    }
                } else {
                    queue.push({ 'id': dep.plugin, 'ver': dep.ver, 'type': dep.type, 'pt': publishedTime }, function(err) {});
                }
            });
            if (queue.length() > 0) {
                queue.drain = function() {
                    callback && callback();
                };
            } else {
                callback && callback();
            }
        } else {
            callback && callback();
        }
    },
    isManifestDefined: function(id) {
        if (this.pluginManifests[id]) {
            return true;
        } else {
            return false;
        }
    },
    isPluginDefined: function(id) {
        if (this.plugins[id]) {
            return true;
        } else {
            return false;
        }
    },
    loadPlugin: function(pluginId, pluginVer, callback) {
        this.loadPluginWithDependencies(pluginId, pluginVer, "plugin", undefined, [], function() {
           callback && callback();
        });
    },
    loadAllPlugins: function(plugins, otherDependencies, callback) {
        var instance = this;
        if (Array.isArray(plugins) && plugins.length) {
            var preloadPlugin = plugins.find(function(plugin) {
                return (plugin.preload === true || plugin.preload === 'true');
            });
            if(preloadPlugin) {
                instance.loadPlugin(preloadPlugin.id, preloadPlugin.ver, function() {
                    instance._loadPlugins(plugins, otherDependencies, callback);
                })
            } else {
                instance._loadPlugins(plugins, otherDependencies, callback);
            }
        } else if (Array.isArray(otherDependencies) && otherDependencies.length) {
            instance.loadOtherDependencies(otherDependencies, callback);
        } else {
            callback && callback();
        }
    },
    _loadPlugins: function(plugins, otherDependencies, callback) {
        var instance = this;
        var q = org.ekstep.pluginframework.async.queue(function(plugin, pluginCallback) {
            instance.loadPluginWithDependencies(plugin.id, plugin.ver, plugin.type, plugin.pt, [], pluginCallback);
        }, 6);
        q.drain = function() {
            instance.loadOtherDependencies(otherDependencies, callback);
        };
        plugins.forEach(function(plugin) {
            q.push({ 'id': plugin.id, 'ver': plugin.ver, 'type': plugin.type, 'pt': undefined }, function(err) {});
        });
    },
    loadOtherDependencies: function(otherDependencies, callback) {
        var instance = this;
        if (Array.isArray(otherDependencies) && otherDependencies.length) {
            var queue = org.ekstep.pluginframework.async.queue(function(dependency, cb) {
                if (dependency.type == 'plugin') {
                    instance.loadCustomPlugin(dependency, cb);
                } else {
                    org.ekstep.pluginframework.resourceManager.loadExternalResource(dependency.src, dependency.type, undefined, cb);
                }
            }, 1);
            otherDependencies.forEach(function(dep) {
                queue.push(dep, function(err) {});
            });
            if (queue.length() > 0) {
                queue.drain = function() {
                    callback && callback();
                };
            } else {
                callback && callback();
            }
        } else {
            callback && callback();
        }
    },
    invoke: function(id, data, parent, override) {
        var instance = this;
        var p = undefined;
        var plugin = this.plugins[id];
        if (!plugin) {
            this.addError('No plugin found for - ' + id);
        } else {
            var pluginClass = override ? plugin.p.extend(override) : plugin.p;
            var pluginManifest = plugin.m;
            try {
                if (Array.isArray(data)) {
                    data.forEach(function(d) {
                        p = new pluginClass(pluginManifest, d, parent);
                        instance.addPluginInstance(p);
                        p.initPlugin();
                        org.ekstep.pluginframework.eventManager.dispatchEvent('plugin:add', { plugin: pluginManifest.id, version: pluginManifest.ver, instanceId: p.id });
                        org.ekstep.pluginframework.eventManager.dispatchEvent(pluginManifest.id + ':add');
                    })
                } else {
                    p = new pluginClass(pluginManifest, data, parent);
                    instance.addPluginInstance(p);
                    p.initPlugin();
                    org.ekstep.pluginframework.eventManager.dispatchEvent('plugin:add', { plugin: pluginManifest.id, version: pluginManifest.ver, instanceId: p.id });
                    org.ekstep.pluginframework.eventManager.dispatchEvent(pluginManifest.id + ':add');
                }
            } catch (e) {
                org.ekstep.pluginframework.eventManager.dispatchEvent('plugin:error', { plugin: pluginManifest.id, version: pluginManifest.ver, action: "invoke", err: e });
                if(p) delete instance.pluginInstances[p.id];
                throw "Error: when instantiating plugin: "+ id;
            }
        }
        return p;
    },
    invokeRenderer: function(id, data, parent, stage, theme) {
        var instance = this;
        var p = undefined;
        var plugin = this.plugins[id];
        if (!plugin) {
            this.addError('No plugin found for - ' + id);
        } else {
            try {
                var pluginClass = plugin.p;
                var pluginManifest = plugin.m || { id: id, ver: undefined };
                if (Array.isArray(data)) {
                    data.forEach(function(d) {
                        p = new pluginClass(d, parent, stage, theme);
                        instance.addPluginInstance(p);
                        org.ekstep.pluginframework.eventManager.dispatchEvent('plugin:add', { plugin: pluginManifest.id, version: pluginManifest.ver, instanceId: p.id });
                        org.ekstep.pluginframework.eventManager.dispatchEvent(pluginManifest.id + ':add');
                    })
                } else {
                    p = new pluginClass(data, parent, stage, theme);
                    instance.addPluginInstance(p);
                    org.ekstep.pluginframework.eventManager.dispatchEvent('plugin:add', { plugin: pluginManifest.id, version: pluginManifest.ver, instanceId: p.id });
                    org.ekstep.pluginframework.eventManager.dispatchEvent(pluginManifest.id + ':add');
                }
            } catch (e) {
                org.ekstep.pluginframework.eventManager.dispatchEvent('plugin:error', { plugin: pluginManifest.id, version: pluginManifest.ver, action: "invoke", err: e });
                if(p) delete instance.pluginInstances[p.id];
                throw "Error: when instantiating plugin: "+ id;
            }
        }
        return p;
    },
    addPluginInstance: function(pluginObj) {
        this.pluginInstances[pluginObj.id] = pluginObj;
    },
    removePluginInstance: function(pluginObj) {        
        if (pluginObj) pluginObj.remove();
    },
    getPluginInstance: function(id) {
        return this.pluginInstances[id];
    },
    getPluginInstances: function() {
        return this.pluginInstances;
    },
    getPluginManifest: function(id) {
        var plugin = this.plugins[id] || this.pluginManifests[id];
        if (plugin) {
            return plugin.m;
        } else {
            return undefined;
        }
    },
    addError: function(error) {
        this.errors.push(error);
    },
    getErrors: function() {
        return this.errors;
    },
    cleanUp: function() {
        this.pluginInstances = {};
        this.pluginManifests = {};
        this.plugins = {};
        this.errors = [];
    },
    getPlugins: function() {
        return Object.keys(this.plugins);
    },
    getPluginType: function(id) {
        if (this.pluginInstances[id]) {
            return this.pluginInstances[id].getType();
        } else {
            return '';
        }
    },
    loadPluginResource: function(pluginId, pluginVer, src, dataType, callback) {
        if (this.plugins[pluginId]) {
            org.ekstep.pluginframework.resourceManager.getResource(pluginId, pluginVer, src, dataType, this.plugins[pluginId]['repo'], callback)
        } else {
            callback(new Error("unable load plugin resource " + src), undefined)
        }
    },
    getPluginVersion: function(id) {
        if (this.pluginInstances[id]) {
            return this.pluginInstances[id].getVersion();
        } else {
            return '';

        }
    },
    resolvePluginResource: function(id, ver, resource) {
        if (this.plugins[id] && this.plugins[id]["repo"]) {
            return this.plugins[id]["repo"].resolveResource(id, ver, resource);
        } else if(this.pluginManifests[id] && this.pluginManifests[id]["repo"]) {
            return this.pluginManifests[id]["repo"].resolveResource(id, ver, resource);
        } else {
            return false;
        }
    }
}));

/**
 * @author Santhosh Vasabhaktula <santhosh@ilimi.in>
 */
org.ekstep.pluginframework.keyboardManager = new (Class.extend({
	registry: {},
	registerKeyCombination: function(command, callback) {
		if(command !== undefined && callback !== undefined){
			Mousetrap.bind(command, callback);
		} else {
			throw "The given key combination is invalid.";
		}
	}
}));
/* istanbul ignore next */
org.ekstep.services.iService = Class.extend({
    /** 
     * @member {object} requestHeaders
     * @memberof org.ekstep.services.iService
     */
    requestHeaders: {
        "headers": {
            "content-type": "application/json",
            "user-id": "content-editor"
            ,"authorization": "Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJiYWYyYzg1OWIxMDg0NzhkYjMyNmYwZDQxNjMwZWMzMSJ9.YZjU6kKNg9F5BvS7JrXTfrxyTEULjR49v7wRD-CT9sg"
        }
    },
    getBaseURL: function() {
        return org.ekstep.services.config.baseURL;
    },
    getAPISlug: function() {
        return org.ekstep.services.config.apislug;
    },
    init: function(config) {
        this.initService(config);
    },
    initService: function(config) {},                
    _dispatchTelemetry: function(data) {
        var status = data.res.responseCode || data.res.statusText;
        org.ekstep.services.telemetryService.apiCall({ "path": encodeURIComponent(data.url), "method": data.method, "request": data.request, "response": "", "responseTime": data.res.responseTime, "status": status, "uip": "" });
    },
    get: function(url, config, cb) {
        var requestTimestamp, instance = this;
        config = config || {};
        config.headers = config.headers || {};
        if (typeof cb !== 'function') throw "iservice expects callback to be function";
        org.ekstep.pluginframework.jQuery.ajax({
            type: "GET",
            url: url,
            headers: config.headers,
            beforeSend: function(xhrObject, settings) {
                requestTimestamp = (new Date()).getTime();
            },
            success: function(res) {
                res.responseTime = (new Date()).getTime() - requestTimestamp;
                instance._dispatchTelemetry({url: url, method: "GET", request: "", res: res }); 
                res = { data: res };
                cb(null, res);                
            },
            error: function(err) {
                err.responseTime = (new Date()).getTime() - requestTimestamp;
                cb(err, null);
                instance._dispatchTelemetry({url: url, method: "GET", request: "", res: err });
            }
        });
    },
    post: function(url, data, config, cb) {
        var requestTimestamp, instance = this;
        data = data || {};
        config = config || {};
        config.headers = config.headers || {};
        if (typeof cb !== 'function') throw "iservice expects callback to be function";
        if (typeof data === 'object') data = JSON.stringify(data);
        org.ekstep.pluginframework.jQuery.ajax({
            type: "POST",
            url: url,
            data: data,
            headers: config.headers,
            beforeSend: function(xhrObject, settings) {
                requestTimestamp = (new Date()).getTime();
            },
            success: function(res) {
                res.responseTime = (new Date()).getTime() - requestTimestamp;
                instance._dispatchTelemetry({url: url, method: "POST", request: data, res: res }); 
                res = { data: res };
                cb(null, res);                
            },
            error: function(err) {
                err.responseTime = (new Date()).getTime() - requestTimestamp;
                cb(err, null);
                instance._dispatchTelemetry({url: url, method: "POST", request: data, res: err });
            }
        });
    },
    patch: function(url, data, config, cb) {
        var requestTimestamp, instance = this;
        data = data || {};
        config = config || {};
        config.headers = config.headers || {};
        if (typeof cb !== 'function') throw "iservice expects callback to be function";
        if (typeof data === 'object') data = JSON.stringify(data);
        org.ekstep.pluginframework.jQuery.ajax({
            type: "PATCH",
            url: url,
            data: data,
            headers: config.headers,
            beforeSend: function(xhrObject, settings) {
                requestTimestamp = (new Date()).getTime();
            },
            success: function(res) {
                res.responseTime = (new Date()).getTime() - requestTimestamp;
                instance._dispatchTelemetry({url: url, method: "PATCH", request: "", res: res });
                res = { data: res };
                cb(null, res);                
            },
            error: function(xhr, status, error) {
                xhr.responseTime = (new Date()).getTime() - requestTimestamp;
                cb(xhr, null);
                instance._dispatchTelemetry({url: url, method: "PATCH", request: "", res: xhr });
            }
        });
    },
    /**
     * Utility function which is used to call http post request
     * @param  {string}   url      API url
     * @param  {object}   data     APT request data
     * @param  {object}   headers  API headers
     * @param  {Function} callback returns error and response as arguments
     * @memberof org.ekstep.services.iService
     */
    postFromService: function(url, data, headers, callback) {
        this.post(url, JSON.stringify(data), headers, function(err, res) {
            callback(err, res)
        });
    },
    /**
     * Utility function which is used to call http get request
     * @param  {string}   url      API url
     * @param  {object}   headers  API headers
     * @param  {Function} callback returns error and response as arguments
     * @memberof org.ekstep.services.iService
     */
    getFromService: function(url, headers, callback) {
        this.get(url, headers, function(err, res) {
            callback(err, res);
        });
    }

});

/**
 * Content service helps to retrieve/save the content, content meta details by making call to learning API.
 * It also helps to download the content.
 *
 * @class org.ekstep.services.contentService
 * @author Sunil A S <sunils@ilimi.in>
 */
org.ekstep.services.contentService = new(org.ekstep.services.iService.extend({
    serviceURL: function() {
        return this.getBaseURL() + this.getAPISlug() + '/content/'
    },
    content: {},
    initService: function() {},
    /**
     *
     * content meta data fields
     *
     * @memberof org.ekstep.services.contentService
     */
    contentFields: "body,editorState,stageIcons,templateId,languageCode,template,gradeLevel,status,concepts,versionKey,name,appIcon,contentType,owner,domain,code,visibility,createdBy,description,language,mediaType,mimeType,osId,languageCode,createdOn,lastUpdatedOn,audience,ageGroup,attributions",
    /**
     *
     * sets content meta for the given content id
     * @param id {string}
     * @param contentMeta {object} content meta object
     * @private
     * @memberof org.ekstep.services.contentService
     */
    _setContentMeta: function(id, contentMeta) {
        /* istanbul ignore else */
        if (id && contentMeta) {
            var meta = {};
            for (k in contentMeta) {
                if (k != 'body' && k != 'stageIcons') {
                    meta[k] = contentMeta[k];
                }
            }
            this.content[id] = meta;
        }
    },
    /**
     *
     * returns content meta details
     * @param id {string} content id
     * @returns {object} if id is "undefined" returns empty object
     *
     * @memberof org.ekstep.services.contentService
     */
    getContentMeta: function(id) {
        return this.content[id] || {};
    },
    /**
     *
     * saves content body by making call to learing API
     * @param contentId {string} content id
     * @param metadata {object} meta data object
     * @param body {object} ECML JSON object of content
     * @param callback {function} callback function
     *
     * @memberof org.ekstep.services.contentService
     */
    saveContent: function(contentId, metadata, body, callback) {
        this._saveContent(contentId, metadata, body, callback);
    },
    /**
     *
     * saves content body by making call to learing API
     * @param contentId {string} content id
     * @param metadata {object} meta data object
     * @param body {object} ECML JSON object of content
     * @param callback {function} callback function
     * @private
     * @memberof org.ekstep.services.contentService
     *
     */
    _saveContent: function(contentId, metadata, body, callback) {

        var instance = this;
        var versionKey = instance.content[contentId] && instance.content[contentId].versionKey;

        if (contentId && versionKey) {
            var update = false;
            var content = {
                versionKey: versionKey,
                lastUpdatedBy: window.context.user.id
            }
            if (metadata) {
                update = true;
                for (k in metadata) {
                    content[k] = metadata[k];
                }
            }
            if (body) {
                content.compatibilityLevel = body.theme.compatibilityVersion;
                content['body'] = JSON.stringify(body);
                update = true;
            }
            if (update) {
                var requestObj = { request: { content: content } };
                instance.patch(this.serviceURL() + 'v3/update/' + contentId, requestObj, this.requestHeaders, function(err, res) {
                    /* istanbul ignore else */
                    if (res && res.data.responseCode == "OK") {
                        instance.content[contentId].versionKey = res.data.result.versionKey;
                        callback(undefined, res);
                    } else {
                        callback(true, err);
                    }
                });
            } else {
                callback('Nothing to save');
            }
        } else {
            callback('Cannot find content id or version key to update content');
        }
    },
    /**
     *
     *
     * retrieves the content and content meta details
     * @param contentId {string} content id
     * @param callback {function} callback function
     *
     * @memberof org.ekstep.services.contentService
     */
    getContent: function(contentId, callback) {
        var instance = this;
        if (contentId) {
            var metaDataFields = "?mode=edit&fields=" + instance.contentFields;
            instance.get(this.serviceURL() + 'v3/read/' + contentId + metaDataFields, this.requestHeaders, function(err, res) {
                /* istanbul ignore else */
                if (err) callback(err, undefined);
                if (!err && res.data && res.data.result && res.data.result.content) {
                    instance._setContentMeta(contentId, res.data.result.content);
                    callback(err, res.data.result.content);
                } else {
                    callback(new Error('no content found!'), undefined)
                }

            });
        } else {
            callback('Content id is required to get content from platform', undefined);
        }
    },
    /**
     *
     *
     * retrieves the versionKey
     * @param contentId {string} content id
     * @param callback {function} callback function
     *
     * @memberof org.ekstep.services.contentService
     */
    getContentVersionKey: function(contentId, callback) {
        var instance = this;
        if (contentId) {
            var metaDataFields = "?mode=edit&fields=" + "versionKey";
            instance.get(this.serviceURL() + 'v3/read/' + contentId + metaDataFields, this.requestHeaders, function(err, res) {
                if (!err && res.data && res.data.result && res.data.result.content) {
                    instance._setContentMeta(contentId, res.data.result.content);
                    callback(err, res.data.result.content);
                } else {
                    callback(new Error('no content found!'), undefined)
                }
            });
        } else {
            callback('Content id is required to get versionKey from platform', undefined);
        }
    },
    /**
     * retrieves template data of selected templateid
     * @param templateId {string} template id
     * @param callback {function} callback function
     * @memberof org.ekstep.services.contentService
     */
    getTemplateData: function(templateId, callback) {
        var instance = this;
        var templateMetaFields = "?taxonomyId=literacy_v2&fields=body,editorState,templateId,languageCode";
        instance.get(this.serviceURL() + 'v3/read/' + templateId + templateMetaFields, this.requestHeaders, function(err, res) {
            callback(err, res)
        });
    },
    /**
     *
     *
     * retrieves downloadable URL link to content
     * @param contentId {string} content id
     * @param fileName {string} "name" parameter of meta data object
     * @param callback {function} callback function
     *
     * @memberof org.ekstep.services.contentService
     */
    downloadContent: function(contentId, fileName, callback) {
        var data = { "request": { "content_identifiers": [contentId], "file_name": fileName } };
        this.postFromService(this.serviceURL() + 'v3/bundle', data, this.requestHeaders, callback);
    }
}));

/**
 *
 * Assessment service helps to get questions(items)
 * @class org.ekstep.services.assessmentService
 * @author Santhosh Vasabhaktula <santhosh@ilimi.in>
 */
org.ekstep.services.assessmentService = new(org.ekstep.services.iService.extend({
    /** 
     * @member {string} learningURL
     * @memberof org.ekstep.services.assessmentService
     */
    assessmentURL: function() {
        return this.getBaseURL() + this.getAPISlug() + '/assessment/'
    },
    /**
     * Get Questions from search API
     * @param  {object}   data     search filter data
     * @param  {Function} callback returns error and response as arguments
     * @memberof org.ekstep.services.assessmentService
     */
    getQuestions: function(data, callback) {
        org.ekstep.services.searchService.search(data, callback);
    },
    /**
     * Get selected Question(assessmentitem)
     * @param  {string}   itemId   selected question(assessmentitem) id
     * @param  {Function} callback returns error and response as arguments
     * @memberof org.ekstep.services.assessmentService
     */
    getItem: function(itemId, callback) {
        this.getFromService(this.assessmentURL() + '/v3/items/read/' + itemId, this.requestHeaders, callback);
    },
    /**
     * Get template data of selected question from content service API
     * @param  {string}   templateId selected question(assessmentitem) template id
     * @param  {Function} callback   returns error and response as arguments
     * @memberof org.ekstep.services.assessmentService
     */
    getTemplate: function(templateId, callback) {
        org.ekstep.services.contentService.getTemplateData(templateId, callback);
    }
}));

/**
 * Asset service provides access to the content API to save assets.
 * @class org.ekstep.services.assetService
 * @author Santhosh Vasabhaktula <santhosh@ilimi.in>
 */
org.ekstep.services.assetService = new(org.ekstep.services.iService.extend({
     /** 
     * @member {string} searchURL
     * @memberof org.ekstep.services.assetService
     */
    contentURL: function() {
        return this.getBaseURL() + this.getAPISlug() + '/content/'
    },
    asset: {},
    initService: function() {},
    /**
     * Set asset object
     * @param {string} id        
     * @param {object} assetMeta 
     * @memberof org.ekstep.services.assetService
     */
    setAssetMeta: function(id, assetMeta) {
        if (id && assetMeta) {
            if(this.asset[id] == undefined) this.asset[id] = {};
            this.asset[id].assetMeta = assetMeta;
        }
    },
    /**
     * get asset object
     * @param  {string} id 
     * @memberof org.ekstep.services.assetService
     */
    getAssetMeta: function(id) {
        return this.asset[id] || {};
    },
    /**
     * This method is used to save assets(audio & image)
     * @param  {string}   assetId
     * @param  {string}   content
     * @param  {Function} callback returns error and response as arguments
     * @memberof org.ekstep.services.assetService
     */
    saveAsset: function(assetId, content, callback) {
        var instance = this;

        var requestObj = {
            request: {
                content: content
            }
        };
        if (assetId) {
            instance.patch(this.contentURL() + 'v3/update/', requestObj, this.requestHeaders, function(err, res) {
                callback(err, res)
            });
        } else {
            instance.post(this.contentURL() + 'v3/create/', requestObj, this.requestHeaders, function(err, res) {
                callback(err, res)
            });
        }
    }
}));

/**
 * Service to get meta information from platform
 * 
 * @class org.ekstep.services.metaService
 * @author Santhosh Vasabhaktula <santhosh@ilimi.in>
 */
org.ekstep.services.metaService = new(org.ekstep.services.iService.extend({
    /** 
     * @member {string} learningURL
     * @memberof org.ekstep.services.metaService
     */
    metaURL: function() {
        return this.getBaseURL() + this.getAPISlug() + '/meta/'
    },
    /** 
     * @member {string} configURL
     * @memberof org.ekstep.services.metaService
     */
    configURL: function() {
        return this.getBaseURL() + this.getAPISlug() + '/config/'
    },
    /**
     * Returns the schema of the specified object. The schema will contain all the properties details (name, code, datatype, identifier etc,.).
     * @param  {string}   objectType  eg.AssessmentItem, Language etc.
     * @param  {Function} callback    returns error and response as arguments
     * @memberof org.ekstep.services.metaService
     */
    getDefinitions: function(objectType, callback) {
        this.getFromService(this.getBaseURL() + this.getAPISlug() + '/learning/' + 'taxonomy/domain/definition/'+ objectType, {"headers": {"content-type": "application/json","user-id": "content-editor"}}, callback);
    },
    /**
     * Returns all property values in the specified language.
     * @param  {string}   languageCode  eg. en, hi etc.
     * @param  {Function} callback      returns error and response as arguments
     * @memberof org.ekstep.services.metaService
     */
    getResourceBundles: function(languageCode ,callback) {
        this.getFromService(this.metaURL() + 'v3/resourcebundles/read/'+ languageCode, this.requestHeaders, callback);
    }
}));

/**
 * 
 * Language service helps to get languages and wordnet data.
 * @class org.ekstep.services.languageService
 * @author Santhosh Vasabhaktula <santhosh@ilimi.in>
 * 
 */
org.ekstep.services.languageService = new(org.ekstep.services.iService.extend({
    /** 
     * @member {string} learningURL
     * @memberof org.ekstep.services.languageService
     */
    learningURL: function() {
        return this.getBaseURL() + this.getAPISlug() + '/learning/'
    },
    /** 
     * @member {string} languageURL
     * @memberof org.ekstep.services.languageService
     */
    languageURL: function() { 
        return this.getBaseURL() + this.getAPISlug() + '/language/'
    },
    /** 
     * @member {object} wordHeaders
     * @memberof org.ekstep.services.languageService
     */
    wordHeaders: {
        "headers": {
            "Content-Type": "application/json",
            "Authorization": "Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiI5OGNlN2RmNmNkOTk0YWQ5YjZlYTRjNDJlNmVjYjY5MCJ9.rtr4188EwDYZywtP7S9uuv1LsivoucFxOvJFDCWvq0Y"
        }
    },
    /**
     * Get all list of languages
     * @param  {Function} callback returns error and response as arguments
     * @memberof org.ekstep.services.languageService
     */
    getLanguages: function(callback) {
        this.getFromService(this.languageURL() + 'v3/list', this.requestHeaders, callback);
    },
    /**
     * Get all list of vowel available in selected language
     * @param  {string}   language eg. en, hi etc.
     * @param  {Function} callback returns error and response as arguments
     * @memberof org.ekstep.services.languageService
     */
    getVowel: function(language, callback) {
        this.getFromService(this.languageURL() + 'v1/language/dictionary/varna/Vowel/list/' + language, this.requestHeaders, callback);
    },
    /**
     * Get all list of consonant available in selected language
     * @param  {string}   language eg. en, hi etc.
     * @param  {Function} callback returns error and response as arguments
     * @memberof org.ekstep.services.languageService
     */
    getConsonant: function(language, callback) {
        this.getFromService(this.languageURL() + 'v1/language/dictionary/varna/Consonant/list/' + language, this.requestHeaders, callback);
    },
    /**
     * Get all avalible words in given content
     * @param  {object}   data     request object contains filters, objectType, exists etc
     * @param  {Function} callback returns error and response as arguments
     * @memberof org.ekstep.services.languageService
     */
    getWords: function(data, callback) {
        this.postFromService(this.languageURL() + 'v3/search', data, this.wordHeaders, callback);
    },
    /**
     * Get types of word. eg. Nouns, verbs etc 
     * @param  {Function} callback returns error and response as arguments
     * @memberof org.ekstep.services.languageService
     */
    getWordDefinition: function(callback) {
        this.getFromService(this.learningURL() + 'taxonomy/en/definition/Word', this.requestHeaders, callback);
    },
    /**
     * Get all avalible keywords in given content
     * @param  {object}   data     request object
     * @param  {Function} callback returns error and response as arguments
     * @memberof org.ekstep.services.languageService
     */
    getKeyWords: function(data, callback) {
        this.postFromService(this.languageURL() + 'v3/tools/parser', data, this.requestHeaders, callback);
    },
    /**
    * Transliterates english text to specified language and invokes a callback
    * @param {Object} data - object containing english text and array of languages
    * @param {Function} callback - Callback when api call returns
    * @return {void}
    */
    getTransliteration: function(data, callback) {
        this.postFromService(this.languageURL() + "v3/tools/transliterate?lemma=" + data.text + "&languages="+ data.languages.toString() , {"request": {}}, this.requestHeaders, callback);
    },
    /**
     * Translates word in provided languages
     * @param {Object} req contain requested data
     * @param {Function} callback, callback function
     */
    getTranslation:  function(data, callback) {
        this.postFromService(this.languageURL() + "v3/tools/translate?language_id="+ data.wordLang + '&lemma=' + data.word + '&languages=' + data.languages, {"request": {}}, this.requestHeaders, callback);
    }
}));

/**
 * Search service provides capability to search content(activities, question etc.) from  composite search API.
 * 
 * @class org.ekstep.services.searchService
 * @author Santhosh Vasabhaktula <santhosh@ilimi.in>
 */
org.ekstep.services.searchService = new(org.ekstep.services.iService.extend({
    /** 
     * @member {string} searchURL
     * @memberof org.ekstep.services.searchService
     */
    searchURL: function() {
        return this.getBaseURL() + this.getAPISlug() + '/composite/'
    },
    initService: function() {},
    /**
     * Search method helps to get the content from search API
     * @param  {object}   request  request object will take all request parameters of search API
     * @param  {Function} callback returns error and response as arguments
     * @memberof org.ekstep.services.searchService
     */
    search: function(request, callback) {
        this.postFromService(this.searchURL() + 'v3/search', request, this.requestHeaders, callback);
    }
}));

/**
 * @author Harish kumar Gangula<harishg@ilimi.in>
 */
org.ekstep.pluginframework.iRepo = Class.extend({
    discoverManifest: function(pluginId, pluginVer, callback) {
    	callback(undefined, undefined);
    },
    resolveResource: function(pluginId, pluginVer, resource) {}
});

/**
 * @author Harish kumar Gangula<harishg@ilimi.in>
 */
org.ekstep.pluginframework.publishedRepo = new(org.ekstep.pluginframework.iRepo.extend({
    id: "published",
    discoverManifest: function(pluginId, pluginVer, callback, publishedTime) {
        var instance = this;
        org.ekstep.pluginframework.resourceManager.loadResource(this.resolveResource(pluginId, pluginVer, "manifest.json"), "json", function(err, response) {
            callback(undefined, { "manifest": response, "repo": instance });
        }, publishedTime);
    },
    resolveResource: function(id, ver, resource) {        
    	return org.ekstep.pluginframework.config.pluginRepo + "/" + id + "-" + ver + "/" + resource;
    }
}));
org.ekstep.pluginframework.resourceManager.addRepo(org.ekstep.pluginframework.publishedRepo);
/**
 * @author Santhosh Vasabhaktula <santhosh@ilimi.in>
 */
/* istanbul ignore next. Fabric extension - cannot be tested */
window.fabric.Object.prototype.toObject = (function(toObject) {
    return function() {
        return window.fabric.util.object.extend(toObject.call(this), {
            meta: this.meta
        });
    };
})(window.fabric.Object.prototype.toObject);


var content_editor = function() {};
content_editor.prototype.jQuery = window.$;
content_editor.prototype._ = window._;
window.org.ekstep.contenteditor = new content_editor();
content_editor = undefined;

window.ServiceConstants = {
    SEARCH_SERVICE: "search",
    POPUP_SERVICE: "popup",
    CONTENT_SERVICE: "content",
    ASSESSMENT_SERVICE: "assessment",
    LANGUAGE_SERVICE: "language",
    META_SERVICE: "meta",
    ASSET_SERVICE: "asset",
    TELEMETRY_SERVICE: "telemetry"
}

window.ManagerConstants = {
    EVENT_MANAGER: "event",
    MEDIA_MANAGER: "media",
    PLUGIN_MANAGER: "plugin",
    RESOURCE_MANAGER: "resource",
    STAGE_MANAGER: "stage",
    TOOLBAR_MANAGER: "toolbar"
}
org.ekstep.contenteditor.config = {
    baseURL: 'https://dev.ekstep.in',
    apislug: '/api',
    defaultSettings: 'config/editorSettings.json',
    build_number: 'BUILDNUMBER',
    pluginRepo: '/plugins',
    aws_s3_urls: ["https://s3.ap-south-1.amazonaws.com/ekstep-public-dev/", "https://ekstep-public-dev.s3-ap-south-1.amazonaws.com/"],
    corePlugins: ["text", "audio", "div", "hotspot", "image", "shape", "scribble", "htext"],
    corePluginMapping: {
        "text": "org.ekstep.text", 
        "image": "org.ekstep.image", 
        "shape": "org.ekstep.shape",
        "stage": "org.ekstep.stage",
        "hotspot": "org.ekstep.hotspot",
        "scribble": "org.ekstep.scribblepad",
        "htext": "org.ekstep.text",
        "audio": "org.ekstep.audio"
    },
    baseConfigManifest: "config/baseConfigManifest.json",
    plugins: [
        { "id": "org.ekstep.developer", "ver": "1.0", "type": "plugin" },
        { "id": "org.ekstep.ceheader", "ver": "1.0", "type": "plugin" }
    ],
    corePluginsPackaged: true,
    dispatcher: "local",
    useProxyForURL: true
}

org.ekstep.contenteditor.baseConfigManifest = [{
    "propertyName": "autoplay",
    "title": "Auto play",
    "description": "Set the element's playability",
    "dataType": "boolean",
    "required": true,
    "defaultValue": false
}, {
    "propertyName": "visible",
    "title": "Visible",
    "description": "Set the element's Visibility",
    "dataType": "boolean",
    "required": true,
    "defaultValue": true
}, {
    "propertyName": "stroke",
    "title": "Border Color",
    "description": "Set the border color for element",
    "dataType": "colorpicker",
    "required": true,
    "defaultValue": "rgba(255, 255, 255, 0)"
}]
/**
 * @author Santhosh Vasabhaktula <santhosh@ilimi.in>
 */

org.ekstep.contenteditor.init = function(context, config, $scope, $document, callback) {
    org.ekstep.contenteditor._mergeConfig(config);
    org.ekstep.contenteditor._initServices();
    org.ekstep.contenteditor.globalContext = context;
    org.ekstep.contenteditor.toolbarManager.setScope($scope);
    org.ekstep.contenteditor._loadDefaultPlugins(context, callback);
    //org.ekstep.contenteditor._backwardCompatibility();
}

org.ekstep.contenteditor._backwardCompatibility = function() {
    /* Deprecated variables */
    EkstepEditorAPI.apislug = org.ekstep.contenteditor.config.apislug;
    EkstepEditorAPI.baseURL = org.ekstep.contenteditor.config.baseURL;
    EkstepEditorAPI.absURL = org.ekstep.contenteditor.config.absURL;
    EkstepEditorAPI.globalContext = org.ekstep.contenteditor.globalContext;
}

org.ekstep.contenteditor._initServices = function() {
    org.ekstep.services.config = {
        baseURL: org.ekstep.contenteditor.config.baseURL,
        apislug: org.ekstep.contenteditor.config.apislug
    }
    org.ekstep.pluginframework.initialize({
        env: 'editor',
        jQuery: org.ekstep.contenteditor.jQuery,
        pluginRepo: org.ekstep.contenteditor.config.pluginRepo,
        build_number: org.ekstep.contenteditor.config.build_number
    });
}

org.ekstep.contenteditor._mergeConfig = function(config) {
    config = config || {};
    org.ekstep.contenteditor.config = _.assign(org.ekstep.contenteditor.config, config);
}

org.ekstep.contenteditor._loadDefaultPlugins = function(context, callback) {
    var startTime = (new Date()).getTime();
    if (org.ekstep.contenteditor.config.corePluginsPackaged === true) org.ekstep.contenteditor.jQuery("body").append($("<script type='text/javascript' src='scripts/coreplugins.js?" + org.ekstep.contenteditor.config.build_number + "'>"));
    org.ekstep.pluginframework.eventManager.enableEvents = false;
    org.ekstep.pluginframework.pluginManager.loadAllPlugins(org.ekstep.contenteditor.config.plugins, undefined, function() {

        org.ekstep.services.telemetryService.initialize({
            uid: context.uid,
            sid: context.sid,
            content_id: context.contentId
        }, org.ekstep.contenteditor.config.dispatcher);
        org.ekstep.pluginframework.eventManager.enableEvents = true;
        callback();
        org.ekstep.services.telemetryService.startEvent().append("loadtimes", { plugins: ((new Date()).getTime() - startTime) });        
    });
}

// Prepare context and config data from url/parentwindow/window
// org.ekstep.contenteditor.window_context = {}
// org.ekstep.contenteditor.window_config = {}
// getWindowContext();
// getWindowConfig();
// 
org.ekstep.contenteditor.getWindowContext = function() {
    var context = org.ekstep.contenteditor.getParameterByName('context') || (window.parent ? window.parent.context : undefined) || window.context;
    org.ekstep.contenteditor.window_context = {
        uid: context.user.id,
        sid: context.sid,
        contentId: context.contentId
    }
    return org.ekstep.contenteditor.window_context;
}

org.ekstep.contenteditor.getWindowConfig = function() {
    var config = org.ekstep.contenteditor.getParameterByName('config') || (window.parent ? window.parent.config : undefined) || window.config;
    org.ekstep.contenteditor.window_config = {};
    if (config) {
        org.ekstep.contenteditor.window_config = {
            baseURL: config.baseURL,
            pluginRepo: config.pluginRepo,
            plugins: config.plugins,
            corePluginsPackaged: config.enableCorePlugin
        }
    }

    return org.ekstep.contenteditor.window_config;
}

org.ekstep.contenteditor.getParameterByName = function(name, url) {
    if (!url) url = window.location.href;
    name = name.replace(/[\[\]]/g, "\\$&");
    var regex = new RegExp("[?&]" + name + "(=([^&#]*)|&|#|$)"),
        results = regex.exec(url);
    if (!results) return null;
    if (!results[2]) return '';
    return decodeURIComponent(results[2].replace(/\+/g, " "));
}

/**
 * The Content Editor API is the core interface of the plugins with the rest of the editor framework. It allows the plugins
 * to access the framework resources, launch popups, and handle events raised by the framework. Plugins should not call any
 * other framework classes directly.
 * 
 * @class org.ekstep.contenteditor.api
 * @author Santhosh Vasabhaktula <santhosh@ilimi.in>
 */
window.org.ekstep.contenteditor.api = {
    /**
     * Handle for JQuery. All plugins should use this instead of using '$' directly
     * 
     * @member {Object} jQuery
     * @memberof org.ekstep.contenteditor.api
     */
    jQuery: org.ekstep.contenteditor.jQuery,

    /**
     * Handle for Lodash Library. All plugins should use this instead of using '_' directly
     * 
     * @member {Object} _
     * @memberof org.ekstep.contenteditor.api
     */
    _: org.ekstep.contenteditor._,

    /**
     * Add an object to the context
     * 
     * @param {String} key   Key
     * @param {Object} value Value
     * @memberof org.ekstep.contenteditor.api
     */
    setContext: function(key, value) {
        org.ekstep.contenteditor.globalContext[key] = value;
    },

    /**
     * Get the context variable
     * 
     * @param  {String} key Key
     * @return {object}     Value
     * @memberof org.ekstep.contenteditor.api
     */
    getContext: function(key) {
        return org.ekstep.contenteditor.globalContext[key];
    },

    /**
     * Get all context attributes
     * @return {map} Map of key values
     */
    getAllContext: function() {
        return org.ekstep.contenteditor.globalContext;
    },

    /**
     * Add or update a configuration property
     * 
     * @param {String} key   Key
     * @param {Object} value Value
     * @memberof org.ekstep.contenteditor.api
     */
    setConfig: function(key, value) {
        org.ekstep.contenteditor.config[key] = value;
    },

    /**
     * Get the config variable
     * 
     * @param  {String} key Key
     * @return {object}     Value
     * @memberof org.ekstep.contenteditor.api
     */
    getConfig: function(key) {
        return org.ekstep.contenteditor.config[key];
    },

    /**
     * Get all config attributes
     * @return {map} Map of key values
     */
    getAllConfig: function() {
        return org.ekstep.contenteditor.config;
    },

    /**
     * Register an event listener callback function for the events raised by the framework.
     * @param type {string} name of the event (e.g. org.ekstep.quickstart:configure)
     * @param callback {function} callback function
     * @param scope {object} the scope of the callback (use this)
     * @memberof org.ekstep.contenteditor.api
     */
    addEventListener: function(type, callback, scope) {
        org.ekstep.pluginframework.eventManager.addEventListener(type, callback, scope);
    },

    /**
     * Fires an event to the framework, allowing other plugins who may have registered to receive the callback notification. All
     * communication between the framework and other plugins is via the events.
     * @param type {string} name of the event to fire (e.g. org.ekstep.quickstart:configure)
     * @param data {object} event data to carry along with the notification
     * @param target {object} the scope of the event (use this)
     * @memberof org.ekstep.contenteditor.api
     */
    dispatchEvent: function(type, data, target) {
        org.ekstep.pluginframework.eventManager.dispatchEvent(type, data, target);
    },

    /**
     * Remove an event listener to an event. Plugins should cleanup when they are removed.
     * @param type {string} name of the event registered with (e.g. org.ekstep.quickstart:configure)
     * @param callback {function} remove the callback function
     * @param scope {object} the scope of the event (use this)
     * @memberof org.ekstep.contenteditor.api
     */
    removeEventListener: function(type, callback, scope) {
        org.ekstep.pluginframework.eventManager.removeEventListener(type, callback, scope);
    },

    /**
     * Framework support to load plugin resources. When the resources are loaded, the callback is fired.
     * @param pluginId {string} id of the plugin requesting resource to be loaded
     * @param pluginVer {string} version of the plugin that is requesting the resource to be loaded
     * @param src {string} URL of the resource to be loaded
     * @param dataType {object} dataType of the resource (image, or audio)
     * @param callback {function} callback function whent he resource is available
     * @memberof org.ekstep.contenteditor.api
     */
    loadPluginResource: function(pluginId, pluginVer, src, dataType, callback) {
        org.ekstep.pluginframework.pluginManager.loadPluginResource(pluginId, pluginVer, src, dataType, callback);
    },

    /**
     * Returns the handle to the Angular services. The services can be used by plugisn to achieve
     * the functional calls or render custom views. Valid services are:
     *     popup - UI service to render popup
     *     content - Provides access to the content API (for loading templates and assets)
     *     assessment - Provides access to the assessment API (for loading questions)
     *     language - Provides access to the wordnet API (for loading words and aksharas)
     *     search - Provides access to search API (for search activities, question, domains)
     *     meta - Provides access to metadata API (for resource bundles, ordinals, definitions)
     *     asset - Provides access to the content API (for save assets)
     *     telemetry - Service to genarate and log telemetry events
     * @param serviceId {string} id of the service to return. Returns undefined if the id is invalid
     * @memberof org.ekstep.contenteditor.api
     */
    getService: function(serviceId) {
        var service = '';
        switch (serviceId) {
            case ServiceConstants.POPUP_SERVICE:
                service = org.ekstep.services.popupService;
                break;
            case ServiceConstants.CONTENT_SERVICE:
                service = org.ekstep.services.contentService;
                break;
            case ServiceConstants.ASSESSMENT_SERVICE:
                service = org.ekstep.services.assessmentService;
                break;
            case ServiceConstants.LANGUAGE_SERVICE:
                service = org.ekstep.services.languageService;
                break;
            case ServiceConstants.SEARCH_SERVICE:
                service = org.ekstep.services.searchService;
                break;
            case ServiceConstants.META_SERVICE:
                service = org.ekstep.services.metaService;
                break;
            case ServiceConstants.ASSET_SERVICE:
                service = org.ekstep.services.assetService;
                break;
            case ServiceConstants.TELEMETRY_SERVICE:
                service = org.ekstep.services.telemetryService;
                break;
        }
        return service;
    },

    /**
     * Returns the angular scope object for the plugins that need angular framework to render. The editor
     * uses Angular 2 and plugins must use this to access the scope instead of instantiating Angular by
     * themselves.
     * @memberof org.ekstep.contenteditor.api
     */
    getAngularScope: function() {
        return org.ekstep.contenteditor.toolbarManager.scope;
    },

    /**
     * Returns the HTML5 canvas for rendering on the editor. By default, the editor uses Fabric.js and recommends
     * the plugins to also use Fabric.js for rendering the WYSIWYG components on the editor canvas. However,
     * this method provides access to the underlying native HTML5 canvas if needed. For example, if your plugin
     * uses some other third-party graphics library for rendering.
     * @memberof org.ekstep.contenteditor.api
     */
    getCanvas: function() {
        return org.ekstep.contenteditor.stageManager.canvas;
    },

    /**
     * Retrns the current stage object to the plugin. Plugins might use this to query other objects on the
     * canvas or access other stage context.
     * @memberof org.ekstep.contenteditor.api
     */
    getCurrentStage: function() {
        return org.ekstep.contenteditor.stageManager.currentStage;
    },

    /**
     * Retrns the specified stage to the plugin. This can be used to build scenarios where a plugin might be
     * linking multiple stages together (e.g. when building navigation plugins).
     * @memberof org.ekstep.contenteditor.api
     */
    getStage: function(stageId) {
        return org.ekstep.contenteditor.stageManager.getStage(stageId);
    },

    /**
     * Refreshes the rendering of stages - plugins can request the stages to be refreshed if any change
     * has been made.
     * @memberof org.ekstep.contenteditor.api
     */
    refreshStages: function() {
        /* istanbul ignore next */
        org.ekstep.contenteditor.api.ngSafeApply(org.ekstep.contenteditor.api.getAngularScope(), function() { org.ekstep.contenteditor.toolbarManager.scope.stages = org.ekstep.contenteditor.stageManager.stages; });
    },

    /**
     * Returns the currently selected active object on the canvas. This can be used by plugins to provide
     * contextual support - e.g. show words for a given text object when the text is selected.
     * @memberof org.ekstep.contenteditor.api
     */
    getCurrentObject: function() {
        var activeObj = org.ekstep.contenteditor.stageManager.canvas.getActiveObject();
        if (!activeObj) return false;
        var pluginId = activeObj.id;
        return org.ekstep.contenteditor.api.getPluginInstance(pluginId);
    },

    /**
     * Returns the current group of selected objects. This is possible when a user does multi-select by
     * clicking on multiple objects or by panning on the canvas.
     * @memberof org.ekstep.contenteditor.api
     */
    getCurrentGroup: function() {
        if(org.ekstep.contenteditor.stageManager.canvas.getActiveGroup()){
        var plugins = org.ekstep.contenteditor.stageManager.canvas.getActiveGroup()._objects;
        var group = [];
        _.forEach(plugins, function(plugins, index) {
            var obj = org.ekstep.contenteditor.api.getPluginInstance(plugins.id);
            group.push(obj);
        });
        return group;
        }
    },

    /**
     * Retrns the current group on the fabric canvas. This provides access to the fabric object. If you
     * want to access the plugin instance that is currently selected, use getCurrentGroup() instead.
     * @memberof org.ekstep.contenteditor.api
     */
    getEditorGroup: function() {
        var group = org.ekstep.contenteditor.stageManager.canvas.getActiveGroup();
        return group;
    },

    /**
     * Retrns the current object on the fabric canvas. This provides access to the fabric object. If you
     * want to access the plugin instance that is currently selected, use getCurrentObject() instead.
     * @memberof org.ekstep.contenteditor.api
     */
    getEditorObject: function() {
        return org.ekstep.contenteditor.stageManager.canvas.getActiveObject();
    },

    /**
     * Notifies the framework to render the canvas once again. This can be done by the plugin when
     * its config or state is modified via the config views.
     * @memberof org.ekstep.contenteditor.api
     */
    render: function() {
        org.ekstep.contenteditor.stageManager.canvas.renderAll();
    },

    /**
     * Returns a plugin instance for the given plugin ID. Plugins can use this work with dependencies
     * or build plugins that enhance the behavior of other plugins.
     * @memberof org.ekstep.contenteditor.api
     */
    getPluginInstance: function(pluginId) {
        return org.ekstep.pluginframework.pluginManager.getPluginInstance(pluginId);
    },

    /**
     * Allows the plugins to request an update to the context menu when one or more objects are selected.
     * This can be used by a plugin to add more actions to the context menu - e.g. when a text is selected,
     * a word parser plugin can add context menu for spell check, or for adding word definition popups.
     * @param menu {object} Menu item to add - see the manifest for the structre of the menu item
     * @memberof org.ekstep.contenteditor.api
     */
    updateContextMenu: function(menu) {
        org.ekstep.contenteditor.toolbarManager.updateContextMenu([menu]);
    },

    /**
     * Allows the plugins to request an update to the context menu by supplying multiple menu items.
     * This can be used by a plugin to add more actions to the context menu - e.g. when a text is selected,
     * a word parser plugin can add context menu for spell check, or for adding word definition popups.
     * @param menu {array} Array of menu items to add - see the manifest for the structre of the menu item
     * @memberof org.ekstep.contenteditor.api
     */
    updateContextMenus: function(menus) {
        org.ekstep.contenteditor.toolbarManager.updateContextMenu(menus);
    },
    updateSidebarMenu: function(menu) {
        org.ekstep.contenteditor.sidebarManager.updateSidebarMenu(menu);        
    },
    /**
     * Allows the plugins to request loading and instantiating another plugin. This is useful when
     * a plugin depends upon other plugins - e.g. a wordpicker might dependend upon an asset picker.
     * @param id {string} Fully qualified plugin id to load and instantiate
     * @param data {object} Data to be passed during instantiation (initial state)
     * @param parent {object} Parent scope - use this
     * @param override {object} Any function overrides - e.g. you can override the handlers of the plugin
     * @see org.ekstep.composite-text-image-shape plugin for a sample of leveraging this.
     * @memberof org.ekstep.contenteditor.api
     */
    instantiatePlugin: function(id, data, parent, override) {
        return org.ekstep.pluginframework.pluginManager.invoke(id, data, parent, override);
    },

    /**
     * Plugins can instantiate a stage and add it to the content. This can be done by special plugins that
     * work at a stage level or cause multiple stages to be added based on the configuration.
     * @param stage {object} Stage to add to the content
     * @memberof org.ekstep.contenteditor.api
     */
    addStage: function(stage) {
        org.ekstep.contenteditor.stageManager.addStage(stage);
    },

    /**
     * Lookup for another plugin in the current plugin manager scope.
     * @param id {string} Plugin id to return. Undefined if the plugin has not been loaded.
     * @memberof org.ekstep.contenteditor.api
     */
    getPlugin: function(id) {
        return org.ekstep.pluginframework.pluginManager.plugins[id];
    },

    /**
     * Adds a plugin instance to the manager. This may be used when a plugin instantiates other plugins. The
     * newly instantiated plugins are added to the framework's registry, making them discoverable by others.
     * Useful for scenarios where plugins depend on others, or composite plugins.
     * @param pluginInstance {object} Plugin object instantiated by this plugin.
     * @memberof org.ekstep.contenteditor.api
     */
    addPluginInstance: function(pluginInstance) {
        org.ekstep.pluginframework.pluginManager.addPluginInstance(pluginInstance);
    },

    /**
     * Removes a plugin instance from the manager. Do this only if you instantiated the plugin using addPluginInstance()
     * @param pluginInstance {object} Plugin object instantiated by this plugin.
     * @memberof org.ekstep.contenteditor.api
     */
    removePluginInstance: function(pluginInstance) {
        org.ekstep.pluginframework.pluginManager.removePluginInstance(pluginInstance);
    },

    /**
     * Creates a deep copy of the given plugin object with an offset x and y position. This is useful when
     * you are building plugins that enable copy paste type functionality for example.
     * @param pluginInstance {object} Plugin object instantiated by this plugin.
     * @memberof org.ekstep.contenteditor.api
     */
    cloneInstance: function(plugin) {
        var data = plugin.getCopy();
        data = _.omit(data, ["id", "event"]);
        if (plugin.parent.id == org.ekstep.contenteditor.api.getCurrentStage().id) {
            data.x = data.x + 2;
            data.y = data.y + 2;
        }
        org.ekstep.contenteditor.api.instantiatePlugin(plugin.manifest.id, data, org.ekstep.contenteditor.api.getCurrentStage());
    },

    /**
     * Returns all stages in the current document. This could be useful when plugins work across stages
     * such as timers that work across stages or page number plugins. Using this, a plugin can get access to all
     * stages, and instantiate plugins on each stage.
     * @memberof org.ekstep.contenteditor.api
     */
    getAllStages: function() {
        return org.ekstep.contenteditor.stageManager.stages;
    },

    /**
     * Selector for plugins of a given type in the document. This can be used by plugins to discover other
     * instances of the same plugin, or other plugins that are compatible with this plugin. E.g. a wordnet
     * plugin might use this to discover all other text plugins in the content.
     * 
     * @param  {String} stage        Stage ID
     * @param  {Array} includeTypes Include plugins
     * @param  {Array} excludeTypes Exclude plugins
     * @param  {Array} excludeIds   Exclude specific plugin instances
     * @return {Array}              Array of plugin instances matching the given criteria
     * @memberof org.ekstep.contenteditor.api
     */
    getStagePluginInstances: function(stage, includeTypes, excludeTypes, excludeIds) {
        // TODO: Add logic to check if stage exists
        var instances = _.clone(org.ekstep.contenteditor.api.getStage(stage).children);
        if (includeTypes) {
            instances = _.filter(instances, function(obj) {
                return includeTypes.indexOf(obj.manifest.id) != -1;
            });
        }
        if (excludeTypes) {
            instances = _.filter(instances, function(obj) {
                return excludeTypes.indexOf(obj.manifest.id) == -1;
            });
        }
        if (excludeIds) {
            instances = _.filter(instances, function(obj) {
                return excludeIds.indexOf(obj.id) == -1;
            });
        }
        return instances;
    },

    /**
     * Get matching plugin instances. This function returns instances across all stages matching the given criteria
     * 
     * @param  {Array} includeTypes Include plugins
     * @param  {Array} excludeTypes Exclude plugins
     * @param  {Array} excludeIds   Exclude specific plugin instances
     * @return {Array}              Array of plugin instances matching the given criteria
     * @memberof org.ekstep.contenteditor.api
     */
    getPluginInstances: function(includeTypes, excludeTypes, excludeIds) {
        var instances = _.clone(org.ekstep.pluginframework.pluginManager.pluginInstances);
        if (includeTypes) {
            instances = _.filter(instances, function(obj) {
                return includeTypes.indexOf(obj.manifest.id) != -1;
            });
        }
        if (excludeTypes) {
            instances = _.filter(instances, function(obj) {
                return excludeTypes.indexOf(obj.manifest.id) == -1;
            });
        }
        if (excludeIds) {
            instances = _.filter(instances, function(obj) {
                return excludeIds.indexOf(obj.id) == -1;
            });
        }
        return instances;
    },

    /**
     * Allows plugins to load a media object that they may depend upon.
     * @param assetId {string} ID of the media asset to load
     * @memberof org.ekstep.contenteditor.api
     */
    getMedia: function(assetId) {
        return org.ekstep.contenteditor.mediaManager.getMedia(assetId);
    },

    /**
     * Get the media asset's reverse proxy URL
     * @param  {String} url Fully qualified URL
     * @return {String}     Reverse proxied URL
     * @memberof org.ekstep.contenteditor.api
     */
    getMediaReverseProxyURL: function(url) {
        return org.ekstep.contenteditor.mediaManager.getMediaOriginURL(url);
    },

    /**
     * API to load a plugin dynamically. Any plugin to be loaded should be ideally declared as dependency in the manifest.
     * 
     * @param  {String} pluginId      Plugin ID
     * @param  {String} pluginVersion Plugin Version
     * @memberof org.ekstep.contenteditor.api
     */
    loadPlugin: function(pluginId, pluginVersion, callback) {
        org.ekstep.pluginframework.pluginManager.loadPluginWithDependencies(pluginId, pluginVersion, "plugin", undefined, [], callback);
    },

    /**
     * Utility API to update the plugin dimenstions once any action like - move, resize etc are performed
     * 
     * @param  {Object} inst Plugin Instance
     * @memberof org.ekstep.contenteditor.api
     */
    updatePluginDimensions: function(inst) {
        inst.attributes.x = inst.editorObj.getLeft();
        inst.attributes.y = inst.editorObj.getTop();
        inst.attributes.w = inst.editorObj.getWidth() - inst.editorObj.getStrokeWidth();
        inst.attributes.h = inst.editorObj.getHeight() - inst.editorObj.getStrokeWidth();
        inst.attributes.rotate = inst.editorObj.getAngle();
        if (_.isFunction(inst.editorObj.getRx))
            inst.attributes.r = inst.editorObj.getRx();
    },
    ngSafeApply: function(scope, fn) {
        if (scope) scope.$safeApply(fn);
    },
    /**
     * API to load and initialize a plugin to the current stage
     * 
     * @param  {String} pluginId      Plugin ID
     * @param  {String} pluginVersion Plugin Version
     * @param  {Long} publishedTime   Plugin published timestamp (for cache busting)
     * @param {Class} parent          Parent for the plugin
     * @memberof org.ekstep.contenteditor.api
     */
    loadAndInitPlugin: function(pluginId, pluginVersion, publishedTime, parent) {
        parent = parent || this.getCurrentStage();
        org.ekstep.pluginframework.pluginManager.loadAndInitPlugin(pluginId, pluginVersion, publishedTime, parent);
    },

    /**
     * API to Resolve plugin resource URL. This API would resolve to the repo the plugin is loaded from.
     * 
     * @param  {String} pluginId      Plugin ID
     * @param  {String} pluginVersion Plugin Version
     * @param  {String} resource resource relative URL
     * @return {String}          Resolved URL
     * @memberof org.ekstep.contenteditor.api
     */
    resolvePluginResource: function (id, ver, resource) {
         return org.ekstep.pluginframework.pluginManager.resolvePluginResource(id, ver, resource);
    },

    /**
     * API to register for a keyboard command
     * 
     * @param  {String}   command  Key combination. For ex: ctrl+s, ctrl+c etc
     * @param  {Function} callback Callback to invoke when the key is pressed
     * @memberof org.ekstep.contenteditor.api
     */
    registerKeyboardCommand: function(command, callback) {
        org.ekstep.pluginframework.keyboardManager.registerKeyCombination(command, callback);
    },
    addResourceRepository: function(repo, position) {
        if (repo) org.ekstep.pluginframework.resourceManager.addRepo(repo, position);
    },
    showSidebarMenu: function(sidebarMenuId) {
        org.ekstep.contenteditor.sidebarManager.showSidebarMenu(sidebarMenuId)
    },
    getCurrentSidebarMenu: function() {
        return org.ekstep.contenteditor.sidebarManager.getCurrentMenu();
    }     
}

window.ecEditor = window.org.ekstep.contenteditor.api;
/**
 * The base plugin class that all editor plugins inherit from. It provides the common support contract for all plugins.
 * Plugins can override specific methods to change the behavior. The most common scenario would be to override the
 * implementation of fabric callback methods to detect interactivity on the canvas.
 *
 * @class org.ekstep.contenteditor.basePlugin
 * @author Santhosh Vasabhaktula <santhosh@ilimi.in>
 */
org.ekstep.contenteditor.basePlugin = Class.extend({
    id: undefined,
    parent: undefined,
    children: [],
    manifest: undefined,
    editorObj: undefined,
    editorData: undefined,
    data: undefined,
    attributes: { x: 0, y: 0, w: 0, h: 0, visible: true, editable: true },
    config: undefined,
    event: undefined,
    events: undefined,
    params: undefined,
    media: undefined,
    configManifest: undefined,

    /**
     * Initializes the plugin with the given manifest and parent object
     * @param manifest {object} Manifest details for this plugin
     * @param data {object} Init parameters for the plugin
     * @param parent {object} Parent plugin object that instantiated this
     * @constructor
     * @memberof org.ekstep.contenteditor.basePlugin
     */
    init: function(manifest, data, parent) {
        var instance = this;
        this.manifest = _.cloneDeep(manifest);
        if (arguments.length == 1) {
            this.registerMenu();
            this.initialize();
            org.ekstep.contenteditor.api.addEventListener(this.manifest.id + ":create", this.create, this);
            console.log(manifest.id + " plugin initialized");
        } else {
            this.editorObj = undefined, this.event = undefined, this.attributes = { x: 0, y: 0, w: 0, h: 0, visible: true }, this.params = undefined, this.data = undefined, this.media = undefined;
            this.editorData = data || {};
            this.children = [];
            this.id = this.editorData.id || UUID();
            this.parent = parent;
            this.config = { opacity: 100, strokeWidth: 1, stroke: "rgba(255, 255, 255, 0)", autoplay: false, visible: true };
        }
        this.configManifest = _.clone(org.ekstep.contenteditor.baseConfigManifest, true);
    },

    /**
     * Initializes the plugin by reading from ECML.
     * @private
     * @memberof org.ekstep.contenteditor.basePlugin
     */
    initPlugin: function() {
        this.fromECML(this.editorData);
        this.newInstance();
        this.postInit();
    },

    /**
     * Post init tasks for the plugin
     * @private
     * @memberof org.ekstep.contenteditor.basePlugin
     */
    postInit: function() {
        this.registerFabricEvents();
        if (this.editorObj) { this.editorObj.set({ id: this.id }); this.editorObj.setVisible(true); }
        if(_.has(this.manifest.editor, 'behaviour')) {
            if(!_.isUndefined(this.manifest.editor.behaviour.rotatable) && (this.manifest.editor.behaviour.rotatable === true)) {
                if (this.editorObj) { this.editorObj.hasRotatingPoint = true; }
            }
        }
        if (this.parent) this.parent.addChild(this);
        if (this.parent && this.parent.type !== 'stage') org.ekstep.contenteditor.api.dispatchEvent('object:modified', { id: this.id });
    },

    /**
     * Registers the menu for this plugin. By default, the base plugin handles the menu additions.
     * Child implementations can use this method to override and register additional menu items.
     * @memberof org.ekstep.contenteditor.basePlugin
     */
    registerMenu: function() {
        var instance = this;
        this.manifest.editor.menu = this.manifest.editor.menu || [];
        this.manifest.editor.sidebarMenu = this.manifest.editor.sidebarMenu || [];
        _.forEach(this.manifest.editor.menu, function(menu) {
            menu.iconImage = menu.iconImage ? instance.relativeURL(menu.iconImage) : menu.iconImage;
            if (menu.submenu) {
                _.forEach(menu.submenu, function(dd) {
                    dd.iconImage = dd.iconImage ? instance.relativeURL(dd.iconImage) : dd.iconImage;
                });
            }
            if (menu.category === 'main') {
                org.ekstep.contenteditor.toolbarManager.registerMenu(menu, instance.manifest);
            } else if (menu.category === 'context') {
                org.ekstep.contenteditor.toolbarManager.registerContextMenu(menu);
            }
        });

        _.forEach(instance.manifest.editor.sidebarMenu, function(sidebarMenu) {
            org.ekstep.contenteditor.sidebarManager.registerSidebarMenu(sidebarMenu, instance.manifest);
        });

        org.ekstep.contenteditor.sidebarManager.loadCustomTemplate(instance.manifest.id);

        _.forEach(instance.manifest.editor.header, function(header) {
            org.ekstep.contenteditor.headerManager.register(header, instance.manifest);
        });
    },

    /**
     * Returns relative URL for a particular asset. Plugins should use this method instead of
     * hard-coding the asset URLs.
     * @memberof org.ekstep.contenteditor.basePlugin
     */
    relativeURL: function(src) {
        return org.ekstep.contenteditor.api.resolvePluginResource(this.manifest.id, this.manifest.ver, src);
    },

    /**
     * Returns the type of this plugin (manifest ID)
     * @memberof org.ekstep.contenteditor.basePlugin
     */
    getType: function() {
        return this.manifest.id;
    },

    /**
     * Returns the version of this plugin (manifest ID)
     * @memberof org.ekstep.contenteditor.basePlugin
     */
    getVersion: function() {
        return this.manifest.ver;
    },

    /**
     * Registers listeners for Fabricjs events from the canvas. Child implementations should override
     * the actual callback methods instead of overriding this one.
     * @private
     * @memberof org.ekstep.contenteditor.basePlugin
     */
    registerFabricEvents: function() {
        if (this.editorObj) {
            this.editorObj.on({
                added: function(options, event) {
                    var inst = org.ekstep.contenteditor.api.getPluginInstance(this.id);
                    inst.added(inst, options, event);
                    if (inst.editorObj) {
                        org.ekstep.contenteditor.api.updatePluginDimensions(inst);
                    }
                },
                removed: function(options, event) {
                    var inst = org.ekstep.contenteditor.api.getPluginInstance(this.id);
                    inst.removed(inst, options, event);
                    _.forEach(inst.children, function(child, index) {
                        child.editorObj.remove();
                    });
                    inst.remove();
                },
                selected: function(options, event) {
                    var inst = org.ekstep.contenteditor.api.getPluginInstance(this.id);
                    inst.selected(inst, options, event)
                },
                deselected: function(options, event) {
                    var inst = org.ekstep.contenteditor.api.getPluginInstance(this.id);
                    inst.deselected(inst, options, event)
                },
                modified: function(options, event) {
                    var inst = org.ekstep.contenteditor.api.getPluginInstance(this.id);
                    /* istanbul ignore else. This cannot be reached */
                    if (inst.editorObj) {
                        org.ekstep.contenteditor.api.updatePluginDimensions(inst);
                    }
                    inst.changed(inst, options, event)
                },
                rotating: function(options, event) {
                    var inst = org.ekstep.contenteditor.api.getPluginInstance(this.id);
                    inst.rotating(inst, options, event)
                },
                scaling: function(options, event) {
                    var inst = org.ekstep.contenteditor.api.getPluginInstance(this.id);
                    inst.scaling(inst, options, event);
                },
                moving: function(options, event) {
                    var inst = org.ekstep.contenteditor.api.getPluginInstance(this.id);
                    inst.moving(inst, options, event)
                },
                skewing: function(options, event) {
                    var inst = org.ekstep.contenteditor.api.getPluginInstance(this.id);
                    inst.skewing(inst, options, event)
                }
            });
        }
    },

    /**
     * Helper method to load a given resource relative to the plugin.
     * @memberof org.ekstep.contenteditor.basePlugin
     */
    loadResource: function(src, dataType, cb) {
        org.ekstep.contenteditor.api.loadPluginResource(this.manifest.id, this.manifest.ver, src, dataType, cb);
    },

    /**
     * Removes the plugin from the stage. This can be used to perform self cleanup. If this method is called
     * from newInstance(), plugin won't be added to stage children.
     * @memberof org.ekstep.contenteditor.basePlugin
     */
    remove: function() {
        if (this.parent) {
            this.parent.removeChild(this);
            this.parent =  undefined; // if this method is called from newInstance(), plugin won't be added to stage children    
        }
        delete org.ekstep.pluginframework.pluginManager.pluginInstances[this.id];
    },

    /**
     * Creates the instance of the plugin when a new object is added to the canvas.
     * @private
     * @memberof org.ekstep.contenteditor.basePlugin
     */
    create: function(event, data) {
        org.ekstep.contenteditor.api.instantiatePlugin(this.manifest.id, _.clone(data), org.ekstep.contenteditor.stageManager.currentStage);
    },

    /**
     * Adds a child to this object. This can be useful for composite scenarios.
     * @memberof org.ekstep.contenteditor.basePlugin
     */
    addChild: function(plugin) {
        this.children.push(plugin);
    },

    /**
     * Removes a child from this plugin. Use this to dynamically manage composite children.
     * @memberof org.ekstep.contenteditor.basePlugin
     */
    removeChild: function(plugin) {
        this.children = _.reject(this.children, { id: plugin.id });
    },

    /**
     * Initialize the plugin when it is loaded. This is a no-op implementation and child classes must
     * provide the complete functional implementation.
     * @memberof org.ekstep.contenteditor.basePlugin
     */
    /* istanbul ignore next */initialize: function(data) {},

    /**
     * Instantiate an object of the plugin type. This is a no-op implementation and child classes must
     * provide the complete functional implementation.
     * @memberof org.ekstep.contenteditor.basePlugin
     */
    /* istanbul ignore next */newInstance: function(data) {},

    /**
     * Called when the plugin is added to the canvas. This is a no-op implementation and child classes must
     * provide the complete functional implementation.
     * @memberof org.ekstep.contenteditor.basePlugin
     */
    added: function(instance, options, event) {},

    /**
     * Called when the plugin is removed from the canvas. This is a no-op implementation and child classes must
     * provide the complete functional implementation.
     * @memberof org.ekstep.contenteditor.basePlugin
     */
    removed: function(instance, options, event) {},

    /**
     * Called when the object is selected on the canvas. This is a no-op implementation and child classes must
     * provide the complete functional implementation.
     * @memberof org.ekstep.contenteditor.basePlugin
     */
    selected: function(instance, options, event) {},

    /**
     * Called when the object loses focus on the canvas. This is a no-op implementation and child classes must
     * provide the complete functional implementation.
     * @memberof org.ekstep.contenteditor.basePlugin
     */
    deselected: function(instance, options, event) {},

    /**
     * Called when the object is modified (dragged, resized or rotated). This is a no-op implementation and child classes must
     * provide the complete functional implementation.
     * @memberof org.ekstep.contenteditor.basePlugin
     */
    changed: function(instance, options, event) {},

    /**
     * Called continuously while the object is rotating. This is a no-op implementation and child classes must
     * provide the complete functional implementation.
     * @memberof org.ekstep.contenteditor.basePlugin
     */
    rotating: function(instance, options, event) {},

    /**
     * Called continuously while the object is scaling. This is a no-op implementation and child classes must
     * provide the complete functional implementation.
     * @memberof org.ekstep.contenteditor.basePlugin
     */
    scaling: function(instance, options, event) {},

    /**
     * Called continuously while the object is being dragged. This is a no-op implementation and child classes must
     * provide the complete functional implementation.
     * @memberof org.ekstep.contenteditor.basePlugin
     */
    moving: function(instance, options, event) {},

    /**
     * Called continuously while the object is being skewed. This is a no-op implementation and child classes must
     * provide the complete functional implementation.
     * @memberof org.ekstep.contenteditor.basePlugin
     */
    skewing: function(instance, options, event) {},

    /**
     * Allows plugins to create a copy of the object. Default implementation just creates a clone. Child
     * classes can override the logic to customize how copy is done.
     * @memberof org.ekstep.contenteditor.basePlugin
     */
    doCopy: function() {
        return this.editorObj;
    },

    /**
     * Returns a copy of the object by converting it to ECML markup.
     * @private
     * @memberof org.ekstep.contenteditor.basePlugin
     */
    getCopy: function() {
        return this.toECML();
    },

    /**
     * Renders the plugin to canvas. Default implementation adds the editor fabric object to canvas.
     * Complex plugins and templates should override this if necessary.
     * @memberof org.ekstep.contenteditor.basePlugin
     */
    render: function(canvas) {
        canvas.add(this.editorObj);
    },

    /**
     * Returns the metadata of the object. This is a no-op implementation. Child plugins should override
     * this method to return custom metadata.
     * @memberof org.ekstep.contenteditor.basePlugin
     */    
    /* istanbul ignore next */
    getMeta: function() {},

    /**
     * Utility method to convert canvas pixels to relative units. By design, all rendering must work with
     * relative units to allow content to be rendered on different types of devices with different pixel
     * ratios and density. Plugins must always use the relative units for rendering.
     * @memberof org.ekstep.contenteditor.basePlugin
     */
    pixelToPercent: function(obj) {
        obj.x = parseFloat(((obj.x / 720) * 100).toFixed(2));
        obj.y = parseFloat(((obj.y / 405) * 100).toFixed(2));
        obj.w = parseFloat(((obj.w / 720) * 100).toFixed(2));
        obj.h = parseFloat(((obj.h / 405) * 100).toFixed(2));
        obj.rotate = parseFloat(obj.rotate);
    },

    /**
     * Utility method to convert relative units to pixels on canvas. By design, all rendering must work with
     * relative units to allow content to be rendered on different types of devices with different pixel
     * ratios and density. Plugins must always use the relative units for rendering.
     * @memberof org.ekstep.contenteditor.basePlugin
     */
    percentToPixel: function(obj) {
        obj.x = obj.x * (720 / 100);
        obj.y = obj.y * (405 / 100);
        obj.w = obj.w * (720 / 100);
        obj.h = obj.h * (405 / 100);
        obj.rotate = obj.rotate;
    },

    /**
     * Sets the config for this object. Override this method to parse the config if necessary.
     * @memberof org.ekstep.contenteditor.basePlugin
     */
    setConfig: function(data) {
        this.config = data;
    },

    /**
     * Adds a given config key and value pair to the config for this plugin instance.
     * @memberof org.ekstep.contenteditor.basePlugin
     */
    addConfig: function(key, value) {
        if (_.isUndefined(this.config)) this.config = {};
        this.config[key] = value;
    },

    /**
     * Returns the config for this plugin. Child plugins should override this method to generate the
     * custom plugin JSON objects.
     * @memberof org.ekstep.contenteditor.basePlugin
     */
    getConfig: function() {
        return this.config;
    },

    /**
     * Returns the data that this plugin might set and use at runtime. As a best practice, plugins should
     * differentiate between config (e.g. rendering colors, font size, levels etc) and data (actual
     * word details to use).
     * @memberof org.ekstep.contenteditor.basePlugin
     */
    setData: function(data) {
        this.data = data;
    },

    /**
     * Returns the data for this plugin. Data includes actual drivers - such as the words in a word game
     * or questions in a quiz. Plugins should set their data is they want to differentiate from
     * the config.
     * @memberof org.ekstep.contenteditor.basePlugin
     */
    getData: function() {
        return this.data;
    },

    /**
     * Manages the ECML attributes for the plugins. This includes x,y,w,h and rotation related attributes
     * that are common to all plugins.
     * @private
     * @memberof org.ekstep.contenteditor.basePlugin
     */
    setAttributes: function(attr) {
        _.merge(this.attributes, attr);
    },

    /**
     * Returns the ECML attributes for the plugins. This includes x,y,w,h and rotation related attributes
     * that are common to all plugins.
     * @private
     * @memberof org.ekstep.contenteditor.basePlugin
     */
    getAttributes: function() {
        return _.omit(this.attributes, ['top', 'left', 'width', 'height']);
    },

    /**
     * Modigies the ECML attributes for the plugins. This includes x,y,w,h and rotation related attributes
     * that are common to all plugins.
     * @private
     * @memberof org.ekstep.contenteditor.basePlugin
     */
    setAttribute: function(key, value) {
        this.attributes[key] = value;
    },

    /**
     * Returns the individual ECML attribute for the plugins. This includes x,y,w,h and rotation related attributes
     * that are common to all plugins.
     * @param key {string} Attribute name
     * @private
     * @memberof org.ekstep.contenteditor.basePlugin
     */
    getAttribute: function(key) {
        return this.attributes[key];
    },

    /**
     * Adds a runtime event listener for this plugin. Plugins can respond to events on the renderer
     * such as stage entry, exit or results of evaluation.
     * @param event {object} Event object
     * @private
     * @memberof org.ekstep.contenteditor.basePlugin
     */
    addEvent: function(event) {
        if (_.isUndefined(this.event)) this.event = [];
        this.event.push(event);
    },

    /**
     * Returns the list of runtime events configured for this plugin. Plugins can respond to events on the renderer
     * such as stage entry, exit or results of evaluation.
     * @param event {object} Event object
     * @memberof org.ekstep.contenteditor.basePlugin
     */
    getEvents: function() {
        return this.event;
    },

    /**
     * Adds a runtime param - such as teacher instructions to the ECML output. Params are like shared variables
     * that can be used for evaluation across stages on the renderer.
     * @param key {string} Name of the runtime parameter
     * @param value {object} Data of the parameter
     * @memberof org.ekstep.contenteditor.basePlugin
     */
    addParam: function(key, value) {
        if (_.isUndefined(this.params)) this.params = {};
        this.params[key] = value;
    },

    /**
     * Removes a runtime param for this plugin.
     * @param key {string} Name of the param to remove.
     * @memberof org.ekstep.contenteditor.basePlugin
     */
    deleteParam: function(key){
        if(this.params) delete this.params[key];
    },

    /**
     * Returns the list of runtime params for this plugin.
     * @memberof org.ekstep.contenteditor.basePlugin
     */
    getParams: function() {
        return this.params;
    },

    /**
     * Returns the specified runtime parameter details. Note that the value of the parameter
     * is only available at runtime.
     * @param key {string} Name of the param to return.
     * @memberof org.ekstep.contenteditor.basePlugin
     */
    getParam: function(key) {
        return this.params ? this.params[key] : undefined;
    },

    /**
     * Adds media to the manifest of this plugin. You can add media such as images, audios, or even
     * other runtime dependencies such as JS, CSS and other plugin files. If you don't declare a
     * media, it will not be included in the content download archive.
     * @param media {object} Media to be included at runtime.
     * @memberof org.ekstep.contenteditor.basePlugin
     */
    addMedia: function(media) {
        if (_.isUndefined(this.media)) this.media = {};
        this.media[media.id] = media;
    },

    /**
     * Returns the media manifest of this plugin. You can add media such as images, audios, or even
     * other runtime dependencies such as JS, CSS and other plugin files. If you don't declare a
     * media, it will not be included in the content download archive.
     * @param media {object} Media to be included at runtime.
     * @memberof org.ekstep.contenteditor.basePlugin
     */
    getMedia: function() {
        return this.media;
    },

    /**
     * Returns the renderer dimensions for this plugin. This includes the x,y,w,h bounding box,
     * and the rotation of the object.
     * @memberof org.ekstep.contenteditor.basePlugin
     */
    getRendererDimensions: function() {
        var attr = this.getAttributes();
        var dims = {
            x: attr.x,
            y: attr.y,
            w: attr.w,
            h: attr.h,
            rotate: attr.rotate
        }
        this.pixelToPercent(dims);
        return dims;
    },

    /**
     * Generates and returns the ECML string for this plugin.
     * @private
     * @memberof org.ekstep.contenteditor.basePlugin
     */
    toECML: function() {
        if(this.editorObj) org.ekstep.contenteditor.api.updatePluginDimensions(this);
        var attr = _.clone(this.getAttributes());
        attr.id = this.id;
        this.pixelToPercent(attr);
        if (!_.isUndefined(this.getData())) {
            attr.data = {
                "__cdata": JSON.stringify(this.getData())
            };
        }
        if (!_.isUndefined(this.getConfig())) {
            attr.config = {
                "__cdata": JSON.stringify(this.getConfig())
            };
        }
        if (!_.isUndefined(this.getEvents())) {
            // attr.config = {
            //     "__cdata": JSON.stringify(this.getEvents())
            // };
            attr.event = this.getEvents();
        }
        if (!_.isUndefined(this.getParams())) {
            attr.param = [];
            _.forIn(this.getParams(), function(value, key) {
                attr.param.push({ name: key, value: value });
            });
        }
        return attr;
    },

    /**
     * Parses the ECML to construct this object.
     * @private
     * @param data {object} ECML to recontruct from
     * @memberof org.ekstep.contenteditor.basePlugin
     */
    fromECML: function(data) {
        var instance = this;
        this.attributes = data;
        if (!_.isUndefined(this.attributes.data)) {
            this.data = this.attributes.data.__cdata ? JSON.parse(this.attributes.data.__cdata) : this.attributes.data;
            delete this.attributes.data;
        }
        if (!_.isUndefined(this.attributes.config)) {
            this.config = this.attributes.config.__cdata ? JSON.parse(this.attributes.config.__cdata) : this.attributes.config;
            delete this.attributes.config;
        }
        if (!_.isUndefined(this.attributes.events)) {
            //this.events = JSON.parse(this.attributes.event.__cdata);
            delete this.attributes.events;
        }
        if (!_.isUndefined(this.attributes.event)) {
            //this.events = JSON.parse(this.attributes.event.__cdata);
            this.event = this.attributes.event;
            delete this.attributes.event;
        }
        if (!_.isUndefined(this.attributes.param)) {
            _.forEach(this.attributes.param, function(param) {
                instance.addParam(param.name, param.value);
            })
            delete this.attributes.param;
        }
        if (!_.isUndefined(this.attributes.asset)) {
            if (!_.isUndefined(this.attributes.assetMedia)) {
                instance.addMedia(this.attributes.assetMedia);
                delete this.attributes.assetMedia;
            } else {
                var media = org.ekstep.contenteditor.mediaManager.getMedia(this.attributes.asset);
                if (!_.isUndefined(media)) {
                    instance.addMedia(media);
                }
            }
        }
        this.percentToPixel(this.attributes);
    },

    /**
     * Utility function to conver the data of the object to Fabric properties - a simple variable
     * transformation that returns the corresponding fabric parameter names.
     * @param data {object} Data of the current plugin instance.
     * @memberof org.ekstep.contenteditor.basePlugin
     */
    convertToFabric: function(data) {
        var retData = _.clone(data);
        if (data.x) retData.left = data.x;
        if (data.y) retData.top = data.y;
        if (data.w) retData.width = data.w;
        if (data.h) retData.height = data.h;
        if (data.radius) retData.rx = data.radius;
        if (data.color) retData.fill = data.color;
        if (data.rotate) retData.angle = data.rotate;
        return retData;
    },
    getConfigManifest: function() {
        if (!this.manifest.editor.configManifest) { this.manifest.editor.configManifest = []; }
        var configManifest = this.manifest.editor.configManifest
        if (this.configManifest) {
            configManifest = _.uniqBy(_.clone(_.concat(this.manifest.editor.configManifest, this.configManifest),true),'propertyName');
        }
        if (!(this.manifest.editor.playable && this.manifest.editor.playable === true)) {
          _.remove(configManifest, function (cm) {return cm.propertyName === 'autoplay'})
        }
        return configManifest
    },

    /**
     * Allows a plugin to update the context menu when the plugin instance is selected. Plugins can use
     * this method to change any specific custom context menu actions.
     * @memberof org.ekstep.contenteditor.basePlugin
     */
    /* istanbul ignore next */
    updateContextMenu: function() {},

    /**
     * Plugins can override this to reset their configuration.
     * @memberof org.ekstep.contenteditor.basePlugin
     */    
    /* istanbul ignore next */
    reConfig: function() {},

    onConfigChange: function() {},

    /**
     * Called when the configuration is modified for the plugin. This is useful if the plugin
     * has to provide WYSIWYG feedback on the fabric canvas.
     * @param key {string} Config property name
     * @param value {string} Value of the config setting.
     * @memberof org.ekstep.contenteditor.basePlugin
     */
    _onConfigChange: function(key, value) {
        this.addConfig(key, value);
        var currentInstace = org.ekstep.contenteditor.api.getCurrentObject();
        if (currentInstace) {
            if (currentInstace.config === undefined) { currentInstace.config = {} }
            switch (key) {
                case 'opacity':
                    currentInstace.editorObj.setOpacity(value/100);
                    currentInstace.attributes.opacity = value/100;
                    currentInstace.config.opacity = value;
                    break;
                case 'strokeWidth':
                    value = parseInt(value);
                    currentInstace.editorObj.set('strokeWidth', value);
                    currentInstace.attributes['stroke-width'] = value;
                    currentInstace.attributes['strokeWidth'] = value;
                    currentInstace.config.strokeWidth = value;
                    break;
                case 'stroke':
                    currentInstace.editorObj.setStroke(value);
                    currentInstace.attributes.stroke = value;
                    currentInstace.config.stroke = value;
                    break;
                case 'autoplay':
                    currentInstace.attributes.autoplay = value;
                    currentInstace.config.autoplay = value;
                    break;
                case 'visible':
                    currentInstace.attributes.visible = value;
                    currentInstace.config.visible = value;
                    break;
            }
            org.ekstep.contenteditor.api.render();
            org.ekstep.contenteditor.api.dispatchEvent('object:modified', { target: org.ekstep.contenteditor.api.getEditorObject() });
        }
    },

    /**
     * Returns the help text for this plugin by reading the help markdown file. Plugins can override this
     * to return custom help.
     * @memberof org.ekstep.contenteditor.basePlugin
     */
    /* istanbul ignore next. test case failing */
    getHelp: function(cb) {        
        var helpText = "Help is not available."
        try {
            this.loadResource(this.manifest.editor.help.src, this.manifest.editor.help.dataType, function(err, help) {
                if (!err) {
                    helpText = help;
                    cb(helpText);
                }
            });
        } catch (e) {
            console.log(e)
            cb(helpText);
        }
    },

    /**
     * Returns the properties that editable for this plugin instance.
     * @private
     * @memberof org.ekstep.contenteditor.basePlugin
     */
    getProperties: function() {
        var props = _.omitBy(_.clone(this.attributes), _.isObject);
        props = _.omitBy(props, _.isNaN);
        this.pixelToPercent(props);
        return props;
    },

    /**
     * Renders the configuration view for this plugin. Default functionality is to launch the config
     * property editor. Plugins can override this method to change the way config is rendered.
     * @memberof org.ekstep.contenteditor.basePlugin
     */    
    /* istanbul ignore next */renderConfig: function() {},

    /**
     * Returns the manifest ID of this object
     * @memberof org.ekstep.contenteditor.basePlugin
     */
    getManifestId: function () {
      return (this.manifest.shortId || this.manifest.id);
    },

    /**
     * Returns the displayName of this object
     * @memberof org.ekstep.contenteditor.basePlugin
     */
    getDisplayName: function () {
         return (this.manifest.displayName || this.manifest.id);
    }
});

/**
 * @author Santhosh Vasabhaktula <santhosh@ilimi.in>
 */
org.ekstep.contenteditor.stageManager = new(Class.extend({
    stages: [],
    thumbnails: {},
    currentStage: undefined,
    canvas: undefined,
    contentLoading: false,
    init: function() {
        var instance = this;
        fabric.Object.prototype.transparentCorners = false;
        fabric.Object.prototype.lockScalingFlip = true;
        fabric.Object.prototype.hasRotatingPoint = false;
        fabric.Object.prototype.cornerSize = 6;
        fabric.Object.prototype.padding = 2;
        fabric.Object.prototype.borderColor = "#1A98FA";
        fabric.Object.prototype.cornerColor = "#1A98FA";
        //fabric.Object.prototype.rotatingPointOffset = 18; //TODO need to add rotation in bas class
        this.canvas = new fabric.Canvas('canvas', { backgroundColor: '#FFFFFF', preserveObjectStacking: true, perPixelTargetFind: false });
        console.log("Stage manager initialized");
        org.ekstep.pluginframework.eventManager.addEventListener("stage:delete", this.deleteConfirmationDialog, this);
        org.ekstep.pluginframework.eventManager.addEventListener("stage:duplicate", this.duplicateStage, this);
    },
    clearCanvas: function(canvas) {
        canvas.clear();
        canvas.setBackgroundColor('#FFFFFF', canvas.renderAll.bind(canvas));
    },
    registerEvents: function() {
        var instance = this;
        this.canvas.on("object:modified", function(options, event) {
            org.ekstep.contenteditor.stageManager.dispatchObjectEvent('modified', options, event);
        });
        this.canvas.on("object:selected", function(options, event) {
            org.ekstep.contenteditor.stageManager.dispatchObjectEvent('selected', options, event);
        });
        this.canvas.on("selection:cleared", function(options, event) {
            org.ekstep.contenteditor.stageManager.dispatchObjectEvent('unselected', options, event);
        });
        this.canvas.on("object:added", function(options, event) {
            org.ekstep.contenteditor.stageManager.dispatchObjectEvent('added', options, event);
        });
        this.canvas.on("object:removed", function(options, event) {
            org.ekstep.contenteditor.stageManager.dispatchObjectEvent('removed', options, event);
        });
        this.canvas.on("object:moving", function(options, event) {
            org.ekstep.contenteditor.stageManager.dispatchObjectEvent('moving', options, event);
        });
        this.canvas.on("object:scaling", function(options, event) {
            org.ekstep.contenteditor.stageManager.dispatchObjectEvent('scaling', options, event);
        });
        org.ekstep.pluginframework.eventManager.addEventListener("stage:select", this.selectStage, this);
    },
    dispatchObjectEvent: function(eventType, options, event) {
        var meta = org.ekstep.contenteditor.stageManager.getObjectMeta(options);
        org.ekstep.pluginframework.eventManager.dispatchEvent('object:' + eventType, meta);
        if (meta.type != '') {
            org.ekstep.pluginframework.eventManager.dispatchEvent(meta.type + ':' + eventType, meta);
        }
    },
    selectStage: function(event, data) {
        if (_.isUndefined(this.currentStage)) {
            this.currentStage = _.find(this.stages, { id: data.stageId });
            this.currentStage.isSelected = true;
            this.currentStage.setCanvas(this.canvas);
            this.currentStage.render(this.canvas);
        } else {
            this.currentStage.isSelected = false;
            org.ekstep.pluginframework.eventManager.dispatchEvent('stage:unselect', { stageId: this.currentStage.id });
            this.clearCanvas(this.canvas);
            this.currentStage = _.find(this.stages, { id: data.stageId });
            this.currentStage.isSelected = true;
            this.canvas.off("object:added");
            this.currentStage.setCanvas(this.canvas);
            this.currentStage.render(this.canvas);
            this.canvas.on("object:added", function(options, event) {
                org.ekstep.contenteditor.stageManager.dispatchObjectEvent('added', options, event);
            });
        }
        org.ekstep.contenteditor.api.dispatchEvent('config:showSettingsTab', { id: this.currentStage.id });
    },
    addStage: function(stage) {
        var prevStageId = _.isUndefined(this.currentStage) ? undefined : this.currentStage.id;
        this.addStageAt(stage, stage.attributes.position);
        this.selectStage(null, { stageId: stage.id });
        org.ekstep.contenteditor.api.dispatchEvent('stage:add', { stageId: stage.id, prevStageId: prevStageId });
    },
    deleteStage: function(event, data) {
        var currentStage = _.find(this.stages, { id: data.stageId });
        this.deleteStageInstances(currentStage);
        var currentStageIndex = this.getStageIndex(currentStage);
        this.stages.splice(currentStageIndex, 1);
        if (this.stages.length === 0) org.ekstep.contenteditor.api.dispatchEvent('stage:create', { "position": "next" });
        else if (currentStageIndex === this.stages.length) this.selectStage(null, { stageId: this.stages[currentStageIndex - 1].id });
        else this.selectStage(null, { stageId: this.stages[currentStageIndex].id });
        org.ekstep.contenteditor.api.dispatchEvent('stage:removed', { stageId: data.stageId });
    },
    deleteStageInstances: function(stage) {
        _.forEach(_.clone(stage.canvas.getObjects()), function(obj) {
            stage.canvas.remove(obj);
        });
    },
    getStageIndex: function(stage) {
        return org.ekstep.contenteditor.api.getAllStages().findIndex(function(obj) {
            return obj.id === stage.id
        });
    },
    getStage: function(stageId) {
        return _.find(this.stages, { id: stageId });
    },
    duplicateStage: function(event, data) {
        var currentStage = _.find(this.stages, { id: data.stageId }),
            instance = this,
            plugins = [];
        var stage = this.stages[this.getStageIndex(currentStage)];
        org.ekstep.contenteditor.api.dispatchEvent('stage:create', { "position": "afterCurrent" });
        org.ekstep.pluginframework.eventManager.enableEvents = false;
        _.forEach(stage.children, function(plugin) {
            plugins.push({ 'z-index': plugin.attributes['z-index'], data: plugin });
        });
        _.forEach(_.sortBy(plugins, 'z-index'), function(plugin) {
            org.ekstep.contenteditor.api.cloneInstance(plugin.data);
        });
        this.currentStage.destroyOnLoad(stage.children.length, this.canvas, function() {
            org.ekstep.pluginframework.eventManager.enableEvents = true;
        });
        org.ekstep.contenteditor.api.dispatchEvent('stage:select', { stageId: this.currentStage.id });

    },
    getObjectMeta: function(options) {
        var pluginId = (options && options.target) ? options.target.id : '';
        return {
            'id': pluginId,
            'type': org.ekstep.pluginframework.pluginManager.getPluginType(pluginId),
            'ver': org.ekstep.pluginframework.pluginManager.getPluginVersion(pluginId)
        }
    },
    addStageAt: function(stage, position) {
        var currentIndex;
        switch (position) {
            case "beginning":
                this.stages.unshift(stage);
                break;
            case "end":
            case "next":
                this.stages.push(stage);
                break;
            case "afterCurrent":
            case "beforeCurrent":
                currentIndex = this.getStageIndex(org.ekstep.contenteditor.api.getCurrentStage());
                if (position === "afterCurrent" && currentIndex >= 0) this.stages.splice(currentIndex + 1, 0, stage);
                if (position === "beforeCurrent" && currentIndex >= 0) this.stages.splice(currentIndex, 0, stage);
                break;
            default:
                this.stages.push(stage)
                break;
        };
    },
    onStageDragDrop: function(srcStageId, destStageId) {
        var srcIdx = this.getStageIndexById(srcStageId);
        var destIdx = this.getStageIndexById(destStageId);
        if (srcIdx < destIdx) {
            var src = this.stages[srcIdx];
            for (var i = srcIdx; i <= destIdx; i++) {
                this.stages[i] = this.stages[i + 1];
                if (i === destIdx) this.stages[destIdx] = src;
            }
        }
        if (srcIdx > destIdx) {
            var src = this.stages[srcIdx];
            for (var i = srcIdx; i >= destIdx; i--) {
                this.stages[i] = this.stages[i - 1];
                if (i === destIdx) this.stages[destIdx] = src;
            }
        }

        org.ekstep.contenteditor.api.dispatchEvent('stage:reorder', { stageId: srcStageId, fromIndex: srcIdx, toIndex: destIdx });
    },
    getStageIndexById: function(stageId) {
        return _.findIndex(this.stages, function(stage) {
            return stage.id == stageId;
        });
    },
    deleteConfirmationDialog: function(event, data) {
        var instance = this;
        org.ekstep.contenteditor.api.getService('popup').open({
            template: 'deleteStageDialog.html',
            controller: ['$scope', function($scope) {
                $scope.delete = function() {
                    $scope.closeThisDialog();
                    instance.deleteStage(event, data);
                }
            }],
            showClose: false
        });
    },
    showLoadScreenMessage: function() {
        var obj = _.find(org.ekstep.contenteditor.api.getAngularScope().appLoadMessage, { 'id': 3 });
        if (_.isObject(obj)) {
            obj.message = "Loading your lesson";
            obj.status = true;
        }
        org.ekstep.contenteditor.api.ngSafeApply(org.ekstep.contenteditor.api.getAngularScope());
        setTimeout(function() {
            org.ekstep.contenteditor.api.getAngularScope().closeLoadScreen(); // added 2 sec set timeout to show the content load message           
        }, 2000)
    },
    getStageIcons: function() {
        return this.thumbnails;
    },
    toECML: function() {
        var instance = this;
        var content = { theme: { id: "theme", version: "1.0", startStage: this.stages[0].id, stage: [], manifest: { media: [] }, "plugin-manifest": { plugin: [] } } };
        this.setNavigationalParams();
        var mediaMap = {};
        _.forEach(this.stages, function(stage, index) {
            instance.thumbnails[stage.id] = stage.thumbnail;
            var stageBody = stage.toECML();
            stageBody.manifest = { media: [] };
            var stageAssets = []
            _.forEach(stage.children, function(plugin) {
                var id = plugin.getManifestId();
                if (_.isUndefined(stageBody[id])) stageBody[id] = [];
                stageBody[id].push(plugin.toECML());                                                               
                var pluginMedia = plugin.getMedia();
                instance.addMediaToMediaMap(mediaMap, pluginMedia, plugin.manifest);
                stageAssets = _.concat(stageAssets, _.keys(pluginMedia));
            });
            stageBody.manifest.media = _.map(_.uniq(stageAssets), function(asset) {
                return { assetId: asset }
            });
            content.theme.stage.push(stageBody);
        });    

        instance.manifestGenerator(content);       

        if (!_.isEmpty(org.ekstep.contenteditor.mediaManager.migratedMediaMap)) {
            instance.mergeMediaMap(mediaMap);
            content.theme["migration-media"] = {};
            content.theme["migration-media"].media = _.values(org.ekstep.contenteditor.mediaManager.migratedMediaMap);
        }
        content.theme.manifest.media = _.uniqBy(_.concat(content.theme.manifest.media, _.values(mediaMap)), 'id');       

        return _.cloneDeep(content);
    },
    manifestGenerator: function(content) {
        var pluginsUsed = {};
        var DEFAULT_COMPATIBILITY_VER = 2; //renderer
        _.forEach(org.ekstep.pluginframework.pluginManager.getPluginInstances(), function(plugin) {
            pluginsUsed[plugin.manifest.id] = plugin.manifest.id;
        });
        ManifestGenerator.generate(_.drop(_.values(pluginsUsed)), 'org.ekstep.stage');        
        content.theme.manifest.media = _.uniqBy(_.concat(content.theme.manifest.media, ManifestGenerator.getMediaManifest()), 'id');
        content.theme['plugin-manifest'].plugin = ManifestGenerator.getPluginManifest();
        content.theme.compatibilityVersion = ManifestGenerator.getCompatibilityVersion() || DEFAULT_COMPATIBILITY_VER;
    },
    mergeMediaMap: function(mediaMap) {
        _.forIn(org.ekstep.contenteditor.mediaManager.migratedMediaMap, function(value, key) {
            if (_.isUndefined(mediaMap[key])) {
                mediaMap[key] = value;
                value.src = org.ekstep.contenteditor.mediaManager.getMediaOriginURL(value.src);
            }
        });
    },
    addMediaToMediaMap: function(mediaMap, media, manifest, stageBody) {
        var pluginType = ['plugin', 'css', 'js'];
        if (_.isObject(media)) {
            _.forIn(media, function(value, key) {
                if (!mediaMap[key]) {
                    mediaMap[key] = value;
                    value.src = org.ekstep.contenteditor.mediaManager.getMediaOriginURL(value.src);
                    if (_.indexOf(pluginType, mediaMap[key].type) != -1) {
                        mediaMap[key].plugin = manifest.id;
                        mediaMap[key].ver = manifest.ver;
                    }
                } else if (value.preload) {
                    mediaMap[key].preload = value.preload;
                }
            });
        }
    },
    setNavigationalParams: function() {
        var instance = this;
        var size = this.stages.length;
        _.forEach(this.stages, function(stage, index) {
            if (index === 0) {
                stage.deleteParam('previous'); // first stage should not have previous param.
            }
            if (index !== 0) {
                stage.addParam('previous', instance.stages[index - 1].id);
            }
            if (index < (size - 1)) {
                stage.addParam('next', instance.stages[index + 1].id);
            }
            if (size === index + 1) {
                stage.deleteParam('next'); // last stage should not have next param.
            }
        });
    },
    fromECML: function(contentBody, stageIcons) {
        var instance = this;
        var startTime = (new Date()).getTime();
        org.ekstep.contenteditor.api.getAngularScope().appLoadMessage.push({ 'id': 3, 'message': 'Loading your lesson', 'status': false });
        org.ekstep.contenteditor.api.ngSafeApply(org.ekstep.contenteditor.api.getAngularScope());
        org.ekstep.contenteditor.stageManager.contentLoading = true;
        org.ekstep.pluginframework.eventManager.enableEvents = false;
        this._loadMedia(contentBody);
        this._loadPlugins(contentBody, function(err, res) {
            if (!err) {
                var stages = _.isArray(contentBody.theme.stage) ? contentBody.theme.stage : [contentBody.theme.stage];
                instance._loadStages(stages, stageIcons, startTime);
            }
        });
    },
    _loadMedia: function(contentBody) {
        _.forEach(contentBody.theme.manifest.media, function(media) {
            if (media.type == 'plugin' && org.ekstep.pluginframework.pluginManager.isPluginDefined(media.id)) {} else {
                org.ekstep.contenteditor.mediaManager.addMedia(media);
            }
        });
        //if migratedMedia present inside theme, add to migrated media
        if (contentBody.theme["migration-media"]) {
            _.forEach(contentBody.theme["migration-media"].media, function(media) {
                org.ekstep.contenteditor.mediaManager.addToMigratedMedia(media);
            });
        }
    },
    _loadPlugins: function(contentBody, cb) {
        var instance = this;
        contentBody.theme.manifest.media = _.isArray(contentBody.theme.manifest.media) ? contentBody.theme.manifest.media : [contentBody.theme.manifest.media];
        var plugins = _.filter(contentBody.theme.manifest.media, { type: 'plugin' });
        var pluginList = []
        _.forEach(plugins, function(plugin) {
            pluginList.push({ id: plugin.id, ver: plugin.ver, type: 'plugin' });
        });
        org.ekstep.pluginframework.pluginManager.loadAllPlugins(pluginList, undefined, cb);
    },
    _loadStages: function(stages, stageIcons, startTime) {
        var instance = this;
        stageIcons = stageIcons || '{}';
        var thumbnails = JSON.parse(stageIcons);
        var tasks = [];
        _.forEach(stages, function(stage, index) {
            tasks.push(function(callback) {
                instance._loadStage(stage, index, stages.length, thumbnails[stage.id], callback);
            });
        });
        if (tasks.length == 0) {
            instance.onContentLoad(startTime);
        } else {
            async.parallel(tasks, function(err, data) {
                instance.onContentLoad(startTime)
            });
        }
    },
    _loadStage: function(stage, index, size, thumbnail, callback) {
        delete stage.manifest;
        var instance = this;
        var stageEvents = _.clone(stage.events) || {};
        var canvas = undefined;
        if (thumbnail) {
            canvas = {
                toDataURL: function() {
                    return thumbnail;
                },
                add: function() {},
                setActiveObject: function() {},
                clear: function() {},
                renderAll: function() {},
                setBackgroundColor: function() {}
            }
        } else {
            // Some extremely complex logic is happening here. Read at your own risk
            // Instantiate a canvas to create thumbnail.
            if (index == 0) {
                canvas = this.canvas;
            } else {
                $('<canvas>').attr({ id: stage.id }).css({ width: '720px', height: '405px' }).appendTo('#thumbnailCanvasContainer');
                canvas = new fabric.Canvas(stage.id, { backgroundColor: "#FFFFFF", preserveObjectStacking: true, width: 720, height: 405 });
            }
        }

        var stageInstance = org.ekstep.contenteditor.api.instantiatePlugin(org.ekstep.contenteditor.config.corePluginMapping['stage'], stage);
        stageInstance.setCanvas(canvas);
        var pluginCount = 0;
        var props = _.pickBy(stage, _.isObject);
        var plugins = [];
        _.forIn(props, function(values, key) {
            values = _.isArray(values) ? values : [values];
            _.forEach(values, function(value) {
                plugins.push({ id: key, 'z-index': value['z-index'], data: value });
            });
            delete stage[key];
        })

        _.forIn(_.sortBy(plugins, 'z-index'), function(plugin) {
            var pluginId = org.ekstep.contenteditor.config.corePluginMapping[plugin.id] || plugin.id;
            var pluginInstance;
            try {
                pluginInstance = org.ekstep.contenteditor.api.instantiatePlugin(pluginId, plugin.data, stageInstance);
                if (_.isUndefined(pluginInstance)) {
                    console.log('Unable to instantiate', plugin.id); // TODO: Add telemetry that plugin is not found
                    org.ekstep.contenteditor.api.instantiatePlugin("org.ekstep.unsupported", { data: plugin }, stageInstance);
                }
                pluginCount++;
            } catch (e) {
                console.warn('error when instantiating plugin:', pluginId, plugin.data, stageInstance.id, e);
                org.ekstep.services.telemetryService.error({ "env": "content", "stage": stageInstance.id, "action": "console log error", "err": "plugin instantiation", "type": "PORTAL", "data": "", "severity": "warn" });
            }
        });
        if (stageEvents) {
            _.forEach(stageEvents, function(event) {
                _.forEach(event, function(e) {
                    stageInstance.addEvent(e);
                })
            })
        }
        stageInstance.destroyOnLoad(pluginCount, canvas, callback);
    },
    onContentLoad: function(startTime) {
        org.ekstep.contenteditor.api.jQuery('#thumbnailCanvasContainer').empty();
        org.ekstep.contenteditor.api.getAngularScope().toggleGenieControl();
        org.ekstep.pluginframework.eventManager.enableEvents = true;
        org.ekstep.contenteditor.stageManager.registerEvents();
        this.showLoadScreenMessage();
        org.ekstep.contenteditor.stageManager.contentLoading = false;
        org.ekstep.services.telemetryService.startEvent(true).append("loadtimes", { "contentLoad": ((new Date()).getTime() - startTime) });        
        if (org.ekstep.contenteditor.api._.isEmpty(this.stages)) {
            org.ekstep.pluginframework.eventManager.dispatchEvent('stage:create', { "position": "beginning" });
        }       
        org.ekstep.contenteditor.api.dispatchEvent('content:load:complete');
    },
    _resolveManifestMediaPath: function(id, ver, resource) {
        var src = org.ekstep.pluginframework.pluginManager.resolvePluginResource(id, ver, resource);
        if (src === false) {
            return ""
        } else if (src.indexOf("http") === -1) {
            src = org.ekstep.contenteditor.config.baseURL + src;
        }
        return src;
    },
    cleanUp: function() {
        this.stages = [];
        this.thumbnails = {};
        this.canvas = undefined;
        this.currentStage = undefined;
    }
}));

/**
 * @author Santhosh Vasabhaktula <santhosh@ilimi.in>
 */
org.ekstep.contenteditor.toolbarManager = new(Class.extend({
    menuItems: [],
    contextMenuItems: [],
    configMenuItems: [],
    scope: undefined,
    setScope: function(scope) {
        this.scope = scope;
    },
    registerMenu: function(menu) {
        if (!_.isObject(_.find(this.menuItems, { id: menu.id }))) {
            this.menuItems.push(menu);
        }
        if(this.scope) this.scope.refreshToolbar();
    },
    registerContextMenu: function(menu) {
        if (!_.isObject(_.find(this.contextMenuItems, { id: menu.id }))) {
            this.contextMenuItems.push(menu);
        }
        if(this.scope) this.scope.refreshToolbar();
    },
    resetContextMenu: function() {
        _.forEach(this.contextMenuItems, function(cmenu) {
            cmenu.state = 'HIDE';
            cmenu.selected = false;
        });
    },
    updateContextMenu: function(menus) {
        var instance = this;
        _.forEach(menus, function(cmenu) {
            instance._updateContextMenu(cmenu.id, cmenu);
        });
        /* istanbul ignore next. Angular functions cannot be tested now */
        org.ekstep.contenteditor.api.ngSafeApply(this.scope, function() {
            instance.scope.contextMenus = instance.contextMenuItems;
        });
        org.ekstep.contenteditor.jQuery(document).ready(function() {
            org.ekstep.contenteditor.jQuery(".ui.dropdown").dropdown();
            org.ekstep.contenteditor.jQuery(".popup-item").popup();
        });

    },
    _updateContextMenu: function(menuId, props) {
        //console.log('menu', menuId, 'props', props);
        var menu = _.find(this.contextMenuItems, { id: menuId });
        _.forIn(props, function(value, key) {
            if (key != 'data') {
                menu[key] = value;
                org.ekstep.pluginframework.eventManager.dispatchEvent(menuId + ':' + key, props.data);
            }
        });
    },
    getRegisterConfigMenu: function() {
        return this.configMenuItems;
    },
    cleanUp: function() {
        this.menuItems = [];
        this.contextMenus = [];
    }
}));

/**
 * @author Santhosh Vasabhaktula <santhosh@ilimi.in>
 */
org.ekstep.contenteditor.mediaManager = new(Class.extend({
    mediaMap: {},
    migratedMediaMap: {},
    addMedia: function(media) {
        if (_.isObject(media) && _.isString(media.id)) {
            this.mediaMap[media.id] = media;
        }
    },
    getMedia: function(asset) {
        return this.mediaMap[asset];
    },
    getMediaOriginURL: function(src) {
        var assetReverseProxyUrl = "/assets/public/";
        var replaceText = org.ekstep.contenteditor.config.baseURL + assetReverseProxyUrl;

        _.forEach(org.ekstep.contenteditor.config.aws_s3_urls, function(url){
            if(src.indexOf(url) !== -1){
                src = src.replace(url, replaceText);
            }
        });
        return src;
    },
    addToMigratedMedia: function(media) {
        if (_.isObject(media) && _.isString(media.id)) {
            this.migratedMediaMap[media.id] = media;
        }
    }
}));

org.ekstep.contenteditor.sidebarManager = new(Class.extend({
    loadNgModules: undefined,
    sidebarMenu: [],
    init: function() {
        this.setSidebarHeight();
    },
    initialize: function(config) {
        this.loadNgModules = config.loadNgModules;
        this.scope = config.scope
    },
    registerSidebarMenu: function(menu, manifest) {
        var instance = this;
        if (!_.isObject(_.find(this.sidebarMenu, { id: "sidebar:" + menu.id }))) {
            menu.onclick = menu.onclick || { id: "sidebar:" + menu.id };
            this.sidebarMenu.push(menu);
            this.loadSidebar(menu, manifest);
            ecEditor.addEventListener("sidebar:" + menu.id, function(event, data) {
                instance.showSidebarMenu(event.type.substring(event.type.indexOf(':') + 1));
            }, instance);
        }
    },
    loadSidebar: function(menu, manifest) {
        var instance = this;
        menu.state = menu.state || 'SHOW';
        if (menu.templateURL) {
            menu.templateURL = org.ekstep.contenteditor.api.resolvePluginResource(manifest.id, manifest.ver, menu.templateURL);
            instance.loadNgModules(menu.templateURL);

            if (menu.controllerURL) {
                menu.controllerURL = org.ekstep.contenteditor.api.resolvePluginResource(manifest.id, manifest.ver, menu.controllerURL);
                instance.loadNgModules(undefined, menu.controllerURL)
                    .then(function() {
                        instance.scope.addToSidebar(menu);
                    }, function() {
                        throw "unable to load controller :" + menu.controllerURL;
                    });
            } else {
                instance.scope.addToSidebar(menu);
            }
        };
    },
    loadCustomTemplate: function(pluginId) {
        var instance = this;
        var manifest = org.ekstep.pluginframework.pluginManager.getPluginManifest(pluginId);
        manifest.editor.configManifest = manifest.editor.configManifest || [];
        _.forEach(manifest.editor.configManifest, function(config) {
            if (config.type == "custom_template") {
                if (config.controllerURL) {
                    instance.loadNgModules(undefined, org.ekstep.contenteditor.api.resolvePluginResource(manifest.id, manifest.ver, config.controllerURL));
                }

                if (config.templateURL) {
                    var path = org.ekstep.contenteditor.api.resolvePluginResource(manifest.id, manifest.ver, config.templateURL);
                    org.ekstep.pluginframework.resourceManager.loadResource(path, 'HTML', function(err, data) {
                        if (err) throw "unable to load custom template";
                        if (data) config.template = data;
                    });
                }
            }
        });
    },
    updateSidebarMenu: function(menu) {
        var menuObject = _.find(this.sidebarMenu, { id: menu.id });
        _.forIn(menu, function(value, key) {
            if (key != 'id') menuObject[key] = value
        });
        this.scope.refreshSidebar();
    },
    getSidebarMenu: function() {
        return this.sidebarMenu;
    },
    setSidebarHeight: function() {
        var newheight = $(window).innerHeight() - 212;
        $('.sidebar-holder').css("height", newheight + "px");
    },
    getCurrentMenu: function() {
        return this.scope.configCategory.selected;
    },
    showSidebarMenu: function(sidebarMenuId) {        
        if (sidebarMenuId) {
            this.scope.configCategory.selected = sidebarMenuId;
            this.scope.refreshSidebar();
        }
    }
}));

org.ekstep.contenteditor.headerManager = new(Class.extend({
	registeredHeaders: [],
	initialize: function(config) {
        this.loadNgModules = config.loadNgModules;
        this.scope = config.scope
    },
    register: function(header, manifest) {
    	this.registeredHeaders.push({ id: manifest.id, header: header });
    	this.load(header, manifest);
    },
    load: function(header, manifest) {
        var instance = this;        
        if (header.templateURL) {
            header.templateURL = org.ekstep.contenteditor.api.resolvePluginResource(manifest.id, manifest.ver, header.templateURL);
            instance.loadNgModules(header.templateURL);

            if (header.controllerURL) {
                header.controllerURL = org.ekstep.contenteditor.api.resolvePluginResource(manifest.id, manifest.ver, header.controllerURL);
                instance.loadNgModules(undefined, header.controllerURL)
                    .then(function() {
                        instance.scope.addToHeader(header);
                    }, function() {
                        throw "unable to load controller :" + header.controllerURL;
                    });
            } else {
                instance.scope.addToHeader(header);
            }
        };
    }   
}));
/**
 * 
 * Popup service helps to show interactive popup modal/dialog window from plugin
 * 
 * @class org.ekstep.services.popupService
 * @author Sunil A S <sunils@ilimi.in>
 */
org.ekstep.services.popupService = new(org.ekstep.services.iService.extend({
    loadModules: undefined,
    openModal: undefined,
    initService: function(loadModuleFn, openModalFn) {
        this.loadModules = loadModuleFn;
        this.openModal = openModalFn;
    },
    /**
     *
     * loads HTML template and angular module 
     * @param templatePath {string} path to HTML template
     * @param controllerPath {string} path to angular module
     * @memberof org.ekstep.services.popupService
     */
    loadNgModules: function(templatePath, controllerPath) {
        this.loadModules && this.loadModules(templatePath, controllerPath);
    },
    /**
     *
     * opens popup modal/dialog window
     * @param config {object} config object refers to ngDialog open method parameter. please refer [ngDialog docs]{@link https://github.com/likeastore/ngDialog#openoptions}
     * @param callback {function} pre close Callback 
     * @memberof org.ekstep.services.popupService
     */
    open: function(config, callback) {
        /* istanbul ignore else */
        if (this.openModal) {
            this.openModal(config, callback);
            org.ekstep.services.telemetryService.interact({ "type": "click", "subtype": "open", "target": "popup", "pluginid": "", "pluginver": '', "objectid": "", "stage": ecEditor.getCurrentStage().id });
        }
    }
}));

/*// toECML
//     1. For each stage
//         1. for each plugin
            1. generate ecml
            2. add media to manifest
            3. add plugin to plugins used
        2. generate ecml
        3. add media to manifest
        4. add thumbnail
// 2. ManifestGenerator - generate plugin and media manifest using pluginsUsed array
// 3. Merge the media manifest generated by stages with the media manifest generated by the manifest generator
// 4. If there is migrated media - merge the migrated media with manifest media

// Pre-condition. toECML would generate the pluginUsed array
*/

var _PM_ = org.ekstep.pluginframework.pluginManager;
var ManifestGenerator = new(Class.extend({
    visitedPlugins: {},
    pluginManifest: [],
    mediaManifest: [],
    compatibilityVersion: 0,
    reset: function() {
        this.visitedPlugins = {};
        this.pluginManifest = [];
        this.mediaManifest = [];
    },
    getPluginManifest: function() {
        return this.pluginManifest;
    },
    getMediaManifest: function() {
        return this.mediaManifest;
    },
    isVisited: function(pluginId) {
        return this.visitedPlugins[pluginId] ? true : false;
    },
    visit: function(pluginId) {
        this.visitedPlugins[pluginId] = true;
    },
    generate: function(pluginUsedArray) {
        this.reset();
        this._generate(pluginUsedArray);
    },
    _generate: function(pluginArray) {
        var instance = this;
        _.forEach(pluginArray, function(pluginId) {
            instance._generateManifest(pluginId);
        })
    },
    _generateManifest: function(pluginId) {
        if(!this.isVisited(pluginId)) {
            this.visit(pluginId);
            var manifest = _PM_.getPluginManifest(pluginId);
            if(!_.isUndefined(manifest)) {
                this._generatePluginManifest(manifest);
                this._generateMediaManifest(manifest);
            }
        }
    },
    _getDependencies: function(pluginManifest) {
        var depends = undefined;
        if(pluginManifest.dependencies && pluginManifest.dependencies.length > 0) {
            var dependencies = _.map(_.filter(pluginManifest.dependencies, function(dependency) {
                return ['all','renderer'].indexOf(dependency.scope) != -1;
            }), function(dep) { return dep.plugin });
            if(dependencies.length > 0) {
                depends = dependencies;
            }
        }
        return depends;
    },
    _generatePluginManifest: function(manifest) {
        var depends = this._getDependencies(manifest);
        var dependsStr = '';
        if(!_.isUndefined(depends) && depends.length > 0) {
            this._generate(depends);
            dependsStr = depends.join(',');    
        } 
        manifest.type = manifest.type || "plugin";
        if (manifest.renderer) this.pluginManifest.push({id: manifest.id, ver: manifest.ver, type: manifest.type, depends: dependsStr});       
    },
    _generateMediaManifest: function(manifest) {
        var instance = this;
        if(manifest.renderer) {
            if (manifest.renderer.compatibilityVersion && (manifest.renderer.compatibilityVersion > instance.compatibilityVersion)) instance.compatibilityVersion = manifest.renderer.compatibilityVersion;

            // Add js/css/custom plugin dependencies
            if(manifest.renderer.dependencies && manifest.renderer.dependencies.length > 0) {
                _.forEach(manifest.renderer.dependencies, function(dependency) {
                    instance.mediaManifest.push({
                        id: dependency.id || UUID(),
                        plugin: manifest.id,
                        ver: manifest.ver,
                        src: _PM_.resolvePluginResource(manifest.id, manifest.ver, dependency.src),
                        type: dependency.type
                    })
                });
            }
            // Add main renderer script file
            if(manifest.renderer.main) {
                instance.mediaManifest.push({
                    id: manifest.id,
                    plugin: manifest.id,
                    ver: manifest.ver,
                    src: _PM_.resolvePluginResource(manifest.id, manifest.ver, manifest.renderer.main),
                    type: 'plugin'
                });
            }
            // Add the manifest.json of the renderer plugin
            instance.mediaManifest.push({
                id: manifest.id + '_manifest',
                plugin: manifest.id,
                ver: manifest.ver,
                src: _PM_.resolvePluginResource(manifest.id, manifest.ver, 'manifest.json'),
                type: 'json'
            });
        }
    },
    getCompatibilityVersion: function() {
        if (this.compatibilityVersion) return this.compatibilityVersion;
        return;
    }
}));
'use strict';

org.ekstep.contenteditor.migration = new(Class.extend({
    migrationFlag: false,
    init: function() {
        console.log('migration task initialized');
        org.ekstep.contenteditor.api.addEventListener('content:migration:start', this.execute, this);
    },
    _startTime: undefined,
    tasks: ['mediamigration_task', 'basestage_task', 'orderstage_task', 'scribblemigration_task', 'imagemigration_task', 'readalongmigration_task', 'assessmentmigration_task', 'eventsmigration_task', 'settagmigration_task'],
    migrationErrors: [],
    execute: function(event, data) {
        var contentbody = data.body, stageIcons = data.stageIcons;

        if (!_.has(contentbody, 'theme.stage')) org.ekstep.services.telemetryService.error({ "env": "content", "stage": "", "action": "migration", "objectId": "", objectType: "", "err": "migration has errors", "type": "PORTAL", "data": "", "severity": "error" });  
        if (this.isOldContent(contentbody)) {            
            this.initLoadScreenMsg();
            this._startTime = (new Date()).getTime();
            _.forEach(this.tasks, function(task) {
                org.ekstep.contenteditor.migration[task].migrate(contentbody)
            });
            this.postMigration(contentbody, stageIcons);
        } else {
            console.info('no need for migration');
            org.ekstep.contenteditor.stageManager.fromECML(contentbody, stageIcons);
        }
    },
    postMigration: function(content, stageIcons) {
        var instance = this;
        org.ekstep.services.telemetryService.startEvent().append("loadtimes", { migration: ((new Date()).getTime() - instance._startTime) });
        instance.setNewVersion(content);
        instance.showLoadScreenMsg();        
        console.info('Migration task completed!');        
        console.log('after migration content:', _.cloneDeep(content));
        if (instance.migrationErrors.length) {            
            console.info('Migration has errors: ', instance.migrationErrors);
            org.ekstep.services.telemetryService.error({ "env": "content", "stage": "", "action": "migration", "objectId": "", objectType: "", "err": "migration has errors", "type": "PORTAL", "data": "", "severity": "error" });
        }

        org.ekstep.contenteditor.stageManager.fromECML(content, stageIcons);
    },
    isOldContent: function(contentbody) {
        var version = contentbody.theme.version || contentbody.theme.ver;
        if (typeof version == 'string') version = parseFloat(version);
        if (version < 1) return true;
        return false;
    },
    initLoadScreenMsg: function() {
        var scope = org.ekstep.contenteditor.api.getAngularScope();
        scope.appLoadMessage.push({ 'id': 2, 'message': 'Migrating Content', 'status': false });
        this.migrationFlag = true;
    },
    showLoadScreenMsg: function () {
        var scope = org.ekstep.contenteditor.api.getAngularScope();
        scope.migration.showPostMigrationMsg = true;
        scope.migration.showMigrationSuccess = true;
        var obj = _.find(org.ekstep.contenteditor.api.getAngularScope().appLoadMessage, { 'id': 2 });
        if (_.isObject(obj)) {
            obj.message = "Content migrated";
            obj.status = true;
        }
        org.ekstep.contenteditor.api.ngSafeApply(scope);
    },
    setNewVersion: function(contentbody) {
        if (_.has(contentbody, 'theme.ver')) delete contentbody.theme.ver;
        contentbody.theme.version = "1.0";
    },
    isMigratedContent: function() {
        return this.migrationFlag;
    },
    clearMigrationFlag: function() {
        this.migrationFlag = false;
    }
}));

'use strict';

org.ekstep.contenteditor.migration.mediamigration_task = new(Class.extend({
    init: function() {
        console.log('media migration task initialized');
    },
    migrate: function(contentbody) {
        _.forEach(contentbody.theme.manifest.media, function(media){
           org.ekstep.contenteditor.mediaManager.addToMigratedMedia(media); 
        });
    }
}));

'use strict';

org.ekstep.contenteditor.migration.orderstage_task = new(Class.extend({
    init: function() {
        console.log('orderstage-task initialized');
    },
    migrate: function(contentbody) {
        var nextStage = {},
            stage,
            contentstages = [],
            instance = this,
            stageIds = [];

        nextStage.value = (!_.isUndefined(contentbody)) ? contentbody.theme.startStage : undefined;
        var stages = _.clone(contentbody.theme.stage);
        for (var i = 0; i < contentbody.theme.stage.length; i++) {
            if (!_.isUndefined(nextStage.value)) {
                stage = _.find(stages, function(st) {
                    return st.id === nextStage.value;
                });
                if(!_.isUndefined(stage)){
                    contentstages.push(stage);
                    var index = _.findIndex(stages, function(s) {
                        return s.id == nextStage.value;
                    });
                    stages.splice(index, 1);
                    if (_.isArray(stage.param) && !_.isUndefined(stage.param)) {
                        _.forEach(stage.param, function(param) {
                            if (param.name === 'next')
                                nextStage.value = param.value;
                        });
                    } else if (!_.isUndefined(stage.param) && stage.param.name === 'next') {
                        nextStage.value = stage.param.value;
                    } else {
                        nextStage.value = undefined;
                    }
                }
            }
            if (contentbody.theme.stage.length === i + 1) {
                contentbody.theme.stage = contentstages.concat(stages);
            }
        }
    }
}));

'use strict';

org.ekstep.contenteditor.migration.basestage_task = new(Class.extend({
    init: function() {
        console.log('basestage_task initialized');
    },
    baseStage: undefined,
    contentbody: undefined,    
    migrate: function(contentbody) {
        var instance = this,
            stageId,
            baseStageArray = [];

            instance.contentbody = contentbody;
        if (!_.isArray(instance.contentbody.theme.stage)) instance.contentbody.theme.stage = [instance.contentbody.theme.stage];
        _.forEach(instance.contentbody.theme.stage, function(stage, index) {
            var mergedObject = {}
            if (stage.extends) {
                instance.baseStage = _.find(contentbody.theme.stage, function(o) { return o.id === stage.extends });
                //merge stage with basestage                
                for (var attr in instance.baseStage) { mergedObject[attr] = instance.baseStage[attr] }
                for (var attr in stage) { mergedObject[attr] = stage[attr] }                
                stage = mergedObject;                 
                delete instance.contentbody.theme.stage[index].extends;
                baseStageArray.push(instance.baseStage.id);
            }
            if (contentbody.theme.stage.length === index + 1) {
                if (baseStageArray.length) {
                    _.forEach(baseStageArray, function(bs, index){ 
                        instance.removeBaseStage(bs);
                    });
                }                
            }
        });
    },
    removeBaseStage: function(baseStage) {
        var instance = this;
        if (baseStage) {
            _.remove(instance.contentbody.theme.stage, function(s) {
                return s.id === baseStage;
            });
        }
    }
}));

'use strict';

org.ekstep.contenteditor.migration.imagemigration_task = new(Class.extend({
    init: function() {
        console.log('image migration initialized');
    },
    migrate: function(contentbody) {},
    removeImage: function(stage, id) {
        _.remove(stage.image, function(image) {
            return image.asset === id;
        });
    }
}));

'use strict';

org.ekstep.contenteditor.migration.scribblemigration_task = new(Class.extend({
    init: function() {
        console.log('scribble migration task initialized');
    },
    id: 'org.ekstep.scribblepad',    
    migrate: function(contentbody) {
    	var instance = this;

        _.forEach(contentbody.theme.stage, function(stage, index) {
            if (stage.scribble && (!_.isArray(stage.scribble))) stage.scribble = [stage.scribble];
            if (stage.scribble && stage.scribble.length) {
                stage[instance.id] = stage.scribble;
                delete stage.scribble;
            }            
            org.ekstep.contenteditor.migration.imagemigration_task.removeImage(stage, 'domain_38441_trash');                
            instance.removeEraserMedia(contentbody);
        });
    },
    removeEraserMedia: function(contentbody) {
        _.forEach(_.clone(contentbody.theme.manifest.media), function(media, index) {
            if (media.assetId === "domain_38441_trash") contentbody.theme.manifest.media.splice(index, 1);
        });
    }
}))

'use strict';

org.ekstep.contenteditor.migration.readalongmigration_task = new(Class.extend({
    init: function() {
        console.log('read along migration task initialized');
    },
    // check 'isReadAlongAutoPlay' attribute in htext and convert to 'autoplay'
    migrate: function(contentbody) {
    		console.log('migrating readalong');
        _.forEach(contentbody.theme.stage, function(stage, index) {
            if (stage.htext && (!_.isArray(stage.htext))) stage.htext = [stage.htext];
            if (stage.htext && stage.htext.length) {
                _.forEach(stage.htext, function(htext) {
                    if(!_.isUndefined(htext.isReadAlongAutoPlay)) {
                        htext.autoplay = htext.isReadAlongAutoPlay;
                        delete htext.isReadAlongAutoPlay;
                    }
                });
            }
        });
    }
}));

'use strict';

org.ekstep.contenteditor.migration.assessmentmigration_task = new(Class.extend({
    init: function() {
        console.log('assessment migration task initialized');
    },
    contentbody: undefined,
    template: [],
    id: 'org.ekstep.quiz',
    quiz: { x: 0, y: 0, w: 0, h: 0, visible: true, editable: true, 'z-index': 0, data: { __cdata: { questionnaire: {}, template: [] } }, config: { __cdata: { "type": "items", "var": "item" } } },
    migrate: function(contentbody) {
        var instance = this;
        this.contentbody = contentbody;

        _.forEach(contentbody.theme.stage, function(stage, index) {
            if(!_.isUndefined(stage.g) && !_.isArray(stage.g)) stage.g = [stage.g];
            if (!_.isUndefined(stage.iterate) && (_.has(stage, 'embed') || _.find(stage.g, function(g){return _.has(g, 'embed')}))) {
                instance.transformToQuiz(stage);
                instance.removeObsoleteTag(stage);              
            }
        });

    },
    getController: function(controllerId) {
        return _.find(this.contentbody.theme.controller, function(ctrl) {
            return ctrl.id === controllerId;
        });
    },
    getTemplate: function(templateId) {        
        return _.find(this.contentbody.theme.template, function(template) {
            return template.id === templateId;
        });        
    },
    transformToQuiz: function(stage) {
        var instance = this,
            questionnaire,
            quiz,
            controllerData,
            ctrl,
            tmplt;

        quiz = _.cloneDeep(instance.quiz);
        ctrl = instance.getController(stage.iterate);
        _.isUndefined(ctrl) ? org.ekstep.contenteditor.migration.migrationErrors.push('controller not found for assessment on stage: '+ stage.id) : (controllerData = ctrl.__cdata);
        if(typeof controllerData === 'string') controllerData = JSON.parse(controllerData);
        questionnaire = quiz.data.__cdata.questionnaire = controllerData;
        if (questionnaire) {
            _.forEach(questionnaire.item_sets, function(itemset, index) {

                _.forEach(questionnaire.items[itemset.id], function(items) {
                    if (items.template) {
                        tmplt = instance.getTemplate(items.template);
                        _.isUndefined(tmplt) ? org.ekstep.contenteditor.migration.migrationErrors.push('Template not found for assessment on stage: ' + stage.id) : quiz.data.__cdata.template.push(tmplt);
                        //instance.removeObsoleteTemplate(items.template);
                    }
                });

                if (questionnaire.item_sets.length === index + 1) {
                    stage[instance.id] = quiz;
                    instance.stringifycdata(stage);
                };
            });
        }
    },
    removeObsoleteTag: function(stage) {
        if (_.has(stage, 'embed')) delete stage.embed;
        if (_.has(stage, 'g')) _.remove(stage.g, function(g){return _.has(g, 'embed')});        
        if (_.has(stage, 'appEvents')) delete stage.appEvents;
        delete stage.iterate;
    },
    removeObsoleteTemplate: function(templateId) {
    	return _.remove(this.contentbody.theme.template, function(template){
    		return template.id === templateId;
    	});
    },
    stringifycdata: function(stage) {
        stage[this.id].data.__cdata = JSON.stringify(stage[this.id].data.__cdata);
        stage[this.id].config.__cdata = JSON.stringify(stage[this.id].config.__cdata);
    }
}));

'use strict';

org.ekstep.contenteditor.migration.eventsmigration_task = new(Class.extend({
    init: function() {
        console.log('events migration task initialized');
    },
    migrate: function(contentbody) {
        console.log('migrating events');
        var instance = this;
        _.forEach(contentbody.theme.stage, function(stage, index) {
            var plugins = _.pickBy(stage, _.isObject);
            if (!_.isArray(plugins)) plugins = [plugins];
            _.forEach(plugins, function(pluginTypes) {
                if (!_.isArray(pluginTypes)) pluginTypes = [pluginTypes];
                _.forEach(pluginTypes, function(plugin) {
                    _.forEach(plugin, function(pluginInstances) {
                        if (_.isArray(pluginInstances)) {
                            _.forEach(pluginInstances, function(pi) {
                                if (pi && (pi.event || pi.events)) {
                                    if (pi.event) {
                                        var event = _.clone(pi.event, true);
                                        delete pi.event;
                                        instance.migrateEvents(event, pi);
                                    }
                                    if (pi.events && pi.events.event) {
                                        var events = _.clone(pi.events.event, true);
                                        delete pi.events;
                                        instance.migrateEvents(events, pi);
                                    }
                                }
                            })
                        } else {
                            if (pluginInstances && (pluginInstances.event || pluginInstances.events)) {
                                if (pluginInstances.event) {
                                    var event = _.clone(pluginInstances.event, true);
                                    delete pluginInstances.event;
                                    instance.migrateEvents(event, pluginInstances);
                                }
                                if (pluginInstances.events && pluginInstances.events.event) {
                                    var events = _.clone(pluginInstances.events.event, true);
                                    delete pluginInstances.events;
                                    instance.migrateEvents(events, pluginInstances);
                                }
                            }
                        }
                    })
                })
            })
            if (stage.event || stage.events) {
                if (stage.event) {
                    var stageEvent = _.clone(stage.event, true);
                    delete stage.event;
                    instance.migrateStageEvents(stageEvent, stage);
                }
                if (stage.events && stage.events.event) {
                    var stageEvents = _.clone(stage.events.event, true);
                    delete stage.events;
                    instance.migrateStageEvents(stageEvents, stage);
                }
            }
        });
    },
    migrateStageEvents: function(events, pi) {
        var instance = this;
        if (_.isArray(events)) {
            _.forEach(events, function(event) {
                if (event.action && _.isArray(event.action)) {
                    _.forEach(event.action, function(action) {
                        instance.addEvent(pi, { 'type': event.type, 'action': [action] });
                    })
                } else if (event.action && _.isObject(event.action)) {
                    instance.addEvent(pi, { 'type': event.type, 'action': [event.action] });
                }
            })
        } else if (_.isObject(events)) {
            if (events.action && _.isArray(events.action)) {
                _.forEach(events.action, function(action) {
                    var eventObj = { 'type': events.type, 'action': [action] };
                    if (!_.isUndefined(events.type)) {
                        eventObj.type = events.type;
                    }
                    instance.addEvent(pi, eventObj);
                })
            } else if (events.action && _.isObject(events.action)) {
                var eventObj = { 'type': events.type, 'action': [events.action] };
                if (!_.isUndefined(events.type)) {
                    eventObj.type = events.type;
                }
                instance.addEvent(pi, eventObj);
            }
        }
    },
    migrateEvents: function(events, pi) {
        var instance = this;
        if (_.isArray(events)) {
            _.forEach(events, function(event) {
                if (event.action && _.isArray(event.action)) {
                    _.forEach(event.action, function(action) {
                        instance.addEvent(pi, { 'type': event.type, 'action': [action] });
                    })
                } else if (event.action && _.isObject(event.action)) {
                    instance.addEvent(pi, { 'type': event.type, 'action': [event.action] });
                }
            })
        } else if (_.isObject(events)) {
            if (events.action && _.isArray(events.action)) {
                _.forEach(events.action, function(action) {
                    instance.addEvent(pi, { 'type': events.type, 'action': [action] });
                })
            } else if (events.action && _.isObject(events.action)) {
                instance.addEvent(pi, { 'type': events.type, 'action': [events.action] });
            }
        }
    },
    addEvent: function(pi, event) {
        if (_.isUndefined(pi.event)) pi.event = [];
        pi.event.push(event);
    }
}))

'use strict';

org.ekstep.contenteditor.migration.settagmigration_task = new(Class.extend({
    init: function() {
        console.log('set tag migration-task initialized');
    },
    migrate: function(contentbody) {
        _.forEach(contentbody.theme.stage, function(stage, index) {
            //if stage has set tag, throw fatal error.                       
            if (_.has(stage, 'set')) org.ekstep.contenteditor.migration.migrationErrors.push('Content has set tag on stage: '+ stage.id);
        });
    }
}));

/**
 *
 * Telemetry service helps to log telemetry events. Telemetry service generates below listed events
 * and logs to registered dispatchers.
 * <ol>
 *  <li>CE_START
 *  <li>CE_API_CALL
 *  <li>CE_INTERACT
 *  <li>CE_PLUGIN_LIFECYCLE
 *  <li>CE_ERROR
 *  <li>CE_END
 * </ol>
 *
 * @class org.ekstep.services.telemetryService
 * @author Santhosh Vasabhaktula <santhosh@ilimi.in>
 */
org.ekstep.services.telemetryService = new(org.ekstep.services.iService.extend({
    context: {},
    dispatchers: [],
    initialized: true,
    start_event: undefined,
    startEventData: undefined,
    /**
    * 
    * Initialize the service with context and dispatcher.     
    * @param context {object} context object can have uid, sid, context_id. 
    * context should have content id, otherwise telemetry service cannot be initialized.
    * @param dispatcher {string} There are 3 types of dispatcher available, anyone of dispatcher 
    * is allowed and same dispatcher is used throughout the editor session. 
    * <ol>
    *   <li>Local dispatcher - dev environment only, logs to file (telemetry.log) - value: "local"
    *   <li>piwik dispatcher - logs to piwik endpoint - value: "piwik"
    *   <li>console dispatcher - logs to client console, default dispatcher - value: undefined
    * </ol>
    * 
    * @memberof org.ekstep.services.telemetryService
    *
    */
    initialize: function(context, dispatcher) {
        var instance = this;
        this.context = context;
        /* istanbul ignore else */
        if(this.context.cdata == undefined) {
            this.context.cdata = [];
        }
        if((this.context.uid == undefined) || (this.context.sid == undefined) || (this.context.content_id == undefined)) {
            console.error('Unable to instantiate telemetry service');
            this.initialized = false;
        }
        this.addDispatcher(dispatcher);

        window.addEventListener('unload', /* istanbul ignore next */ function() {
            instance.end();
        }); 

        this.startEventData = { defaultPlugins: Object.keys(org.ekstep.pluginframework.pluginManager.plugins), loadtimes: {}, client: {} };
    },
    /**
    *
    * to populate data for start event (CE_START)  
    * @param autoplublish {boolean} if "true" logs the events through dispatcher. 
    * @returns {object} returns method chain. 
    * <ol>
    *   <li> <pre>getData()</pre>: return start event data
    *   <li> <pre>append(param, dataObj)</pre>: appends only "loadtimes" param of CE_START with dataObj(type: object). 
    * <ol> 
    * @memberof org.ekstep.services.telemetryService
    *
    */
    startEvent: function(autopublish) {
        var instance = this;
        return {
            getData: function() {
                return instance.startEventData;
            },
            append: function(param, dataObj) {
                for (var key in dataObj) {
                    instance.startEventData[param][key] = dataObj[key];
                }
                if (autopublish) instance.start();
            }
        }
    },
    /**
    *
    * returns dispatcher instance
    * @param dispatcherId {string}     
    * <ol>
    *   <li>Local dispatcher: value: "local"
    *   <li>piwik dispatcher: value: "piwik"
    *   <li>(default) console dispatcher: value: undefined 
    * </ol>
    * @returns dispatcher {object}
    * @memberof org.ekstep.services.telemetryService
    *
    */
    getDispatcher: function(dispatcherId) {
        switch(dispatcherId) {
            case "local":
                return org.ekstep.contenteditor.localDispatcher;
            case "piwik":
                return org.ekstep.contenteditor.piwikDispatcher;
            default:
                return org.ekstep.contenteditor.consoleDispatcher;
        }
    },
    /**
    * 
    * To add a dispatcher to the dispatcher registry
    * @param dispatcherId {string}
    * <ol>
    *   <li>Local dispatcher: value: "local"
    *   <li>piwik dispatcher: value: "piwik"
    *   <li>(default) console dispatcher: value: undefined 
    * </ol>
    * @memberof org.ekstep.services.telemetryService
    *
    */
    addDispatcher: function(dispatcherId) {
        var dispatcher = this.getDispatcher(dispatcherId);
        var dispatcherExist = this.dispatchers.find(function(obj){
           return  obj.type === dispatcher.type;
        });
        if(!dispatcherExist) this.dispatchers.push(dispatcher);
    },
    /**
     *
     * dispatch event to all registered dipatchers
     * @private
     * @param message {event} structured event
     * @memberof org.ekstep.services.telemetryService
     *
     */
    _dispatch: function(message) {
        if (this.initialized) {
            message.mid = 'CE:' + CryptoJS.MD5(JSON.stringify(message)).toString();
            _.forEach(this.dispatchers, function(dispatcher) {
                dispatcher.dispatch(message);
            });
        }
    },
    /**
    *
    * returns structured telemetry event for the given data
    * @param eventId {string} 
    * <ol>
    *  <li>CE_START
    *  <li>CE_API_CALL
    *  <li>CE_INTERACT
    *  <li>CE_PLUGIN_LIFECYCLE
    *  <li>CE_ERROR
    *  <li>CE_END
    * </ol>
    * @param data {object} telemetry data object specified for each telemetry event.
    * @memberof org.ekstep.services.telemetryService
    *
    */
    getEvent: function(eventId, data) {
        return {
            "eid": eventId,
            "mid": "",
            "ets": (new Date()).getTime(), 
            "ver": "1.0",
            "pdata": {"id": "ATTool","pid": "ContentEditor","ver": "2.0"},
            "cdata": this.context.cdata, //TODO: No correlation data as of now. Needs to be sent by portal in context
            "uid": this.context.uid, // uuid of the requester
            "context": {"sid": this.context.sid,"content_id": this.context.content_id},
            "rid": "", // Leave blank.
            "edata": { "eks": data},
            "tags":[]
        }
    },
    /**
    *
    * validates telemetry data with mandatory fields
    * @param data {object} telemetry data
    * @param mandatoryFields {array} required fields for the specific telemetry to validate
    * @memberof org.ekstep.services.telemetryService
    *
    */
    hasRequiredData: function(data, mandatoryFields) {
        var isValid = true;
        mandatoryFields.forEach(function(key) {
            if (!data.hasOwnProperty(key)) isValid = false;
        });
        return isValid;
    },
    interactRequiredFields: ["type", "subtype", "target", "pluginid", "pluginver", "objectid", "stage"],
    lifecycleRequiredFields: ["type", "pluginid", "pluginver", "objectid", "stage"],
    errorRequiredFields: ["env", "stage", "action", "err", "type", "data", "severity", "objectid", "objecttype"],
    apiCallRequiredFields: ["path", "method", "request", "response","responseTime", "status", "uip"],
    /**
    *
    * dispatches interact event (CE_INTERACT)
    * @param data {object} interact event data
    * @memberof org.ekstep.services.telemetryService
    *
    */
    interact: function(data) {
        if(!this.hasRequiredData(data, this.interactRequiredFields)) {
            console.error('Invalid interact data');
            return;
        }
        this._dispatch(this.getEvent('CE_INTERACT', data))
    },
    /**
    *
    * dispatches end event (CE_END)
    * @memberof org.ekstep.services.telemetryService
    *
    */
    end: function() {
        var endEvent = this.getEvent('CE_END', {});
        endEvent.edata.eks.duration = (new Date()).getTime() - this.start_event.ets;
        this._dispatch(endEvent);
    },
    /**
    *
    * dispatches plugin lifecycle event (CE_PLUGIN_LIFECYCLE)
    * @param data {object} plugin lifecycle event data
    * @memberof org.ekstep.services.telemetryService
    *
    */
    pluginLifeCycle: function(data) {
        if(!this.hasRequiredData(data, this.lifecycleRequiredFields)) {
            console.error('Invalid plugin lifecycle event data');
            return;
        }
        this._dispatch(this.getEvent('CE_PLUGIN_LIFECYCLE', data))
    },
    /**
    *
    * dispatches error event (CE_ERROR)
    * @param data {object} error event data
    * @memberof org.ekstep.services.telemetryService
    *
    */
    error: function(data) {
        if(!this.hasRequiredData(data, this.errorRequiredFields)) {
            console.error('Invalid error data');
            return;
        }
        this._dispatch(this.getEvent('CE_ERROR', data))
    },
    /**
    *
    * dispatches start event (CE_START)
    * @memberof org.ekstep.services.telemetryService
    *
    */
    start: function() {
        this.startEventData.client = this.detectClient();
        this.start_event = this.getEvent('CE_START', this.startEventData);
        this._dispatch(this.start_event);
    },
    /**
    *
    * dispatches api call event (CE_API_CALL)
    * @param data {object} api call event data
    * @memberof org.ekstep.services.telemetryService
    *
    */
    apiCall: function(data) {
        if (!this.hasRequiredData(data, this.apiCallRequiredFields)) {
            console.error('Invalid api call data');
            return;
        }
        this._dispatch(this.getEvent('CE_API_CALL', data))
    },
    /**
    *
    * returns client machine info such as OS, browser, browser version
    * @memberof org.ekstep.services.telemetryService
    *
    */
    detectClient: function() {        

        var nAgt = navigator.userAgent;
        var browserName = navigator.appName;
        var fullVersion = '' + parseFloat(navigator.appVersion);
        var nameOffset, verOffset, ix;

        // In Opera
        /* istanbul ignore next. Cannot test this as the test cases runs in phatomjs browser */
        if ((verOffset = nAgt.indexOf("Opera")) != -1) {
            browserName = "opera";
            fullVersion = nAgt.substring(verOffset + 6);
            if ((verOffset = nAgt.indexOf("Version")) != -1)
                fullVersion = nAgt.substring(verOffset + 8);
        }
        // In MSIE
        else if ((verOffset = nAgt.indexOf("MSIE")) != -1) {
            browserName = "IE";
            fullVersion = nAgt.substring(verOffset + 5);
        }
        // In Chrome
        else if ((verOffset = nAgt.indexOf("Chrome")) != -1) {
            browserName = "chrome";
            fullVersion = nAgt.substring(verOffset + 7);
        }
        // In Safari
        else if ((verOffset = nAgt.indexOf("Safari")) != -1) {
            browserName = "safari";
            fullVersion = nAgt.substring(verOffset + 7);
            if ((verOffset = nAgt.indexOf("Version")) != -1)
                fullVersion = nAgt.substring(verOffset + 8);
        }
        // In Firefox
        else if ((verOffset = nAgt.indexOf("Firefox")) != -1) {
            browserName = "firefox";
            fullVersion = nAgt.substring(verOffset + 8);
        }
        
        // trim the fullVersion string at semicolon/space if present
        /* istanbul ignore next. Cannot test this as the test cases runs in phatomjs browser */
        if ((ix = fullVersion.indexOf(";")) != -1)
            fullVersion = fullVersion.substring(0, ix);
        /* istanbul ignore next. Cannot test this as the test cases runs in phatomjs browser */
        if ((ix = fullVersion.indexOf(" ")) != -1)
            fullVersion = fullVersion.substring(0, ix);

        return { browser: browserName, browserver: fullVersion, os: navigator.platform };
    }
}));

org.ekstep.contenteditor.IDispatcher = Class.extend({
    init: function() {
        this.initDispatcher();
    },
    initDispatcher: function() {throw 'Subclass should implement initDispatcher'},
    dispatch: function(event) {throw 'Subclass should implement dispatch'}
});
org.ekstep.contenteditor.consoleDispatcher = new(org.ekstep.contenteditor.IDispatcher.extend({
    type: "consoleDispatcher",
    initDispatcher: function() {},
    dispatch: function(event) {
        console.log(event);
    }
}));

org.ekstep.contenteditor.localDispatcher = new(org.ekstep.contenteditor.IDispatcher.extend({
    type: "localDispatcher",
    initDispatcher: function() {},
    dispatch: function(event) {        
        event = (typeof event === "string") ? event : JSON.stringify(event);
        org.ekstep.contenteditor.jQuery.ajax({
            type: 'POST',
            url: 'telemetry',
            data: {event: event},
            success: function(res) {}
        });
    }
}));

org.ekstep.contenteditor.piwikDispatcher = new(org.ekstep.contenteditor.IDispatcher.extend({
    type: "piwikDispatcher",
    piwikEndPoint: function() {
        return org.ekstep.contenteditor.config.baseURL + "/piwik/piwik.php";
    },
    idsite: 1,
    initDispatcher: function() {},
    dispatch: function(event) {
        if (!event) return;

        try {
            event = (typeof event === "string") ? event : JSON.stringify(event);
            /* istanbul ignore next. Cannot test jquery post */
            org.ekstep.contenteditor.jQuery.post(this.piwikEndPoint(), 'idsite=' + this.idsite + '&url=' + org.ekstep.contenteditor.config.absURL + location.pathname + '&e_c=ContentEditor&e_a=' + event + '&rec=1', function() {
            })
            .fail(function() {
                console.log("error: while piwik dispatch");
            });
        } catch (e) {
            console.log('error: piwik event cannot be stringify', e);
        }
    }
}));

/**
 * @author Santhosh Vasabhaktula <santhosh@ilimi.in>
 */
'use strict';

angular.module('editorApp', ['ngDialog', 'oc.lazyLoad', 'Scope.safeApply']).config(['$locationProvider', function($locationProvider) {
    $locationProvider.html5Mode({
        enabled: true,
        requireBase: false
    });
}]);
angular.module('editorApp').controller('MainCtrl', ['$scope', '$timeout', '$http', '$location', '$q', '$window', '$document', '$ocLazyLoad', '$rootScope',
    function($scope, $timeout, $http, $location, $q, $window, $document, $ocLazyLoad, $rootScope) {

        // Declare global variables
        $scope.showAppLoadScreen = true;
        $scope.contentLoadedFlag = false;

        $scope.showGenieControls = false;

        $window.context = $window.context || window.parent.context;

        $scope.developerMode = $location.search().developerMode;

        $scope.appLoadMessage = [
            { 'id': 1, 'message': 'Getting things ready for you', 'status': false }
        ];
        $scope.model = {
            teacherInstructions: undefined
        }
        $scope.migration = {
            showMigrationError: false,
            showPostMigrationMsg: false,
            showMigrationSuccess: false
        }

        $scope.onLoadCustomMessage = {
            show: false,
            text: undefined
        }

        //toolbar(sidebar menu)
        $scope.configCategory = { selected: '' };
        $scope.cancelLink = (($window.context && $window.context.cancelLink) ? $window.context.cancelLink : "");
        $scope.reportIssueLink = (($window.context && $window.context.reportIssueLink) ? $window.context.reportIssueLink : "");

        $scope.context = $window.context;
        $scope.contentId = $location.search().contentId;
        if (_.isUndefined($scope.contentId)) {
            $scope.contentId = (($window.context && $window.context.content_id) ? $window.context.content_id : undefined)
        }

        //sidebar scope starts
        $scope.registeredCategories = [];
        $scope.loadNgModules = function(templatePath, controllerPath) {
            var files = [];
            if (templatePath) files.push({ type: 'html', path: templatePath });
            if (controllerPath) files.push({ type: 'js', path: controllerPath });
            if (files.length) return $ocLazyLoad.load(files)
        };

        org.ekstep.contenteditor.sidebarManager.initialize({ loadNgModules: $scope.loadNgModules, scope: $scope });

        $scope.fireSidebarTelemetry = function(menu, menuType) {
            var pluginId = "",
                pluginVer = "",
                objectId = "";
            var pluginObject = org.ekstep.contenteditor.api.getCurrentObject() || org.ekstep.contenteditor.api.getCurrentStage();
            if (pluginObject) {
                pluginId = pluginObject.manifest.id;
                pluginVer = pluginObject.manifest.ver;
                objectId = pluginObject.id;
            }
            $scope.telemetryService.interact({ "type": "modify", "subtype": "sidebar", "target": menuType, "pluginid": pluginId, 'pluginver': pluginVer, "objectid": objectId, "stage": org.ekstep.contenteditor.stageManager.currentStage.id });
        };

        $scope.addToSidebar = function(sidebar) {
            $scope.registeredCategories.push(sidebar);
            $scope.$safeApply();
        };

        $scope.refreshSidebar = function() {
            $scope.$safeApply();
        };
        //sidebar scope ends


        //Header scope starts
        $scope.headers = [];

        $scope.addToHeader = function(header) {
            $scope.headers.push(header);
            $scope.$safeApply();
        }

        org.ekstep.contenteditor.headerManager.initialize({ loadNgModules: $scope.loadNgModules, scope: $scope });

        //Header scope ends

        $scope.contentDetails = {
            contentTitle: "Untitled Content",
            contentImage: "/images/com_ekcontent/default-images/default-content.png",
            contentConcepts: "No concepts selected",
            contentType: ""
        };

        $scope.showInstructions = true;
        $scope.stageAttachments = {};

        // Functions
        $scope.closeLoadScreen = function(flag) {
            $scope.contentLoadedFlag = true;
            if (!$scope.migrationFlag || flag) {
                $scope.showAppLoadScreen = false;
            }
            $scope.$safeApply();
        }

        function toggleGenieControls() {
            if (!$scope.showGenieControls) {
                //Position the transparent image correctly on top of image
                setTimeout(function() {
                    org.ekstep.contenteditor.api.jQuery('#geniecontrols').css({
                        "display": 'block'
                    });
                }, 500);

            }
            $scope.showGenieControls = !$scope.showGenieControls;
        }

        $scope.toggleGenieControl = toggleGenieControls;

        $scope.convertToJSON = function(contentBody) {
            try {
                var x2js = new X2JS({ attributePrefix: 'none', enableToStringFunc: false });
                return x2js.xml_str2json(contentBody);
            } catch (e) {
                return;
            }
        }

        $scope.parseContentBody = function(contentBody) {
            try {
                contentBody = JSON.parse(contentBody);
            } catch (e) {
                contentBody = $scope.convertToJSON(contentBody);
            }
            if (_.isUndefined(contentBody) || _.isNull(contentBody)) {
                $scope.contentLoadedFlag = true;
                $scope.onLoadCustomMessage.show = true;
                $scope.onLoadCustomMessage.text = "Your content has errors! we are unable to read the content!";
                $scope.$safeApply();
                $scope.telemetryService.error({ "env": "content", "stage": "", "action": "show error and stop the application", "err": "Unable to read the content due to parse error", "type": "PORTAL", "data": "", "severity": "fatal" });
            };
            return contentBody;
        }

        $scope.onStageDragDrop = function(dragEl, dropEl) {
            org.ekstep.contenteditor.stageManager.onStageDragDrop(org.ekstep.contenteditor.jQuery('#' + dragEl).attr('data-id'), org.ekstep.contenteditor.jQuery('#' + dropEl).attr('data-id'));
            org.ekstep.contenteditor.api.refreshStages();
        }


        $scope.refreshToolbar = function() {
            setTimeout(function() {
                org.ekstep.contenteditor.jQuery(".ui.dropdown").dropdown();
                org.ekstep.contenteditor.jQuery(".popup-item").popup();
                $scope.$safeApply();
            }, 500);
        }

        /**
         * Content Editor Initialization
         */
        // Get context from url or window or parentwindow
        // Set the context
        var context = org.ekstep.contenteditor.getWindowContext();
        context.contentId = context.contentId ||  $scope.contentId;      

        // Get config from url or window or parentwindow
        // Add the absURL as below
        // Config to override
        var config = org.ekstep.contenteditor.getWindowConfig();
            config.absURL = $location.protocol() + '://' + $location.host() + ':' + $location.port() // Required
        
        /**
         * Load Content - Invoked once the content editor has loaded
         */
        $scope.loadContent = function() {
                org.ekstep.contenteditor.api.getService(ServiceConstants.CONTENT_SERVICE).getContent(org.ekstep.contenteditor.api.getContext('contentId'), function(err, content) {
                    if (err) {
                        $scope.contentLoadedFlag = true;
                        $scope.onLoadCustomMessage.show = true;
                        $scope.onLoadCustomMessage.text = ":( Unable to fetch the content! Please try again later!";
                        $scope.telemetryService.error({ "env": "content", "stage": "", "action": "show error and stop the application", "err": "Unable to fetch content from remote", "type": "API", "data": err, "severity": "fatal" });
                    }
                    if (!(content && content.body) && !err) {
                        org.ekstep.contenteditor.stageManager.onContentLoad((new Date()).getTime());
                        $scope.closeLoadScreen(true);
                    } else if (content && content.body) {
                        $scope.oldContentBody = angular.copy(content.body);
                        var parsedBody = $scope.parseContentBody(content.body);
                        if (parsedBody) org.ekstep.contenteditor.api.dispatchEvent("content:migration:start", { body: parsedBody, stageIcons: content.stageIcons });
                    }
                    if (content) {
                        var concepts = "";
                        if (!_.isUndefined(content.concepts)) {
                            concepts = _.size(content.concepts) <= 1 ? content.concepts[0].name : content.concepts[0].name + ' & ' + (_.size(content.concepts) - 1) + ' more';
                        }
                        $scope.contentDetails = {
                            contentTitle: content.name,
                            contentImage: content.appIcon,
                            contentConcepts: concepts
                        };

                        content.contentType ? ($scope.contentDetails.contentType = '| ' + content.contentType) : ($scope.contentDetails.contentType = "");
                        $scope.setTitleBarText($scope.contentDetails.contentTitle);
                    }
                });
            }
            /**
             * Initialize the ekstep editor
             * @param  {object} context The context for the editor to load
             * @param  {object} config The config for the editor to override/set
             * @param  {function} $scope Scope of the controller
             * @param  {function} callback Function to be invoked once the editor is loaded
             */
        org.ekstep.contenteditor.init(context, config, $scope, $document, function() {
            var obj = _.find($scope.appLoadMessage, { 'id': 1 });
            if (_.isObject(obj)) {
                obj.message = "Getting things ready for you";
                obj.status = true;
            }
            $scope.contentService = org.ekstep.contenteditor.api.getService(ServiceConstants.CONTENT_SERVICE);
            $scope.popupService = org.ekstep.contenteditor.api.getService(ServiceConstants.POPUP_SERVICE);
            $scope.telemetryService = org.ekstep.contenteditor.api.getService(ServiceConstants.TELEMETRY_SERVICE);
            $scope.menus = org.ekstep.contenteditor.toolbarManager.menuItems;
            $scope.contextMenus = org.ekstep.contenteditor.toolbarManager.contextMenuItems;
            $scope.stages = org.ekstep.contenteditor.api.getAllStages();
            $scope.currentStage = org.ekstep.contenteditor.api.getCurrentStage();
            $scope.sidebarMenus = org.ekstep.contenteditor.sidebarManager.getSidebarMenu();
            $scope.configCategory.selected = $scope.sidebarMenus[0].id;

            $scope.loadContent();
            /* KeyDown event to show ECML */
            $document.on("keydown", function(event) {
                if ((event.metaKey || event.ctrlKey) && event.shiftKey && event.keyCode == 69) { /*ctrl+shift+e or command+shift+e*/
                    event.preventDefault();
                    org.ekstep.contenteditor.api.dispatchEvent("org.ekstep.viewecml:show", {});
                }
            });
        });

        $scope.fireEvent = function(event) {
            if (event) org.ekstep.contenteditor.api.dispatchEvent(event.id, event.data);
        };

        $scope.setTitleBarText = function(text) {
            if (text) document.title = text;
        };

        $scope.fireToolbarTelemetry = function(menu, menuType) {
            $scope.telemetryService.interact({ "type": "click", "subtype": "menu", "target": menuType, "pluginid": '', 'pluginver': '', "objectid": menu.id, "stage": org.ekstep.contenteditor.stageManager.currentStage.id });
        };
    }
]);

org.ekstep.contenteditor.jQuery(document).ready(function() {
    var newheight = $(window).innerHeight() - 114;
    org.ekstep.contenteditor.jQuery('.scrollable-slides').css("height", newheight + "px");
});

angular.module('editorApp').controller('popupController', ['ngDialog', '$ocLazyLoad', function(ngDialog, $ocLazyLoad) {
    function loadNgModules(templatePath, controllerPath) {
        $ocLazyLoad.load([
            { type: 'html', path: templatePath },
            { type: 'js', path: controllerPath }
        ]);
    };

    function openModal(config, callback) {
        if (config && callback) config.preCloseCallback = callback;
        if (config) ngDialog.open(config);
    };

    org.ekstep.contenteditor.api.getService('popup').initService(loadNgModules, openModal);

}]);

angular.module('editorApp').directive('lvlDraggable', ['$rootScope', function ($rootScope) {
    return {
        restrict: 'A',
        link: function (scope, el, attrs, controller) {
            angular.element(el).attr("draggable", "true");

            var id = angular.element(el).attr("id");

            if (!id) {
                id = window.UUID();
                angular.element(el).attr("id", id);
            }
            
            el.bind("dragstart", function (e) {
                e.originalEvent.dataTransfer.setData('text', id);                
                $rootScope.$emit("LVL-DRAG-START");
            });

            el.bind("dragend", function (e) {
                $rootScope.$emit("LVL-DRAG-END");
            });
        }
    };
}]);
angular.module('editorApp').directive('lvlDropTarget', ['$rootScope', function ($rootScope) {
    return {
        restrict: 'A',
        scope: {
            onDrop: '&'
        },
        link: function (scope, el, attrs, controller) {
            var id = angular.element(el).attr("id");
            if (!id) {
                id = window.UUID();
                angular.element(el).attr("id", id);
            }

            el.bind("dragover", function (e) {
                if (e.preventDefault) {
                    e.preventDefault(); // Necessary. Allows us to drop.
                }

                e.originalEvent.dataTransfer.dropEffect = 'move';  // See the section on the DataTransfer object.
                return false;
            });

            el.bind("dragenter", function (e) {
                // this / e.target is the current hover target.
                angular.element(e.target).addClass('lvl-over');
            });

            el.bind("dragleave", function (e) {
                angular.element(e.target).removeClass('lvl-over');  // this / e.target is previous target element.
            });

            el.bind("drop", function (e) {
                if (e.preventDefault) {
                    e.preventDefault(); // Necessary. Allows us to drop.
                }

                if (e.stopPropagation) {
                    e.stopPropagation(); // Necessary. Allows us to drop.
                }
                var data = e.originalEvent.dataTransfer.getData("text");
                var dest = document.getElementById(id);
                var src = document.getElementById(data);

                scope.onDrop({dragEl: data, dropEl: id});
            });

            $rootScope.$on("LVL-DRAG-START", function () {
                var el = document.getElementById(id);
                angular.element(el).addClass("lvl-target");
            });

            $rootScope.$on("LVL-DRAG-END", function () {
                var el = document.getElementById(id);
                angular.element(el).removeClass("lvl-target");
                angular.element(el).removeClass("lvl-over");
            });
        }
    };
}]);
angular.module('editorApp').directive('compilehtml', ['$compile', function($compile) {
    return {
        restrict: 'A',
        replace: true,        
        link: function(scope, ele, attrs) {
            scope.$watch(attrs.compilehtml, function(html) {
                ele.html(html);
                $compile(ele.contents())(scope);
            });           
        }
    };
}]);
