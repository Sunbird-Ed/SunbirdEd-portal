// https://tc39.github.io/ecma262/#sec-array.prototype.find
//source: https://github.com/Modernizr/Modernizr/wiki/HTML5-Cross-Browser-Polyfills


/*
compiled by <sunils@ilimi.in> Sunil A S

Polyfill for Array:
1. find
2. filter
3. forEach
4. every
5. indexOf
6. map
7. lastIndexOf
8. reduce
9. reduceRight
10. isArray

*/
if (!Array.prototype.find) {
  Object.defineProperty(Array.prototype, 'find', {
    value: function(predicate) {
     // 1. Let O be ? ToObject(this value).
      if (this == null) {
        throw new TypeError('"this" is null or not defined');
      }

      var o = Object(this);

      // 2. Let len be ? ToLength(? Get(O, "length")).
      var len = o.length >>> 0;

      // 3. If IsCallable(predicate) is false, throw a TypeError exception.
      if (typeof predicate !== 'function') {
        throw new TypeError('predicate must be a function');
      }

      // 4. If thisArg was supplied, let T be thisArg; else let T be undefined.
      var thisArg = arguments[1];

      // 5. Let k be 0.
      var k = 0;

      // 6. Repeat, while k < len
      while (k < len) {
        // a. Let Pk be ! ToString(k).
        // b. Let kValue be ? Get(O, Pk).
        // c. Let testResult be ToBoolean(? Call(predicate, T, « kValue, k, O »)).
        // d. If testResult is true, return kValue.
        var kValue = o[k];
        if (predicate.call(thisArg, kValue, k, o)) {
          return kValue;
        }
        // e. Increase k by 1.
        k++;
      }

      // 7. Return undefined.
      return undefined;
    }
  });
}

if (!Array.prototype.filter) {
  Array.prototype.filter = function(fun/*, thisArg*/) {
    'use strict';

    if (this === void 0 || this === null) {
      throw new TypeError();
    }

    var t = Object(this);
    var len = t.length >>> 0;
    if (typeof fun !== 'function') {
      throw new TypeError();
    }

    var res = [];
    var thisArg = arguments.length >= 2 ? arguments[1] : void 0;
    for (var i = 0; i < len; i++) {
      if (i in t) {
        var val = t[i];

        // NOTE: Technically this should Object.defineProperty at
        //       the next index, as push can be affected by
        //       properties on Object.prototype and Array.prototype.
        //       But that method's new, and collisions should be
        //       rare, so use the more-compatible alternative.
        if (fun.call(thisArg, val, i, t)) {
          res.push(val);
        }
      }
    }

    return res;
  };
}

// Production steps of ECMA-262, Edition 5, 15.4.4.18
// Reference: http://es5.github.io/#x15.4.4.18
if (!Array.prototype.forEach) {

  Array.prototype.forEach = function(callback/*, thisArg*/) {

    var T, k;

    if (this == null) {
      throw new TypeError('this is null or not defined');
    }

    // 1. Let O be the result of calling toObject() passing the
    // |this| value as the argument.
    var O = Object(this);

    // 2. Let lenValue be the result of calling the Get() internal
    // method of O with the argument "length".
    // 3. Let len be toUint32(lenValue).
    var len = O.length >>> 0;

    // 4. If isCallable(callback) is false, throw a TypeError exception. 
    // See: http://es5.github.com/#x9.11
    if (typeof callback !== 'function') {
      throw new TypeError(callback + ' is not a function');
    }

    // 5. If thisArg was supplied, let T be thisArg; else let
    // T be undefined.
    if (arguments.length > 1) {
      T = arguments[1];
    }

    // 6. Let k be 0
    k = 0;

    // 7. Repeat, while k < len
    while (k < len) {

      var kValue;

      // a. Let Pk be ToString(k).
      //    This is implicit for LHS operands of the in operator
      // b. Let kPresent be the result of calling the HasProperty
      //    internal method of O with argument Pk.
      //    This step can be combined with c
      // c. If kPresent is true, then
      if (k in O) {

        // i. Let kValue be the result of calling the Get internal
        // method of O with argument Pk.
        kValue = O[k];

        // ii. Call the Call internal method of callback with T as
        // the this value and argument list containing kValue, k, and O.
        callback.call(T, kValue, k, O);
      }
      // d. Increase k by 1.
      k++;
    }
    // 8. return undefined
  };
}


if (!Array.prototype.every) {
  Array.prototype.every = function(callbackfn, thisArg) {
    'use strict';
    var T, k;

    if (this == null) {
      throw new TypeError('this is null or not defined');
    }

    // 1. Let O be the result of calling ToObject passing the this 
    //    value as the argument.
    var O = Object(this);

    // 2. Let lenValue be the result of calling the Get internal method
    //    of O with the argument "length".
    // 3. Let len be ToUint32(lenValue).
    var len = O.length >>> 0;

    // 4. If IsCallable(callbackfn) is false, throw a TypeError exception.
    if (typeof callbackfn !== 'function') {
      throw new TypeError();
    }

    // 5. If thisArg was supplied, let T be thisArg; else let T be undefined.
    if (arguments.length > 1) {
      T = thisArg;
    }

    // 6. Let k be 0.
    k = 0;

    // 7. Repeat, while k < len
    while (k < len) {

      var kValue;

      // a. Let Pk be ToString(k).
      //   This is implicit for LHS operands of the in operator
      // b. Let kPresent be the result of calling the HasProperty internal 
      //    method of O with argument Pk.
      //   This step can be combined with c
      // c. If kPresent is true, then
      if (k in O) {

        // i. Let kValue be the result of calling the Get internal method
        //    of O with argument Pk.
        kValue = O[k];

        // ii. Let testResult be the result of calling the Call internal method
        //     of callbackfn with T as the this value and argument list 
        //     containing kValue, k, and O.
        var testResult = callbackfn.call(T, kValue, k, O);

        // iii. If ToBoolean(testResult) is false, return false.
        if (!testResult) {
          return false;
        }
      }
      k++;
    }
    return true;
  };
}


// Production steps of ECMA-262, Edition 5, 15.4.4.14
// Reference: http://es5.github.io/#x15.4.4.14
if (!Array.prototype.indexOf) {
  Array.prototype.indexOf = function(searchElement, fromIndex) {

    var k;

    // 1. Let o be the result of calling ToObject passing
    //    the this value as the argument.
    if (this == null) {
      throw new TypeError('"this" is null or not defined');
    }

    var o = Object(this);

    // 2. Let lenValue be the result of calling the Get
    //    internal method of o with the argument "length".
    // 3. Let len be ToUint32(lenValue).
    var len = o.length >>> 0;

    // 4. If len is 0, return -1.
    if (len === 0) {
      return -1;
    }

    // 5. If argument fromIndex was passed let n be
    //    ToInteger(fromIndex); else let n be 0.
    var n = fromIndex | 0;

    // 6. If n >= len, return -1.
    if (n >= len) {
      return -1;
    }

    // 7. If n >= 0, then Let k be n.
    // 8. Else, n<0, Let k be len - abs(n).
    //    If k is less than 0, then let k be 0.
    k = Math.max(n >= 0 ? n : len - Math.abs(n), 0);

    // 9. Repeat, while k < len
    while (k < len) {
      // a. Let Pk be ToString(k).
      //   This is implicit for LHS operands of the in operator
      // b. Let kPresent be the result of calling the
      //    HasProperty internal method of o with argument Pk.
      //   This step can be combined with c
      // c. If kPresent is true, then
      //    i.  Let elementK be the result of calling the Get
      //        internal method of o with the argument ToString(k).
      //   ii.  Let same be the result of applying the
      //        Strict Equality Comparison Algorithm to
      //        searchElement and elementK.
      //  iii.  If same is true, return k.
      if (k in o && o[k] === searchElement) {
        return k;
      }
      k++;
    }
    return -1;
  };
}

// Production steps of ECMA-262, Edition 5, 15.4.4.19
// Reference: http://es5.github.io/#x15.4.4.19
if (!Array.prototype.map) {

  Array.prototype.map = function(callback/*, thisArg*/) {

    var T, A, k;

    if (this == null) {
      throw new TypeError('this is null or not defined');
    }

    // 1. Let O be the result of calling ToObject passing the |this| 
    //    value as the argument.
    var O = Object(this);

    // 2. Let lenValue be the result of calling the Get internal 
    //    method of O with the argument "length".
    // 3. Let len be ToUint32(lenValue).
    var len = O.length >>> 0;

    // 4. If IsCallable(callback) is false, throw a TypeError exception.
    // See: http://es5.github.com/#x9.11
    if (typeof callback !== 'function') {
      throw new TypeError(callback + ' is not a function');
    }

    // 5. If thisArg was supplied, let T be thisArg; else let T be undefined.
    if (arguments.length > 1) {
      T = arguments[1];
    }

    // 6. Let A be a new array created as if by the expression new Array(len) 
    //    where Array is the standard built-in constructor with that name and 
    //    len is the value of len.
    A = new Array(len);

    // 7. Let k be 0
    k = 0;

    // 8. Repeat, while k < len
    while (k < len) {

      var kValue, mappedValue;

      // a. Let Pk be ToString(k).
      //   This is implicit for LHS operands of the in operator
      // b. Let kPresent be the result of calling the HasProperty internal 
      //    method of O with argument Pk.
      //   This step can be combined with c
      // c. If kPresent is true, then
      if (k in O) {

        // i. Let kValue be the result of calling the Get internal 
        //    method of O with argument Pk.
        kValue = O[k];

        // ii. Let mappedValue be the result of calling the Call internal 
        //     method of callback with T as the this value and argument 
        //     list containing kValue, k, and O.
        mappedValue = callback.call(T, kValue, k, O);

        // iii. Call the DefineOwnProperty internal method of A with arguments
        // Pk, Property Descriptor
        // { Value: mappedValue,
        //   Writable: true,
        //   Enumerable: true,
        //   Configurable: true },
        // and false.

        // In browsers that support Object.defineProperty, use the following:
        // Object.defineProperty(A, k, {
        //   value: mappedValue,
        //   writable: true,
        //   enumerable: true,
        //   configurable: true
        // });

        // For best browser support, use the following:
        A[k] = mappedValue;
      }
      // d. Increase k by 1.
      k++;
    }

    // 9. return A
    return A;
  };
}

// Production steps of ECMA-262, Edition 5, 15.4.4.15
// Reference: http://es5.github.io/#x15.4.4.15
if (!Array.prototype.lastIndexOf) {
  Array.prototype.lastIndexOf = function(searchElement /*, fromIndex*/) {
    'use strict';

    if (this === void 0 || this === null) {
      throw new TypeError();
    }

    var n, k,
      t = Object(this),
      len = t.length >>> 0;
    if (len === 0) {
      return -1;
    }

    n = len - 1;
    if (arguments.length > 1) {
      n = Number(arguments[1]);
      if (n != n) {
        n = 0;
      }
      else if (n != 0 && n != (1 / 0) && n != -(1 / 0)) {
        n = (n > 0 || -1) * Math.floor(Math.abs(n));
      }
    }

    for (k = n >= 0 ? Math.min(n, len - 1) : len - Math.abs(n); k >= 0; k--) {
      if (k in t && t[k] === searchElement) {
        return k;
      }
    }
    return -1;
  };
}

// Production steps of ECMA-262, Edition 5, 15.4.4.21
// Reference: http://es5.github.io/#x15.4.4.21
// https://tc39.github.io/ecma262/#sec-array.prototype.reduce
if (!Array.prototype.reduce) {
  Object.defineProperty(Array.prototype, 'reduce', {
    value: function(callback /*, initialValue*/) {
      if (this === null) {
        throw new TypeError( 'Array.prototype.reduce ' + 
          'called on null or undefined' );
      }
      if (typeof callback !== 'function') {
        throw new TypeError( callback +
          ' is not a function');
      }

      // 1. Let O be ? ToObject(this value).
      var o = Object(this);

      // 2. Let len be ? ToLength(? Get(O, "length")).
      var len = o.length >>> 0; 

      // Steps 3, 4, 5, 6, 7      
      var k = 0; 
      var value;

      if (arguments.length >= 2) {
        value = arguments[1];
      } else {
        while (k < len && !(k in o)) {
          k++; 
        }

        // 3. If len is 0 and initialValue is not present,
        //    throw a TypeError exception.
        if (k >= len) {
          throw new TypeError( 'Reduce of empty array ' +
            'with no initial value' );
        }
        value = o[k++];
      }

      // 8. Repeat, while k < len
      while (k < len) {
        // a. Let Pk be ! ToString(k).
        // b. Let kPresent be ? HasProperty(O, Pk).
        // c. If kPresent is true, then
        //    i.  Let kValue be ? Get(O, Pk).
        //    ii. Let accumulator be ? Call(
        //          callbackfn, undefined,
        //          « accumulator, kValue, k, O »).
        if (k in o) {
          value = callback(value, o[k], k, o);
        }

        // d. Increase k by 1.      
        k++;
      }

      // 9. Return accumulator.
      return value;
    }
  });
}

// Production steps of ECMA-262, Edition 5, 15.4.4.22
// Reference: http://es5.github.io/#x15.4.4.22
if ('function' !== typeof Array.prototype.reduceRight) {
  Array.prototype.reduceRight = function(callback /*, initialValue*/) {
    'use strict';
    if (null === this || 'undefined' === typeof this) {
      throw new TypeError('Array.prototype.reduce called on null or undefined');
    }
    if ('function' !== typeof callback) {
      throw new TypeError(callback + ' is not a function');
    }
    var t = Object(this), len = t.length >>> 0, k = len - 1, value;
    if (arguments.length >= 2) {
      value = arguments[1];
    } else {
      while (k >= 0 && !(k in t)) {
        k--;
      }
      if (k < 0) {
        throw new TypeError('Reduce of empty array with no initial value');
      }
      value = t[k--];
    }
    for (; k >= 0; k--) {
      if (k in t) {
        value = callback(value, t[k], k, t);
      }
    }
    return value;
  };
}

if (!Array.isArray) {
  Array.isArray = function(arg) {
    return Object.prototype.toString.call(arg) === '[object Array]';
  };
}
/* Simple JavaScript Inheritance
 * By John Resig http://ejohn.org/
 * MIT Licensed.
 */
// Inspired by base2 and Prototype
(function() {
    /* istanbul ignore next */
    var initializing = false,
        fnTest = /xyz/.test(function() {
            xyz;
        }) ? /\b_super\b/ : /.*/;

    // The base Class implementation (does nothing)
    this.Class = function() {};

    // Create a new Class that inherits from this class
    Class.extend = function(prop) {
        var _super = this.prototype;

        // Instantiate a base class (but only create the instance,
        // don't run the init constructor)
        initializing = true;
        var prototype = new this();
        initializing = false;

        // Copy the properties over onto the new prototype
        for (var name in prop) {
            // Check if we're overwriting an existing function
            prototype[name] = typeof prop[name] == "function" &&
                typeof _super[name] == "function" && fnTest.test(prop[name]) ?
                (function(name, fn) {
                    return function() {
                        var tmp = this._super;

                        // Add a new ._super() method that is the same method
                        // but on the super-class
                        this._super = _super[name];

                        // The method only need to be bound temporarily, so we
                        // remove it when we're done executing
                        var ret = fn.apply(this, arguments);
                        this._super = tmp;

                        return ret;
                    };
                })(name, prop[name]) :
                prop[name];
        }

        // The dummy class constructor
        function Class() {
            // All construction is actually done in the init method
            if (!initializing && this.init)
                this.init.apply(this, arguments);
        }

        // Populate our constructed prototype object
        Class.prototype = prototype;

        // Enforce the constructor to be what we expect
        Class.prototype.constructor = Class;

        // And make this class extendable
        Class.extend = arguments.callee;

        return Class;
    };
})();

(function(root,factory){if(typeof exports==="object"&&typeof module==="object")module.exports=factory();else if(typeof define==="function"&&define.amd)define("EventBus",[],factory);else if(typeof exports==="object")exports["EventBus"]=factory();else root["EventBus"]=factory()})(this,function(){var EventBusClass={};EventBusClass=function(){this.listeners={}};EventBusClass.prototype={addEventListener:function(type,callback,scope){var args=[];var numOfArgs=arguments.length;for(var i=0;i<numOfArgs;i++){args.push(arguments[i])}args=args.length>3?args.splice(3,args.length-1):[];if(typeof this.listeners[type]!="undefined"){this.listeners[type].push({scope:scope,callback:callback,args:args})}else{this.listeners[type]=[{scope:scope,callback:callback,args:args}]}},removeEventListener:function(type,callback,scope){if(typeof this.listeners[type]!="undefined"){var numOfCallbacks=this.listeners[type].length;var newArray=[];for(var i=0;i<numOfCallbacks;i++){var listener=this.listeners[type][i];if(listener.scope==scope&&listener.callback==callback){}else{newArray.push(listener)}}this.listeners[type]=newArray}},hasEventListener:function(type,callback,scope){if(typeof this.listeners[type]!="undefined"){var numOfCallbacks=this.listeners[type].length;if(callback===undefined&&scope===undefined){return numOfCallbacks>0}for(var i=0;i<numOfCallbacks;i++){var listener=this.listeners[type][i];if((scope?listener.scope==scope:true)&&listener.callback==callback){return true}}}return false},dispatch:function(type,target){var numOfListeners=0;var event={type:type,target:target};var args=[];var numOfArgs=arguments.length;for(var i=0;i<numOfArgs;i++){args.push(arguments[i])}args=args.length>2?args.splice(2,args.length-1):[];args=[event].concat(args);if(typeof this.listeners[type]!="undefined"){var numOfCallbacks=this.listeners[type].length;for(var i=0;i<numOfCallbacks;i++){var listener=this.listeners[type][i];if(listener&&listener.callback){var concatArgs=args.concat(listener.args);listener.callback.apply(listener.scope,concatArgs);numOfListeners+=1}}}},getEvents:function(){var str="";for(var type in this.listeners){var numOfCallbacks=this.listeners[type].length;for(var i=0;i<numOfCallbacks;i++){var listener=this.listeners[type][i];str+=listener.scope&&listener.scope.className?listener.scope.className:"anonymous";str+=" listen for '"+type+"'\n"}}return str}};var EventBus=new EventBusClass;return EventBus});
/* mousetrap v1.6.0 craig.is/killing/mice */
(function(r,t,g){function u(a,b,h){a.addEventListener?a.addEventListener(b,h,!1):a.attachEvent("on"+b,h)}function y(a){if("keypress"==a.type){var b=String.fromCharCode(a.which);a.shiftKey||(b=b.toLowerCase());return b}return k[a.which]?k[a.which]:p[a.which]?p[a.which]:String.fromCharCode(a.which).toLowerCase()}function D(a){var b=[];a.shiftKey&&b.push("shift");a.altKey&&b.push("alt");a.ctrlKey&&b.push("ctrl");a.metaKey&&b.push("meta");return b}function v(a){return"shift"==a||"ctrl"==a||"alt"==a||
"meta"==a}function z(a,b){var h,c,e,g=[];h=a;"+"===h?h=["+"]:(h=h.replace(/\+{2}/g,"+plus"),h=h.split("+"));for(e=0;e<h.length;++e)c=h[e],A[c]&&(c=A[c]),b&&"keypress"!=b&&B[c]&&(c=B[c],g.push("shift")),v(c)&&g.push(c);h=c;e=b;if(!e){if(!n){n={};for(var l in k)95<l&&112>l||k.hasOwnProperty(l)&&(n[k[l]]=l)}e=n[h]?"keydown":"keypress"}"keypress"==e&&g.length&&(e="keydown");return{key:c,modifiers:g,action:e}}function C(a,b){return null===a||a===t?!1:a===b?!0:C(a.parentNode,b)}function c(a){function b(a){a=
a||{};var b=!1,m;for(m in n)a[m]?b=!0:n[m]=0;b||(w=!1)}function h(a,b,m,f,c,h){var g,e,k=[],l=m.type;if(!d._callbacks[a])return[];"keyup"==l&&v(a)&&(b=[a]);for(g=0;g<d._callbacks[a].length;++g)if(e=d._callbacks[a][g],(f||!e.seq||n[e.seq]==e.level)&&l==e.action){var q;(q="keypress"==l&&!m.metaKey&&!m.ctrlKey)||(q=e.modifiers,q=b.sort().join(",")===q.sort().join(","));q&&(q=f&&e.seq==f&&e.level==h,(!f&&e.combo==c||q)&&d._callbacks[a].splice(g,1),k.push(e))}return k}function g(a,b,m,f){d.stopCallback(b,
b.target||b.srcElement,m,f)||!1!==a(b,m)||(b.preventDefault?b.preventDefault():b.returnValue=!1,b.stopPropagation?b.stopPropagation():b.cancelBubble=!0)}function e(a){"number"!==typeof a.which&&(a.which=a.keyCode);var b=y(a);b&&("keyup"==a.type&&x===b?x=!1:d.handleKey(b,D(a),a))}function k(a,c,m,f){function e(c){return function(){w=c;++n[a];clearTimeout(r);r=setTimeout(b,1E3)}}function h(c){g(m,c,a);"keyup"!==f&&(x=y(c));setTimeout(b,10)}for(var d=n[a]=0;d<c.length;++d){var p=d+1===c.length?h:e(f||
z(c[d+1]).action);l(c[d],p,f,a,d)}}function l(a,b,c,f,e){d._directMap[a+":"+c]=b;a=a.replace(/\s+/g," ");var g=a.split(" ");1<g.length?k(a,g,b,c):(c=z(a,c),d._callbacks[c.key]=d._callbacks[c.key]||[],h(c.key,c.modifiers,{type:c.action},f,a,e),d._callbacks[c.key][f?"unshift":"push"]({callback:b,modifiers:c.modifiers,action:c.action,seq:f,level:e,combo:a}))}var d=this;a=a||t;if(!(d instanceof c))return new c(a);d.target=a;d._callbacks={};d._directMap={};var n={},r,x=!1,p=!1,w=!1;d._handleKey=function(a,
c,e){var f=h(a,c,e),d;c={};var k=0,l=!1;for(d=0;d<f.length;++d)f[d].seq&&(k=Math.max(k,f[d].level));for(d=0;d<f.length;++d)f[d].seq?f[d].level==k&&(l=!0,c[f[d].seq]=1,g(f[d].callback,e,f[d].combo,f[d].seq)):l||g(f[d].callback,e,f[d].combo);f="keypress"==e.type&&p;e.type!=w||v(a)||f||b(c);p=l&&"keydown"==e.type};d._bindMultiple=function(a,b,c){for(var d=0;d<a.length;++d)l(a[d],b,c)};u(a,"keypress",e);u(a,"keydown",e);u(a,"keyup",e)}if(r){var k={8:"backspace",9:"tab",13:"enter",16:"shift",17:"ctrl",
18:"alt",20:"capslock",27:"esc",32:"space",33:"pageup",34:"pagedown",35:"end",36:"home",37:"left",38:"up",39:"right",40:"down",45:"ins",46:"del",91:"meta",93:"meta",224:"meta"},p={106:"*",107:"+",109:"-",110:".",111:"/",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'"},B={"~":"`","!":"1","@":"2","#":"3",$:"4","%":"5","^":"6","&":"7","*":"8","(":"9",")":"0",_:"-","+":"=",":":";",'"':"'","<":",",">":".","?":"/","|":"\\"},A={option:"alt",command:"meta","return":"enter",
escape:"esc",plus:"+",mod:/Mac|iPod|iPhone|iPad/.test(navigator.platform)?"meta":"ctrl"},n;for(g=1;20>g;++g)k[111+g]="f"+g;for(g=0;9>=g;++g)k[g+96]=g;c.prototype.bind=function(a,b,c){a=a instanceof Array?a:[a];this._bindMultiple.call(this,a,b,c);return this};c.prototype.unbind=function(a,b){return this.bind.call(this,a,function(){},b)};c.prototype.trigger=function(a,b){if(this._directMap[a+":"+b])this._directMap[a+":"+b]({},a);return this};c.prototype.reset=function(){this._callbacks={};this._directMap=
{};return this};c.prototype.stopCallback=function(a,b){return-1<(" "+b.className+" ").indexOf(" mousetrap ")||C(b,this.target)?!1:"INPUT"==b.tagName||"SELECT"==b.tagName||"TEXTAREA"==b.tagName||b.isContentEditable};c.prototype.handleKey=function(){return this._handleKey.apply(this,arguments)};c.addKeycodes=function(a){for(var b in a)a.hasOwnProperty(b)&&(k[b]=a[b]);n=null};c.init=function(){var a=c(t),b;for(b in a)"_"!==b.charAt(0)&&(c[b]=function(b){return function(){return a[b].apply(a,arguments)}}(b))};
c.init();r.Mousetrap=c;"undefined"!==typeof module&&module.exports&&(module.exports=c);"function"===typeof define&&define.amd&&define(function(){return c})}})("undefined"!==typeof window?window:null,"undefined"!==typeof window?document:null);

/**
 * @author Santhosh Vasabhaktula <santhosh@ilimi.in>
 */

// Declare Namespace
window.org = { ekstep: {} }

var plugin_framework = function() {};
plugin_framework.prototype.initialize = function(config) {
    config = config || {};
    org.ekstep.pluginframework.config = org.ekstep.pluginframework.config || {};
    if (!config.env) throw "Framework should be initialized with environment!";
    org.ekstep.pluginframework.env = config.env;
    org.ekstep.pluginframework.jQuery = config.jQuery || window.$;
    org.ekstep.pluginframework.async = config.async || window.async;
    org.ekstep.pluginframework.config.build_number = config.build_number || 'BUILD_NUMBER';
    org.ekstep.pluginframework.config.pluginRepo = config.pluginRepo || '/content-plugins';
};

window.org.ekstep.pluginframework = new plugin_framework();
plugin_framework = undefined;

var services_framework = function() {};
window.org.ekstep.services = new services_framework();
services_framework = undefined;
/**
 * @author Harish kumar Gangula<harishg@ilimi.in>
 */
org.ekstep.pluginframework.resourceManager = new(Class.extend({
    init: function() {},
    buildNumber: undefined,
    registeredRepos: [],    
    discoverManifest: function(pluginId, pluginVer, cb, publishedTime) {
        var ayncTasks = [];
        
        if (typeof pluginVer === "number") pluginVer = pluginVer.toFixed(1);

        this.registeredRepos.forEach(function(repo, index) {
            var Fns = function() {
                if (index == 0) {
                    return function(callback) {
                        repo.discoverManifest(pluginId, pluginVer, callback, publishedTime);
                    }
                } else {
                    return function(data, callback) {
                        if (data.manifest == undefined) {
                            repo.discoverManifest(pluginId, pluginVer, callback, publishedTime);
                        } else {
                            callback(null, data);
                        }
                    }
                }
            };

            ayncTasks.push(Fns());
        });

        org.ekstep.pluginframework.async.waterfall(ayncTasks, function(err, result) {
            if (result && result.manifest !== undefined)
                cb(undefined, result);
            else
                cb('Plugin not found in any repo or manifest', undefined);
        });

    },
    addRepo: function(repo, position) {
        var repoFound = this.registeredRepos.find(function(rp) {
            return rp.id == repo.id;
        });

        if (!repoFound) {
            if (typeof position === 'number') this.registeredRepos.splice(position, 0, repo)
            else this.registeredRepos.push(repo);
        } else {
            console.error(repo.id + ': Repo already registered!');
        }
    },
    getResource: function(pluginId, pluginVer, src, dataType, repo, callback, publishedTime) {
        var resource = repo.resolveResource(pluginId, pluginVer, src);
        this.loadResource(resource, dataType, callback, publishedTime);
    },
    loadExternalPluginResource: function(type, pluginId, pluginVer, src, repo, publishedTime, callback) {
        var resource = repo.resolveResource(pluginId, pluginVer, src);
        this.loadExternalResource(resource, type, publishedTime, callback);
    },
    loadExternalResource: function(resource, type, publishedTime, callback) {
        switch (type) {
            case 'js':
                if (callback)
                    this.loadResource(resource, 'script', callback, publishedTime);
                else
                    org.ekstep.pluginframework.jQuery("body").append($("<script type='text/javascript' src=" + resource + "?" + org.ekstep.pluginframework.config.build_number + "&" + (publishedTime || "") + ">"));
                break;
            case 'css':
                org.ekstep.pluginframework.jQuery("head").append("<link rel='stylesheet' type='text/css' href='" + resource + "?" + org.ekstep.pluginframework.config.build_number + "&" + (publishedTime || "") + "'>");
                if (callback) callback();
                break;
            default:
                if (callback) callback();
        }
    },
    loadResource: function(url, dataType, callback, publishedTime) {
        url = url + "?" + (org.ekstep.pluginframework.config ? org.ekstep.pluginframework.config.build_number : '');
        if (publishedTime) {
            url = url + "&" + publishedTime;
        }
        org.ekstep.pluginframework.jQuery.ajax({
            async: false,
            url: url,
            dataType: dataType
        }).done(function(data) {
            callback(null, data);
        }).fail(function(jqXHR, textStatus, errorThrown) {
            if(jqXHR.statusText === 'OK') {
                console.log('Unable to load resource:', url, 'error:', errorThrown);
            }
            callback(errorThrown)
        });
    }
}));

/**
 * @author Santhosh Vasabhaktula <santhosh@ilimi.in>
 */
org.ekstep.pluginframework.eventManager = new (Class.extend({
	enableEvents: true,
	addEventListener: function(type, callback, scope) {
		EventBus.addEventListener(type, callback, scope)
	},
	dispatchEvent: function(type, data, target) {
		if(this.enableEvents) EventBus.dispatch(type, target, data);
	},
	removeEventListener: function(type, callback, scope) {
		EventBus.removeEventListener(type, callback, scope);
	}
}));
/**
 * @author Santhosh Vasabhaktula <santhosh@ilimi.in>
 */
org.ekstep.pluginframework.pluginManager = new(Class.extend({
    pluginManifests: {},
    plugins: {},
    pluginObjs: {},
    pluginInstances: {},
    errors: [],
    init: function() {        
        console.log("Plugin manager initialized");        
    },
    _registerPlugin: function(pluginId, pluginVer, plugin, manifest, repo) {
        this.plugins[pluginId] = { p: plugin, m: manifest, repo: repo };
        this._registerNameSpace(pluginId, plugin);
        if (manifest) this.pluginManifests[manifest.id] =  { m: manifest, repo: repo };
        org.ekstep.pluginframework.eventManager.dispatchEvent('plugin:load', { plugin: pluginId, version: pluginVer });
        org.ekstep.pluginframework.eventManager.dispatchEvent(pluginId + ':load');
        var p = new plugin(manifest); 
        if (manifest) this.pluginObjs[manifest.id] = p;        
    },
    registerPlugin: function(manifest, plugin, repo) {
        repo = repo || org.ekstep.pluginframework.publishedRepo;
        this._registerPlugin(manifest.id, manifest.ver, plugin, manifest, repo);        
    },
    loadCustomPlugin: function(dependency, callback, publishedTime) {
        var instance = this;
        org.ekstep.pluginframework.resourceManager.loadResource(dependency.src, 'text', function(err, data) {
            if (err) {
                org.ekstep.pluginframework.eventManager.dispatchEvent('plugin:error', { plugin: dependency.id, version: dependency.ver, action: "load", err: err });                
                console.error('Unable to load editor plugin', 'plugin:' + dependency.id + '-' + dependency.ver, 'resource:', 'Error:', err);
            } else {
                try {
                    if (!instance.isPluginDefined(dependency.id)) {
                        data = eval(data);
                        instance._registerPlugin(dependency.id, undefined, data, undefined, undefined);
                    } else {
                        console.info("Plugin is already registered: ", dependency.id);
                    }
                } catch (e) {
                    org.ekstep.pluginframework.eventManager.dispatchEvent('plugin:error', { plugin: dependency.id, version: dependency.ver, action: "load", err: e });
                    console.error("Error while loading plugin", 'plugin:' + dependency.id + '-' + dependency.ver, 'Error:', e);
                }
            }
            callback && callback();
        }, publishedTime);
    },
    loadPluginByManifest: function(manifest, repo, pluginType, publishedTime) {
        var instance = this;
        var scope = org.ekstep.pluginframework.env;        
        if(manifest[scope] && manifest[scope].main) org.ekstep.pluginframework.resourceManager.getResource(manifest.id, manifest.ver, manifest[scope].main, 'text', repo, function(err, data) {
            if (err) {
                org.ekstep.pluginframework.eventManager.dispatchEvent('plugin:error', { plugin: manifest.id, version: manifest.ver, action: "load", err: err });
                console.error('Unable to load editor plugin', 'plugin:' + manifest.id + '-' + manifest.ver, 'resource:' + manifest[scope].main, 'Error:', err);
            } else {
                try {
                    if (!instance.isPluginDefined(manifest.id)) {
                        if (pluginType == 'library') {
                            org.ekstep.pluginframework.jQuery.globalEval(data);
                        } else {
                            if (data) instance.registerPlugin(manifest, eval(data), repo);
                        }
                    } else {
                        console.info("Plugin is already registered: ", manifest.id);
                    }
                } catch (e) {
                    org.ekstep.pluginframework.eventManager.dispatchEvent('plugin:error', { plugin: manifest.id, version: manifest.ver, action: "load", err: e });
                    console.error("Error while loading plugin", 'plugin:' + manifest.id + '-' + manifest.ver, 'Error:', e);
                }
            }
        }, publishedTime);
    },
    _registerNameSpace: function(pluginId, clazz) {
        console.info("Registering namespace for plugin:", pluginId);
        var names = pluginId.split('.')
        var baseNameSpace = names[0];
        var lastKey = names[names.length-1];
        names.splice(0, 1);

        var pluginClazz = (org.ekstep.pluginframework.env === 'editor') ? Class.extend({
            init: function(data, parent, override) {
                org.ekstep.pluginframework.pluginManager.invoke(pluginId, data, parent, override);
            }
        }) : Class.extend({
            init: function(data, parent, stage, theme) {
                org.ekstep.pluginframework.pluginManager.invokeRenderer(pluginId, data, parent, stage, theme);
            }
        });
        pluginClazz.extend = function(subClazz) {
            return clazz.extend(subClazz);
        }

        if(names.length > 0) {
            if (!window[baseNameSpace]) {
                window[baseNameSpace] = {};
            }
            names.reduce(function(o, s) {
                var val = ((s === lastKey) ? pluginClazz : {});
                return (o[s] === undefined) ? o[s] = val : o[s] 
            }, window[baseNameSpace]);
        } else {
            if(window[baseNameSpace] === undefined) window[baseNameSpace] = pluginClazz;
        }
    },
    loadAndInitPlugin: function(pluginId, version, publishedTime, parent) {
        var self = this;
        if (this.isPluginDefined(pluginId)) {
            var pluginManifest = this.getPluginManifest(pluginId);
            if (pluginManifest.type && (pluginManifest.type.toLowerCase() === "widget")) {
                this.invoke(pluginId, JSON.parse(JSON.stringify(pluginManifest[org.ekstep.pluginframework.env]['init-data'] || {})), parent);
            }
        } else {
            this.loadPluginWithDependencies(pluginId, version, undefined, publishedTime, [], function() {
                if (self.isPluginDefined(pluginId)) {
                    var pluginManifest = self.getPluginManifest(pluginId);
                    if (pluginManifest.type && (pluginManifest.type.toLowerCase() === "widget")) {
                        self.invoke(pluginId, JSON.parse(JSON.stringify(pluginManifest[org.ekstep.pluginframework.env]['init-data'] || {})), parent);
                    }
                }
            });
        }
    },
    loadPluginWithDependencies: function(pluginId, pluginVer, pluginType, publishedTime, parents, callback) {
        var instance = this;
        if (this.plugins[pluginId]) {
            console.info('A plugin with id "' + pluginId + '" and ver "' + pluginVer + '" is already loaded');
            callback && callback();
            return;
        }

        if(parents.indexOf(pluginId) != -1) {
            console.warn('Detected a cyclic dependency with the plugin: "' + pluginId + '". Breaking the chain...');
            callback && callback();
            return;
        }

        parents.push(pluginId);
        org.ekstep.pluginframework.resourceManager.discoverManifest(pluginId, pluginVer, function(err, data) {
            if (err || (data == undefined)) {
                org.ekstep.pluginframework.eventManager.dispatchEvent('plugin:error', { plugin: pluginId, version: pluginVer, action: "load", err: err });
                console.error('Unable to load plugin manifest', 'plugin:' + pluginId + '-' + pluginVer, 'Error:', err);
                callback && callback(); // TODO: probably pass the error
            } else {
                instance.loadManifestDependencies(data.manifest.dependencies, publishedTime, parents, function() {
                    if (!data.manifest.editor || Object.keys(data.manifest.editor).length === 0) {
                        instance.pluginManifests[data.manifest.id] = { m: data.manifest, repo: data.repo };                        
                    }                    
                    var queue = instance.queueDependencies(data.manifest, data.repo, publishedTime, parents);
                    if (queue.length() > 0) {
                        queue.drain = function() {
                            instance.loadPluginByManifest(data.manifest, data.repo, pluginType, publishedTime);
                            callback && callback();
                        };
                    } else {
                        instance.loadPluginByManifest(data.manifest, data.repo, pluginType, publishedTime);
                        callback && callback();
                    }
                });
            }
        }, publishedTime);
    },
    queueDependencies: function(manifest, repo, publishedTime, parents) {
        var scope = org.ekstep.pluginframework.env;
        var queue = org.ekstep.pluginframework.async.queue(function(task, callback) {
            if (task.type == 'plugin') {
                if (org.ekstep.pluginframework.env == 'renderer') {
                    instance.loadCustomPlugin({id: task.plugin, src: task.repo.resolveResource(task.id, task.ver, task.src)}, callback, undefined);
                } else {
                    instance.loadPluginWithDependencies(task.plugin, task.ver, task.type, publishedTime, parents, callback);
                }
            } else {
                org.ekstep.pluginframework.resourceManager.loadExternalPluginResource(task.type, task.id, task.ver, task.src, task.repo, task.publishedTime, callback);
            }
        }, 1);
        var instance = this;
        if (manifest[scope] && Array.isArray(manifest[scope].dependencies)) {
            manifest[scope].dependencies.forEach(function(dependency) {
                if (dependency.type == 'plugin') {
                    if (org.ekstep.pluginframework.env == 'renderer') {
                        queue.push({
                            type: dependency.type,
                            id: manifest.id,
                            ver: manifest.ver,
                            src: dependency.src,
                            repo: repo,
                            plugin: dependency.id
                        }, function() {});
                    } else {
                        queue.push(dependency, function() {});
                    }
                } else if(dependency.type == 'js' || dependency.type == 'css') {
                    queue.push({
                        type: dependency.type,
                        id: manifest.id,
                        ver: manifest.ver,
                        src: dependency.src,
                        repo: repo,
                        publishedTime: publishedTime
                    }, function() {});
                }
            });
        }
        return queue;
    },
    loadManifestDependencies: function(dependencies, publishedTime, parents, callback) {
        var instance = this;
        if (Array.isArray(dependencies) && dependencies.length > 0) {
            var queue = org.ekstep.pluginframework.async.queue(function(plugin, pluginCallback) {
                instance.loadPluginWithDependencies(plugin.id, plugin.ver, plugin.type, plugin.pt, parents, pluginCallback);
            }, 1);
            dependencies.forEach(function(dep) {
                if (org.ekstep.pluginframework.env == 'renderer') {
                    if (dep.scope == org.ekstep.pluginframework.env || dep.scope == 'all') {
                        queue.push({ 'id': dep.plugin, 'ver': dep.ver, 'type': dep.type, 'pt': publishedTime }, function(err) {});
                    }
                } else {
                    queue.push({ 'id': dep.plugin, 'ver': dep.ver, 'type': dep.type, 'pt': publishedTime }, function(err) {});
                }
            });
            if (queue.length() > 0) {
                queue.drain = function() {
                    callback && callback();
                };
            } else {
                callback && callback();
            }
        } else {
            callback && callback();
        }
    },
    isManifestDefined: function(id) {
        if (this.pluginManifests[id]) {
            return true;
        } else {
            return false;
        }
    },
    isPluginDefined: function(id) {
        if (this.plugins[id]) {
            return true;
        } else {
            return false;
        }
    },
    loadPlugin: function(pluginId, pluginVer, callback) {
        this.loadPluginWithDependencies(pluginId, pluginVer, "plugin", undefined, [], function() {
           callback && callback();
        });
    },
    loadAllPlugins: function(plugins, otherDependencies, callback) {
        var instance = this;
        if (Array.isArray(plugins) && plugins.length) {
            var preloadPlugin = plugins.find(function(plugin) {
                return (plugin.preload === true || plugin.preload === 'true');
            });
            if(preloadPlugin) {
                instance.loadPlugin(preloadPlugin.id, preloadPlugin.ver, function() {
                    instance._loadPlugins(plugins, otherDependencies, callback);
                })
            } else {
                instance._loadPlugins(plugins, otherDependencies, callback);
            }
        } else if (Array.isArray(otherDependencies) && otherDependencies.length) {
            instance.loadOtherDependencies(otherDependencies, callback);
        } else {
            callback && callback();
        }
    },
    _loadPlugins: function(plugins, otherDependencies, callback) {
        var instance = this;
        var q = org.ekstep.pluginframework.async.queue(function(plugin, pluginCallback) {
            instance.loadPluginWithDependencies(plugin.id, plugin.ver, plugin.type, plugin.pt, [], pluginCallback);
        }, 6);
        q.drain = function() {
            instance.loadOtherDependencies(otherDependencies, callback);
        };
        plugins.forEach(function(plugin) {
            q.push({ 'id': plugin.id, 'ver': plugin.ver, 'type': plugin.type, 'pt': undefined }, function(err) {});
        });
    },
    loadOtherDependencies: function(otherDependencies, callback) {
        var instance = this;
        if (Array.isArray(otherDependencies) && otherDependencies.length) {
            var queue = org.ekstep.pluginframework.async.queue(function(dependency, cb) {
                if (dependency.type == 'plugin') {
                    instance.loadCustomPlugin(dependency, cb);
                } else {
                    org.ekstep.pluginframework.resourceManager.loadExternalResource(dependency.src, dependency.type, undefined, cb);
                }
            }, 1);
            otherDependencies.forEach(function(dep) {
                queue.push(dep, function(err) {});
            });
            if (queue.length() > 0) {
                queue.drain = function() {
                    callback && callback();
                };
            } else {
                callback && callback();
            }
        } else {
            callback && callback();
        }
    },
    invoke: function(id, data, parent, override) {
        var instance = this;
        var p = undefined;
        var plugin = this.plugins[id];
        if (!plugin) {
            this.addError('No plugin found for - ' + id);
        } else {
            var pluginClass = override ? plugin.p.extend(override) : plugin.p;
            var pluginManifest = plugin.m;
            try {
                if (Array.isArray(data)) {
                    data.forEach(function(d) {
                        p = new pluginClass(pluginManifest, d, parent);
                        instance.addPluginInstance(p);
                        p.initPlugin();
                        org.ekstep.pluginframework.eventManager.dispatchEvent('plugin:add', { plugin: pluginManifest.id, version: pluginManifest.ver, instanceId: p.id });
                        org.ekstep.pluginframework.eventManager.dispatchEvent(pluginManifest.id + ':add');
                    })
                } else {
                    p = new pluginClass(pluginManifest, data, parent);
                    instance.addPluginInstance(p);
                    p.initPlugin();
                    org.ekstep.pluginframework.eventManager.dispatchEvent('plugin:add', { plugin: pluginManifest.id, version: pluginManifest.ver, instanceId: p.id });
                    org.ekstep.pluginframework.eventManager.dispatchEvent(pluginManifest.id + ':add');
                }
            } catch (e) {
                org.ekstep.pluginframework.eventManager.dispatchEvent('plugin:error', { plugin: pluginManifest.id, version: pluginManifest.ver, action: "invoke", err: e });
                if(p) delete instance.pluginInstances[p.id];
                throw "Error: when instantiating plugin: "+ id;
            }
        }
        return p;
    },
    invokeRenderer: function(id, data, parent, stage, theme) {
        var instance = this;
        var p = undefined;
        var plugin = this.plugins[id];
        if (!plugin) {
            this.addError('No plugin found for - ' + id);
        } else {
            try {
                var pluginClass = plugin.p;
                var pluginManifest = plugin.m || { id: id, ver: undefined };
                if (Array.isArray(data)) {
                    data.forEach(function(d) {
                        p = new pluginClass(d, parent, stage, theme);
                        instance.addPluginInstance(p);
                        org.ekstep.pluginframework.eventManager.dispatchEvent('plugin:add', { plugin: pluginManifest.id, version: pluginManifest.ver, instanceId: p.id });
                        org.ekstep.pluginframework.eventManager.dispatchEvent(pluginManifest.id + ':add');
                    })
                } else {
                    p = new pluginClass(data, parent, stage, theme);
                    instance.addPluginInstance(p);
                    org.ekstep.pluginframework.eventManager.dispatchEvent('plugin:add', { plugin: pluginManifest.id, version: pluginManifest.ver, instanceId: p.id });
                    org.ekstep.pluginframework.eventManager.dispatchEvent(pluginManifest.id + ':add');
                }
            } catch (e) {
                org.ekstep.pluginframework.eventManager.dispatchEvent('plugin:error', { plugin: pluginManifest.id, version: pluginManifest.ver, action: "invoke", err: e });
                if(p) delete instance.pluginInstances[p.id];
                throw "Error: when instantiating plugin: "+ id;
            }
        }
        return p;
    },
    addPluginInstance: function(pluginObj) {
        this.pluginInstances[pluginObj.id] = pluginObj;
    },
    removePluginInstance: function(pluginObj) {        
        if (pluginObj) pluginObj.remove();
    },
    getPluginInstance: function(id) {
        return this.pluginInstances[id];
    },
    getPluginInstances: function() {
        return this.pluginInstances;
    },
    getPluginManifest: function(id) {
        var plugin = this.plugins[id] || this.pluginManifests[id];
        if (plugin) {
            return plugin.m;
        } else {
            return undefined;
        }
    },
    addError: function(error) {
        this.errors.push(error);
    },
    getErrors: function() {
        return this.errors;
    },
    cleanUp: function() {
        this.pluginInstances = {};
        this.pluginManifests = {};
        this.plugins = {};
        this.errors = [];
    },
    getPlugins: function() {
        return Object.keys(this.plugins);
    },
    getPluginType: function(id) {
        if (this.pluginInstances[id]) {
            return this.pluginInstances[id].getType();
        } else {
            return '';
        }
    },
    loadPluginResource: function(pluginId, pluginVer, src, dataType, callback) {
        if (this.plugins[pluginId]) {
            org.ekstep.pluginframework.resourceManager.getResource(pluginId, pluginVer, src, dataType, this.plugins[pluginId]['repo'], callback)
        } else {
            callback(new Error("unable load plugin resource " + src), undefined)
        }
    },
    getPluginVersion: function(id) {
        if (this.pluginInstances[id]) {
            return this.pluginInstances[id].getVersion();
        } else {
            return '';

        }
    },
    resolvePluginResource: function(id, ver, resource) {
        if (this.plugins[id] && this.plugins[id]["repo"]) {
            return this.plugins[id]["repo"].resolveResource(id, ver, resource);
        } else if(this.pluginManifests[id] && this.pluginManifests[id]["repo"]) {
            return this.pluginManifests[id]["repo"].resolveResource(id, ver, resource);
        } else {
            return false;
        }
    }
}));

/**
 * @author Santhosh Vasabhaktula <santhosh@ilimi.in>
 */
org.ekstep.pluginframework.keyboardManager = new (Class.extend({
	registry: {},
	registerKeyCombination: function(command, callback) {
		if(command !== undefined && callback !== undefined){
			Mousetrap.bind(command, callback);
		} else {
			throw "The given key combination is invalid.";
		}
	}
}));
/* istanbul ignore next */
org.ekstep.services.iService = Class.extend({
    /** 
     * @member {object} requestHeaders
     * @memberof org.ekstep.services.iService
     */
    requestHeaders: {
        "headers": {
            "content-type": "application/json",
            "user-id": "content-editor"
            
        }
    },
    getBaseURL: function() {
        return org.ekstep.services.config.baseURL;
    },
    getAPISlug: function() {
        return org.ekstep.services.config.apislug;
    },
    getConfig: function(configKey, _default) {
        return org.ekstep.services.config[configKey] || _default;
    },
    init: function(config) {
        this.initService(config);
    },
    initService: function(config) {},                
    _dispatchTelemetry: function(data) {
        var status = data.res.responseCode || data.res.statusText;
        org.ekstep.services.telemetryService.apiCall({ "path": encodeURIComponent(data.url), "method": data.method, "request": data.request, "response": "", "responseTime": data.res.responseTime, "status": status, "uip": "" });
    },
    get: function(url, config, cb) {
        var requestTimestamp, instance = this;
        config = config || {};
        config.headers = config.headers || {};
        if (typeof cb !== 'function') throw "iservice expects callback to be function";
        org.ekstep.pluginframework.jQuery.ajax({
            type: "GET",
            url: url,
            headers: config.headers,
            beforeSend: function(xhrObject, settings) {
                requestTimestamp = (new Date()).getTime();
            },
            success: function(res) {
                res.responseTime = (new Date()).getTime() - requestTimestamp;
                instance._dispatchTelemetry({url: url, method: "GET", request: "", res: res }); 
                res = { data: res };
                cb(null, res);                
            },
            error: function(err) {
                err.responseTime = (new Date()).getTime() - requestTimestamp;
                cb(err, null);
                instance._dispatchTelemetry({url: url, method: "GET", request: "", res: err });
            }
        });
    },
    post: function(url, data, config, cb) {
        var requestTimestamp, instance = this;
        data = data || {};
        config = config || {};
        config.headers = config.headers || {};
        if (typeof cb !== 'function') throw "iservice expects callback to be function";
        if (typeof data === 'object') data = JSON.stringify(data);
        org.ekstep.pluginframework.jQuery.ajax({
            type: "POST",
            url: url,
            data: data,
            headers: config.headers,
            beforeSend: function(xhrObject, settings) {
                requestTimestamp = (new Date()).getTime();
            },
            success: function(res) {
                res.responseTime = (new Date()).getTime() - requestTimestamp;
                instance._dispatchTelemetry({url: url, method: "POST", request: data, res: res }); 
                res = { data: res };
                cb(null, res);                
            },
            error: function(err) {
                err.responseTime = (new Date()).getTime() - requestTimestamp;
                cb(err, null);
                instance._dispatchTelemetry({url: url, method: "POST", request: data, res: err });
            }
        });
    },
    patch: function(url, data, config, cb) {
        var requestTimestamp, instance = this;
        data = data || {};
        config = config || {};
        config.headers = config.headers || {};
        if (typeof cb !== 'function') throw "iservice expects callback to be function";
        if (typeof data === 'object') data = JSON.stringify(data);
        org.ekstep.pluginframework.jQuery.ajax({
            type: "PATCH",
            url: url,
            data: data,
            headers: config.headers,
            beforeSend: function(xhrObject, settings) {
                requestTimestamp = (new Date()).getTime();
            },
            success: function(res) {
                res.responseTime = (new Date()).getTime() - requestTimestamp;
                instance._dispatchTelemetry({url: url, method: "PATCH", request: "", res: res });
                res = { data: res };
                cb(null, res);                
            },
            error: function(xhr, status, error) {
                xhr.responseTime = (new Date()).getTime() - requestTimestamp;
                cb(xhr, null);
                instance._dispatchTelemetry({url: url, method: "PATCH", request: "", res: xhr });
            }
        });
    },
    delete: function(url, config, cb) {
        var requestTimestamp, instance = this;
        config = config || {};
        config.headers = config.headers || {};
        if (typeof cb !== 'function') throw "iservice expects callback to be function";
        org.ekstep.pluginframework.jQuery.ajax({
            type: "DELETE",
            url: url,
            headers: config.headers,
            beforeSend: function(xhrObject, settings) {
                requestTimestamp = (new Date()).getTime();
            },
            success: function(res) {
                res.responseTime = (new Date()).getTime() - requestTimestamp;
                instance._dispatchTelemetry({url: url, method: "DELETE", request: "", res: res });
                res = { data: res };
                cb(null, res);                
            },
            error: function(xhr, status, error) {
                xhr.responseTime = (new Date()).getTime() - requestTimestamp;
                cb(xhr, null);
                instance._dispatchTelemetry({url: url, method: "DELETE", request: "", res: xhr });
            }
        });
    },
    /**
     * Utility function which is used to call http post request
     * @param  {string}   url      API url
     * @param  {object}   data     APT request data
     * @param  {object}   headers  API headers
     * @param  {Function} callback returns error and response as arguments
     * @memberof org.ekstep.services.iService
     */
    postFromService: function(url, data, headers, callback) {
        this.post(url, JSON.stringify(data), headers, function(err, res) {
            callback(err, res)
        });
    },
    /**
     * Utility function which is used to call http get request
     * @param  {string}   url      API url
     * @param  {object}   headers  API headers
     * @param  {Function} callback returns error and response as arguments
     * @memberof org.ekstep.services.iService
     */
    getFromService: function(url, headers, callback) {
        this.get(url, headers, function(err, res) {
            callback(err, res);
        });
    }

});

/**
 * Content service helps to retrieve/save the content, content meta details by making call to learning API.
 * It also helps to download the content.
 *
 * @class org.ekstep.services.contentService
 * @author Sunil A S <sunils@ilimi.in>
 */
org.ekstep.services.contentService = new(org.ekstep.services.iService.extend({
    serviceURL: function() {
        return this.getBaseURL() + this.getAPISlug() + this.getConfig('contentEndPoint', '/content');
    },
    learningURL: function() {
        return this.getBaseURL() + this.getAPISlug() + this.getConfig('learningEndPoint', '/learning');
    },
    content: {},
    initService: function() {},
    /**
     *
     * content meta data fields
     *
     * @memberof org.ekstep.services.contentService
     */
    contentFields: "body,editorState,stageIcons,templateId,languageCode,template,gradeLevel,status,concepts,versionKey,name,appIcon,contentType,owner,domain,code,visibility,createdBy,description,language,mediaType,mimeType,osId,languageCode,createdOn,lastUpdatedOn,audience,ageGroup,attributions,artifactUrl",
    /**
     *
     * sets content meta for the given content id
     * @param id {string}
     * @param contentMeta {object} content meta object
     * @private
     * @memberof org.ekstep.services.contentService
     */
    _setContentMeta: function(id, contentMeta) {
        /* istanbul ignore else */
        if (id && contentMeta) {
            var meta = {};
            for (k in contentMeta) {
                if (k != 'body' && k != 'stageIcons') {
                    meta[k] = contentMeta[k];
                }
            }
            this.content[id] = meta;
        }
    },
    /**
     *
     * returns content meta details
     * @param id {string} content id
     * @returns {object} if id is "undefined" returns empty object
     *
     * @memberof org.ekstep.services.contentService
     */
    getContentMeta: function(id) {
        return this.content[id] || {};
    },
    /**
     *
     * saves content body by making call to learing API
     * @param contentId {string} content id
     * @param metadata {object} meta data object
     * @param body {object} ECML JSON object of content
     * @param callback {function} callback function
     *
     * @memberof org.ekstep.services.contentService
     */
    saveContent: function(contentId, metadata, body, callback) {
        this._saveContent(contentId, metadata, body, callback);
    },
    /**
     *
     * saves content body by making call to learing API
     * @param contentId {string} content id
     * @param metadata {object} meta data object
     * @param body {object} ECML JSON object of content
     * @param callback {function} callback function
     * @private
     * @memberof org.ekstep.services.contentService
     *
     */
    _saveContent: function(contentId, metadata, body, callback) {

        var instance = this;
        var versionKey = instance.content[contentId] && instance.content[contentId].versionKey;

        if (contentId && versionKey) {
            var update = false;
            var content = {
                versionKey: versionKey,
                lastUpdatedBy: ecEditor.getContext('user') && ecEditor.getContext('user').id
            }
            if (metadata) {
                update = true;
                for (k in metadata) {
                    content[k] = metadata[k];
                }
            }
            if (body) {
                content.compatibilityLevel = body.theme.compatibilityVersion;
                content['body'] = JSON.stringify(body);
                update = true;
            }
            if (update) {
                var requestObj = { request: { content: content } };
                instance.patch(this.serviceURL() + this.getConfig('contentUpdateUrl', '/v3/update/') + contentId, requestObj, this.requestHeaders, function(err, res) {
                    /* istanbul ignore else */
                    if (res && res.data.responseCode == "OK") {
                        instance.content[contentId].versionKey = res.data.result.versionKey;
                        callback(undefined, res);
                    } else {
                        callback(true, err);
                    }
                });
            } else {
                callback('Nothing to save');
            }
        } else {
            callback('Cannot find content id or version key to update content');
        }
    },
    /**
     *
     *
     * retrieves the content and content meta details
     * @param contentId {string} content id
     * @param callback {function} callback function
     *
     * @memberof org.ekstep.services.contentService
     */
    getContent: function(contentId, callback) {
        var instance = this;
        if (contentId) {
            var metaDataFields = "?mode=edit&fields=" + instance.contentFields;
            instance.get(this.serviceURL() + this.getConfig('contentReadUrl', '/v3/read/') + contentId + metaDataFields, this.requestHeaders, function(err, res) {
                /* istanbul ignore else */                
                if (res && res.data && res.data.responseCode === "OK") {
                    instance._setContentMeta(contentId, res.data.result.content);
                    callback(err, res.data.result.content);
                } else {
                    callback(new Error('no content found!'), undefined)
                }

            });
        } else {
            callback('Content id is required to get content from platform', undefined);
        }
    },
    /**
     *
     *
     * retrieves the versionKey
     * @param contentId {string} content id
     * @param callback {function} callback function
     *
     * @memberof org.ekstep.services.contentService
     */
    getContentVersionKey: function(contentId, callback) {
        var instance = this;
        if (contentId) {
            var metaDataFields = "?mode=edit&fields=" + "versionKey";
            instance.get(this.serviceURL() + this.getConfig('contentReadUrl', '/v3/read/') + contentId + metaDataFields, this.requestHeaders, function(err, res) {
                if (res && res.data && res.data.responseCode === "OK") {
                    instance._setContentMeta(contentId, res.data.result.content);
                    callback(err, res.data.result.content);
                } else {
                    callback(new Error('no content found!'), undefined)
                }
            });
        } else {
            callback('Content id is required to get versionKey from platform', undefined);
        }
    },
    /**
     * retrieves template data of selected templateid
     * @param templateId {string} template id
     * @param callback {function} callback function
     * @memberof org.ekstep.services.contentService
     */
    getTemplateData: function(templateId, callback) {
        var instance = this;
        var templateMetaFields = "?taxonomyId=literacy_v2&fields=body,editorState,templateId,languageCode";
        instance.get(this.serviceURL() + this.getConfig('contentReadUrl', '/v3/read/') + templateId + templateMetaFields, this.requestHeaders, function(err, res) {
            callback(err, res)
        });
    },
    /**
     *
     *
     * retrieves downloadable URL link to content
     * @param contentId {string} content id
     * @param fileName {string} "name" parameter of meta data object
     * @param callback {function} callback function
     *
     * @memberof org.ekstep.services.contentService
     */
    downloadContent: function(contentId, fileName, callback) {
        var data = { "request": { "content_identifiers": [contentId], "file_name": fileName } };
        this.postFromService(this.serviceURL() + this.getConfig('contentBundleUrl', '/v3/bundle'), data, this.requestHeaders, callback);
    },
    /**
     *
     *
     * retrieves collection in hierarchical order
     * @param data {object} "contentId" : String. Content ID to get
     * @param callback {function} callback function
     *
     * @memberof org.ekstep.services.contentService
     */
    getCollectionHierarchy: function(data, callback) {
        var instance = this;
        var metaFields = "fields=versionKey"
        if (data.mode === "edit") metaFields = "mode=edit&" + metaFields;
        this.getFromService(this.serviceURL() + this.getConfig('collectionHierarchyGetUrl', '/v3/hierarchy/') + data.contentId + "?" + metaFields, this.requestHeaders, function(err, res) {            
            if (res && res.data && res.data.responseCode === "OK") {
                instance._setContentMeta(data.contentId, res.data.result.content);
                callback(err, res);
            } else {
                callback(new Error('no content found!'), undefined)
            }
        });
    },
    /**
     * saves collection in hierarchical order
     * @param data {object} "body": Object. content body to save
     * @param callback {function} callback function
     *
     * @memberof org.ekstep.services.contentService
     */
    saveCollectionHierarchy: function(data, callback) {
        //Versionkey not considered for hierarchy patch
        if (!data) {
            callback("nothing to save!");        
            return;
        }
        data.body.lastUpdatedBy = ecEditor.getContext('user') && ecEditor.getContext('user').id;
        var requestObj = { request: { data: data.body } };
        this.patch(this.serviceURL() + this.getConfig('collectionHierarchyUpdateUrl', '/v3/hierarchy/update/'), requestObj, this.requestHeaders, function(err, res) {
            if (res && res.data.responseCode == "OK") {
                callback(undefined, res);
            } else {
                callback(true, err);
            }
        });
    },
    /**
     * Content sent for review call
     * @param data {object} "contentId" : String. Content ID
     * @param callback {function} callback function
     * @memberof org.ekstep.services.contentService
     */
    sendForReview: function(data, callback) {
        var requestObj = {"request":{"content":{}}};
        this.postFromService(this.serviceURL() + this.getConfig('sendfortReviewURL', '/v3/review/') + data.contentId, requestObj, this.requestHeaders, callback);
    },
    /**
     * Content sent for review call
     * @param data {object} "contentId" : String. Content ID
     * @param callback {function} callback function
     * @memberof org.ekstep.services.contentService
     */
    publishContent: function(data, callback) {
        var requestObj = {
                            "request": {
                                "content" : {
                                    "lastPublishedBy" : ecEditor.getContext('uid')
                                }
                            }
                        };
        this.postFromService(this.serviceURL() + this.getConfig('contentPublishURL', '/v3/publish/') + data.contentId, requestObj, this.requestHeaders, callback);
    },
    /**
     * Content sent for review call
     * @param data {object} "contentId" : String. Content ID
     * @param callback {function} callback function
     * @memberof org.ekstep.services.contentService
     */
    rejectContent: function(data, callback) {
        var requestObj = {"request":{}};
        this.postFromService(this.serviceURL() + this.getConfig('contentRejectURL', '/v3/reject/') + data.contentId, requestObj, this.requestHeaders, callback);

    },
    retireContent: function(data, callback) {
        this.delete(this.serviceURL() + this.getConfig('contentRejectURL', '/v3/retire/') + data.contentId, this.requestHeaders, callback);
    },
    acceptContentFlag: function(data, callback) {
        var requestObj = {"request":{}};
        this.postFromService(this.serviceURL() + this.getConfig('acceptContentFlag', '/v3/flag/accept/') + data.contentId, requestObj, this.requestHeaders, callback);
    },
    discardContentFlag: function(data, callback) {
        var requestObj = {"request":{}};
        this.postFromService(this.serviceURL() + this.getConfig('discardContentFlag', '/v3/flag/reject/') + data.contentId, requestObj, this.requestHeaders, callback);
    }
}));

/**
 *
 * Assessment service helps to get questions(items)
 * @class org.ekstep.services.assessmentService
 * @author Santhosh Vasabhaktula <santhosh@ilimi.in>
 */
org.ekstep.services.assessmentService = new(org.ekstep.services.iService.extend({
    /** 
     * @member {string} learningURL
     * @memberof org.ekstep.services.assessmentService
     */
    assessmentURL: function() {
        return this.getBaseURL() + this.getAPISlug() + this.getConfig('assessmentEndPoint', '/assessment');
    },
    /**
     * Get Questions from search API
     * @param  {object}   data     search filter data
     * @param  {Function} callback returns error and response as arguments
     * @memberof org.ekstep.services.assessmentService
     */
    getQuestions: function(data, callback) {
        org.ekstep.services.searchService.search(data, callback);
    },
    /**
     * Get selected Question(assessmentitem)
     * @param  {string}   itemId   selected question(assessmentitem) id
     * @param  {Function} callback returns error and response as arguments
     * @memberof org.ekstep.services.assessmentService
     */
    getItem: function(itemId, callback) {
        this.getFromService(this.assessmentURL() + this.getConfig('itemReadUrl', '/v3/items/read/') + itemId, this.requestHeaders, callback);
    },
    /**
     * Get template data of selected question from content service API
     * @param  {string}   templateId selected question(assessmentitem) template id
     * @param  {Function} callback   returns error and response as arguments
     * @memberof org.ekstep.services.assessmentService
     */
    getTemplate: function(templateId, callback) {
        org.ekstep.services.contentService.getTemplateData(templateId, callback);
    },
    /**
     * This method is used to save question
     * @param  {string}   assessmentId
     * @param  {object}   requestObj
     * @param  {Function} callback returns error and response as arguments
     * @memberof org.ekstep.services.assessmentService
     */
    saveQuestion: function(assessmentId, requestObj, callback) {
        var instance = this;
        /*If assessment Id exists then update the question else create*/
        if (assessmentId) {
            instance.patch(this.assessmentURL() + 'assessmentitems/update/' + assessmentId, requestObj, this.requestHeaders, function(err, res) {
                callback(err, res)
            });
        } else {
            instance.post(this.assessmentURL() + 'assessmentitems/create', requestObj, this.requestHeaders, function(err, res) {
                callback(err, res)
            });
        }
    }
}));

/**
 * Asset service provides access to the content API to save assets.
 * @class org.ekstep.services.assetService
 * @author Santhosh Vasabhaktula <santhosh@ilimi.in>
 */
org.ekstep.services.assetService = new(org.ekstep.services.iService.extend({
     /** 
     * @member {string} searchURL
     * @memberof org.ekstep.services.assetService
     */
    contentURL: function() {
        return this.getBaseURL() + this.getAPISlug() + this.getConfig('contentEndPoint', '/content');
    },
    asset: {},
    initService: function() {},
    /**
     * Set asset object
     * @param {string} id        
     * @param {object} assetMeta 
     * @memberof org.ekstep.services.assetService
     */
    setAssetMeta: function(id, assetMeta) {
        if (id && assetMeta) {
            if(this.asset[id] == undefined) this.asset[id] = {};
            this.asset[id].assetMeta = assetMeta;
        }
    },
    /**
     * get asset object
     * @param  {string} id 
     * @memberof org.ekstep.services.assetService
     */
    getAssetMeta: function(id) {
        return this.asset[id] || {};
    },
    /**
     * This method is used to save assets(audio & image)
     * @param  {string}   assetId
     * @param  {string}   content
     * @param  {Function} callback returns error and response as arguments
     * @memberof org.ekstep.services.assetService
     */
    saveAsset: function(assetId, content, callback) {
        var instance = this;

        var requestObj = {
            request: {
                content: content
            }
        };
        if (assetId) {
            instance.patch(this.contentURL() + this.getConfig('contentUpdateUrl', '/v3/update/'), requestObj, this.requestHeaders, function(err, res) {
                callback(err, res)
            });
        } else {
            instance.post(this.contentURL() + this.getConfig('contentCreateUrl', '/v3/create'), requestObj, this.requestHeaders, function(err, res) {
                callback(err, res)
            });
        }
    }
}));

/**
 * Service to get meta information from platform
 * 
 * @class org.ekstep.services.metaService
 * @author Santhosh Vasabhaktula <santhosh@ilimi.in>
 */
org.ekstep.services.metaService = new(org.ekstep.services.iService.extend({
    /** 
     * @member {string} learningURL
     * @memberof org.ekstep.services.metaService
     */
    learningURL: function() {
        return this.getBaseURL() + this.getAPISlug() + this.getConfig('learningEndPoint', '/learning')
    },
    /** 
     * @member {string} learningURL
     * @memberof org.ekstep.services.metaService
     */
    metaURL: function() {
        return this.getBaseURL() + this.getAPISlug() + this.getConfig('metaEndPoint', '/meta')
    },
    /** 
     * @member {string} configURL
     * @memberof org.ekstep.services.metaService
     */
    configURL: function() {
        return this.getBaseURL() + this.getAPISlug() + this.getConfig('configEndPoint', '/domain')
    },
    /** 
     * @member {string} domainURL
     * @memberof org.ekstep.services.metaService
     */
    domainURL: function(){
        return this.getBaseURL() + this.getAPISlug() + this.getConfig('domainEndPoint', '/domain')
    },
    /**
     * Returns the schema of the specified object. The schema will contain all the properties details (name, code, datatype, identifier etc,.).
     * @param  {string}   objectType  eg.AssessmentItem, Language etc.
     * @param  {Function} callback    returns error and response as arguments
     * @memberof org.ekstep.services.metaService
     */
    getDefinitions: function(objectType, callback) {
        this.getFromService(this.learningURL() + this.getConfig('definitionsGetUrl', '/taxonomy/domain/definition/') + objectType, { "headers": { "content-type": "application/json", "user-id": "content-editor" } }, callback);
    },
    /**
     * Returns all property values in the specified language.
     * @param  {string}   languageCode  eg. en, hi etc.
     * @param  {Function} callback      returns error and response as arguments
     * @memberof org.ekstep.services.metaService
     */
    getResourceBundles: function(languageCode, callback) {
        this.getFromService(this.metaURL() + this.getConfig('resourceBundleUrl', '/v3/resourcebundles/read/') + languageCode, this.requestHeaders, callback);
    },
    /**
     * Get config items from learning api terms list
     * @param  {Function} callback returns error and response as arguments
     * @memberof org.ekstep.services.configService
     */
    getLearningConfig: function(callback) {
        this.getFromService(this.domainURL() + this.getConfig('termsListUrl', '/v3/terms/list'), this.requestHeaders, callback);
    },
    /**
     * Get config items from config api ordinals
     * @param  {Function} callback returns error and response as arguments
     * @memberof org.ekstep.services.configService
     */
    getConfigOrdinals: function(callback) {
        this.getFromService(this.metaURL() + this.getConfig('ordinalsGetUrl', '/v3/ordinals/list'), this.requestHeaders, callback);
    }
}));

/**
 * 
 * Language service helps to get languages and wordnet data.
 * @class org.ekstep.services.languageService
 * @author Santhosh Vasabhaktula <santhosh@ilimi.in>
 * 
 */
org.ekstep.services.languageService = new(org.ekstep.services.iService.extend({
    /** 
     * @member {string} learningURL
     * @memberof org.ekstep.services.languageService
     */
    learningURL: function() {
        return this.getBaseURL() + this.getAPISlug() + this.getConfig('learningEndPoint', '/learning');
    },
    /** 
     * @member {string} languageURL
     * @memberof org.ekstep.services.languageService
     */
    languageURL: function() { 
        return this.getBaseURL() + this.getAPISlug() + this.getConfig('languageEndPoint', '/language');
    },
    /** 
     * @member {object} wordHeaders
     * @memberof org.ekstep.services.languageService
     */
    wordHeaders: {
        "headers": {
            "Content-Type": "application/json",
            "Authorization": "Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiI5OGNlN2RmNmNkOTk0YWQ5YjZlYTRjNDJlNmVjYjY5MCJ9.rtr4188EwDYZywtP7S9uuv1LsivoucFxOvJFDCWvq0Y"
        }
    },
    /**
     * Get all list of languages
     * @param  {Function} callback returns error and response as arguments
     * @memberof org.ekstep.services.languageService
     */
    getLanguages: function(callback) {
        this.getFromService(this.languageURL() + this.getConfig('languageListUrl', '/v3/list'), this.requestHeaders, callback);
    },
    /**
     * Get all list of vowel available in selected language
     * @param  {string}   language eg. en, hi etc.
     * @param  {Function} callback returns error and response as arguments
     * @memberof org.ekstep.services.languageService
     */
    getVowel: function(language, callback) {
        this.getFromService(this.languageURL() + this.getConfig('vowelGetUrl', '/v3/varnas/vowels/list') + "?language_id=" + language, this.requestHeaders, callback);
    },
    /**
     * Get all list of consonant available in selected language
     * @param  {string}   language eg. en, hi etc.
     * @param  {Function} callback returns error and response as arguments
     * @memberof org.ekstep.services.languageService
     */
    getConsonant: function(language, callback) {
        this.getFromService(this.languageURL() + this.getConfig('consonantListUrl', '/v3/varnas/consonants/list') + "?language_id=" + language, this.requestHeaders, callback);
    },
    /**
     * Get all avalible words in given content
     * @param  {object}   data     request object contains filters, objectType, exists etc
     * @param  {Function} callback returns error and response as arguments
     * @memberof org.ekstep.services.languageService
     */
    getWords: function(data, callback) {
        this.postFromService(this.languageURL() + this.getConfig('wordsGetUrl', '/v3/search'), data, this.wordHeaders, callback);
    },
    /**
     * Get types of word. eg. Nouns, verbs etc 
     * @param  {Function} callback returns error and response as arguments
     * @memberof org.ekstep.services.languageService
     */
    getWordDefinition: function(callback) {
        this.getFromService(this.learningURL() + this.getConfig('word_definition_url', '/taxonomy/en/definition/Word'), this.requestHeaders, callback);
    },
    /**
     * Get all avalible keywords in given content
     * @param  {object}   data     request object
     * @param  {Function} callback returns error and response as arguments
     * @memberof org.ekstep.services.languageService
     */
    getKeyWords: function(data, callback) {
        this.postFromService(this.languageURL() + this.getConfig('keywordsGetUrl', '/v3/tools/parser'), data, this.requestHeaders, callback);
    },
    /**
    * Transliterates english text to specified language and invokes a callback
    * @param {Object} data - object containing english text and array of languages
    * @param {Function} callback - Callback when api call returns
    * @return {void}
    */
    getTransliteration: function(data, callback) {
        this.postFromService(this.languageURL() + this.getConfig('transliterateGetUrl', '/v3/tools/transliterate') + "?lemma=" + data.text + "&languages="+ data.languages.toString() , {"request": {}}, this.requestHeaders, callback);
    },
    /**
     * Translates word in provided languages
     * @param {Object} req contain requested data
     * @param {Function} callback, callback function
     */
    getTranslation:  function(data, callback) {
        this.postFromService(this.languageURL() + this.getConfig('translateGetUrl', '/v3/tools/translate') + "?language_id="+ data.wordLang + '&lemma=' + data.word + '&languages=' + data.languages, {"request": {}}, this.requestHeaders, callback);
    },
    /**
     * GetSyllables split word into letters
     * @param {Object} req contain requested data
     * @param {Function} callback, callback function
     */
    getSyllables: function(data, callback) {
        this.postFromService(this.languageURL() + '/v3/varnas/syllables/list', data, this.requestHeaders, callback);
    }
}));

/**
 * Search service provides capability to search content(activities, question etc.) from  composite search API.
 * 
 * @class org.ekstep.services.searchService
 * @author Santhosh Vasabhaktula <santhosh@ilimi.in>
 */
org.ekstep.services.searchService = new(org.ekstep.services.iService.extend({
    /** 
     * @member {string} searchURL
     * @memberof org.ekstep.services.searchService
     */
    searchURL: function() {
        return this.getBaseURL() + this.getAPISlug() + this.getConfig('compositeEndPoint', '/composite');
    },
    initService: function() {},
    /**
     * Search method helps to get the content from search API
     * @param  {object}   request  request object will take all request parameters of search API
     * @param  {Function} callback returns error and response as arguments
     * @memberof org.ekstep.services.searchService
     */
    search: function(request, callback) {
        this.postFromService(this.searchURL() + this.getConfig('searchUrl', '/v3/search'), request, this.requestHeaders, callback);
    }
}));
/**
 * @author Harish kumar Gangula<harishg@ilimi.in>
 */
org.ekstep.pluginframework.iRepo = Class.extend({
    discoverManifest: function(pluginId, pluginVer, callback) {
    	callback(undefined, undefined);
    },
    resolveResource: function(pluginId, pluginVer, resource) {}
});

/**
 * @author Harish kumar Gangula<harishg@ilimi.in>
 */
org.ekstep.pluginframework.publishedRepo = new(org.ekstep.pluginframework.iRepo.extend({
    id: "published",
    discoverManifest: function(pluginId, pluginVer, callback, publishedTime) {
        var instance = this;
        org.ekstep.pluginframework.resourceManager.loadResource(this.resolveResource(pluginId, pluginVer, "manifest.json"), "json", function(err, response) {
            callback(undefined, { "manifest": response, "repo": instance });
        }, publishedTime);
    },
    resolveResource: function(id, ver, resource) {        
    	return org.ekstep.pluginframework.config.pluginRepo + "/" + id + "-" + ver + "/" + resource;
    }
}));
org.ekstep.pluginframework.resourceManager.addRepo(org.ekstep.pluginframework.publishedRepo);
/**
 * @author Santhosh Vasabhaktula <santhosh@ilimi.in>
 */
/* istanbul ignore next. Fabric extension - cannot be tested */
if(window.fabric) {
    window.fabric.Object.prototype.toObject = (function(toObject) {
        return function() {
            return window.fabric.util.object.extend(toObject.call(this), {
                meta: this.meta
            });
        };
    })(window.fabric.Object.prototype.toObject);
}

var content_editor = function() {};
content_editor.prototype.jQuery = window.$;
content_editor.prototype._ = window._;
window.org.ekstep.contenteditor = new content_editor();
content_editor = undefined;

window.ServiceConstants = {
    SEARCH_SERVICE: "search",
    POPUP_SERVICE: "popup",
    CONTENT_SERVICE: "content",
    ASSESSMENT_SERVICE: "assessment",
    LANGUAGE_SERVICE: "language",
    META_SERVICE: "meta",
    ASSET_SERVICE: "asset",
    TELEMETRY_SERVICE: "telemetry"
}

window.ManagerConstants = {
    EVENT_MANAGER: "event",
    MEDIA_MANAGER: "media",
    PLUGIN_MANAGER: "plugin",
    RESOURCE_MANAGER: "resource",
    STAGE_MANAGER: "stage",
    TOOLBAR_MANAGER: "toolbar"
}
org.ekstep.contenteditor.config = {
    baseURL: '',
    apislug: '/action',
    build_number: 'BUILDNUMBER',
    pluginRepo: '/content-plugins',
    aws_s3_urls: ["https://s3.ap-south-1.amazonaws.com/ekstep-public-dev/", "https://ekstep-public-dev.s3-ap-south-1.amazonaws.com/"],
    plugins: [
        { "id": "org.ekstep.developer", "ver": "1.0", "type": "plugin" },
        { "id": "org.ekstep.ceheader", "ver": "1.0", "type": "plugin" },
        { "id": "org.ekstep.whatsnew", "ver": "1.0", "type": "plugin" },
        { "id": "org.ekstep.todo", "ver": "1.0", "type": "plugin" },
        { "id": "org.ekstep.review", "ver": "1.0", "type": "plugin" }
    ],
    corePluginsPackaged: true,
    dispatcher: "piwik",
    localDispatcherEndpoint: "/app/telemetry",
    previewURL: "/content/preview/preview.html"
}

org.ekstep.contenteditor.extendedConfig = {
    corePlugins: ["text", "audio", "div", "hotspot", "image", "shape", "scribble", "htext"],
    corePluginMapping: {
        "text": "org.ekstep.text", 
        "image": "org.ekstep.image", 
        "shape": "org.ekstep.shape",
        "stage": "org.ekstep.stage",
        "hotspot": "org.ekstep.hotspot",
        "scribble": "org.ekstep.scribblepad",
        "htext": "org.ekstep.text",
        "audio": "org.ekstep.audio"
    },
    useProxyForURL: false
}

org.ekstep.contenteditor.baseConfigManifest = [{
    "propertyName": "autoplay",
    "title": "Auto play",
    "description": "Set the element's playability",
    "dataType": "boolean",
    "required": true,
    "defaultValue": false
}, {
    "propertyName": "visible",
    "title": "Visible",
    "description": "Set the element's Visibility",
    "dataType": "boolean",
    "required": true,
    "defaultValue": true
}, {
    "propertyName": "stroke",
    "title": "Border Color",
    "description": "Set the border color for element",
    "dataType": "colorpicker",
    "required": true,
    "defaultValue": "rgba(255, 255, 255, 0)"
}]
/**
 * @author Santhosh Vasabhaktula <santhosh@ilimi.in>
 */

org.ekstep.contenteditor.init = function(context, config, $scope, $document, callback) {
    org.ekstep.contenteditor._mergeConfig(config);
    org.ekstep.contenteditor._initServices();
    org.ekstep.contenteditor.globalContext = context;
    org.ekstep.contenteditor.toolbarManager.setScope($scope);
    org.ekstep.contenteditor._loadDefaultPlugins(context, callback);
    //org.ekstep.contenteditor._backwardCompatibility();
}

org.ekstep.contenteditor._backwardCompatibility = function() {
    /* Deprecated variables */
    EkstepEditorAPI.apislug = org.ekstep.contenteditor.config.apislug;
    EkstepEditorAPI.baseURL = org.ekstep.contenteditor.config.baseURL;
    EkstepEditorAPI.absURL = org.ekstep.contenteditor.config.absURL;
    EkstepEditorAPI.globalContext = org.ekstep.contenteditor.globalContext;
}

org.ekstep.contenteditor._initServices = function() {
    org.ekstep.services.config = {
        baseURL: org.ekstep.contenteditor.config.baseURL,
        apislug: org.ekstep.contenteditor.config.apislug
    }
    org.ekstep.pluginframework.initialize({
        env: 'editor',
        jQuery: org.ekstep.contenteditor.jQuery,
        pluginRepo: org.ekstep.contenteditor.config.pluginRepo,
        build_number: org.ekstep.contenteditor.config.build_number
    });
}

org.ekstep.contenteditor._mergeConfig = function(config) {
    config = config || {};
    // Override default config
    org.ekstep.contenteditor.config = _.assign(org.ekstep.contenteditor.config, config);
    // Set non overridable config
    org.ekstep.contenteditor.config = _.assign(org.ekstep.contenteditor.config, org.ekstep.contenteditor.extendedConfig);
}

org.ekstep.contenteditor._loadDefaultPlugins = function(context, callback) {
    var startTime = (new Date()).getTime();
    if (org.ekstep.contenteditor.config.corePluginsPackaged === true) org.ekstep.contenteditor.jQuery("body").append($("<script type='text/javascript' src='scripts/coreplugins.js?" + org.ekstep.contenteditor.config.build_number + "'>"));
    org.ekstep.pluginframework.eventManager.enableEvents = false;
    org.ekstep.pluginframework.pluginManager.loadAllPlugins(org.ekstep.contenteditor.config.plugins, undefined, function() {

        org.ekstep.services.telemetryService.initialize({
            uid: context.uid,
            sid: context.sid,
            content_id: context.contentId,
            etags: context.etags,
            channel:context.channel || "",
            pdata: context.pdata || {}

        }, org.ekstep.contenteditor.config.dispatcher);
        org.ekstep.pluginframework.eventManager.enableEvents = true;
        callback();
        org.ekstep.services.telemetryService.startEvent().append("loadtimes", { plugins: ((new Date()).getTime() - startTime) });        
    });
}

// Prepare context and config data from url/parentwindow/window
// org.ekstep.contenteditor.window_context = {}
// org.ekstep.contenteditor.window_config = {}
// getWindowContext();
// getWindowConfig();
// 
org.ekstep.contenteditor.getWindowContext = function() {
    return org.ekstep.contenteditor.getParameterByName('context') || (window.parent ? window.parent.context : undefined) || window.context || {};
}

org.ekstep.contenteditor.getWindowConfig = function() {
    return org.ekstep.contenteditor.getParameterByName('config') || (window.parent ? window.parent.config : undefined) || window.config || {};
}

org.ekstep.contenteditor.getParameterByName = function(name, url) {
    if (!url) url = window.location.href;
    name = name.replace(/[\[\]]/g, "\\$&");
    var regex = new RegExp("[?&]" + name + "(=([^&#]*)|&|#|$)"),
        results = regex.exec(url);
    if (!results) return undefined;
    if (!results[2]) return undefined;
    var value = decodeURIComponent(results[2].replace(/\+/g, " "));
    return JSON.parse(value);
}

/**
 * The Content Editor API is the core interface of the plugins with the rest of the editor framework. It allows the plugins
 * to access the framework resources, launch popups, and handle events raised by the framework. Plugins should not call any
 * other framework classes directly.
 * 
 * @class org.ekstep.contenteditor.api
 * @author Santhosh Vasabhaktula <santhosh@ilimi.in>
 */
window.org.ekstep.contenteditor.api = {
    /**
     * Handle for JQuery. All plugins should use this instead of using '$' directly
     * 
     * @member {Object} jQuery
     * @memberof org.ekstep.contenteditor.api
     */
    jQuery: org.ekstep.contenteditor.jQuery,

    /**
     * Handle for Lodash Library. All plugins should use this instead of using '_' directly
     * 
     * @member {Object} _
     * @memberof org.ekstep.contenteditor.api
     */
    _: org.ekstep.contenteditor._,

    /**
     * Add an object to the context
     * 
     * @param {String} key   Key
     * @param {Object} value Value
     * @memberof org.ekstep.contenteditor.api
     */
    setContext: function(key, value) {
        org.ekstep.contenteditor.globalContext[key] = value;
    },

    /**
     * Get the context variable
     * 
     * @param  {String} key Key
     * @return {object}     Value
     * @memberof org.ekstep.contenteditor.api
     */
    getContext: function(key) {
        return org.ekstep.contenteditor.globalContext[key];
    },

    /**
     * Get all context attributes
     * @return {map} Map of key values
     */
    getAllContext: function() {
        return org.ekstep.contenteditor.globalContext;
    },

    /**
     * Add or update a configuration property
     * 
     * @param {String} key   Key
     * @param {Object} value Value
     * @memberof org.ekstep.contenteditor.api
     */
    setConfig: function(key, value) {
        org.ekstep.contenteditor.config[key] = value;
    },

    /**
     * Get the config variable
     * 
     * @param  {String} key Key
     * @return {object}     Value
     * @memberof org.ekstep.contenteditor.api
     */
    getConfig: function(key) {
        return org.ekstep.contenteditor.config[key];
    },

    /**
     * Get all config attributes
     * @return {map} Map of key values
     */
    getAllConfig: function() {
        return org.ekstep.contenteditor.config;
    },

    /**
     * Register an event listener callback function for the events raised by the framework.
     * @param type {string} name of the event (e.g. org.ekstep.quickstart:configure)
     * @param callback {function} callback function
     * @param scope {object} the scope of the callback (use this)
     * @memberof org.ekstep.contenteditor.api
     */
    addEventListener: function(type, callback, scope) {
        org.ekstep.pluginframework.eventManager.addEventListener(type, callback, scope);
    },

    /**
     * Fires an event to the framework, allowing other plugins who may have registered to receive the callback notification. All
     * communication between the framework and other plugins is via the events.
     * @param type {string} name of the event to fire (e.g. org.ekstep.quickstart:configure)
     * @param data {object} event data to carry along with the notification
     * @param target {object} the scope of the event (use this)
     * @memberof org.ekstep.contenteditor.api
     */
    dispatchEvent: function(type, data, target) {
        org.ekstep.pluginframework.eventManager.dispatchEvent(type, data, target);
    },

    /**
     * Remove an event listener to an event. Plugins should cleanup when they are removed.
     * @param type {string} name of the event registered with (e.g. org.ekstep.quickstart:configure)
     * @param callback {function} remove the callback function
     * @param scope {object} the scope of the event (use this)
     * @memberof org.ekstep.contenteditor.api
     */
    removeEventListener: function(type, callback, scope) {
        org.ekstep.pluginframework.eventManager.removeEventListener(type, callback, scope);
    },

    /**
     * Framework support to load plugin resources. When the resources are loaded, the callback is fired.
     * @param pluginId {string} id of the plugin requesting resource to be loaded
     * @param pluginVer {string} version of the plugin that is requesting the resource to be loaded
     * @param src {string} URL of the resource to be loaded
     * @param dataType {object} dataType of the resource (image, or audio)
     * @param callback {function} callback function whent he resource is available
     * @memberof org.ekstep.contenteditor.api
     */
    loadPluginResource: function(pluginId, pluginVer, src, dataType, callback) {
        org.ekstep.pluginframework.pluginManager.loadPluginResource(pluginId, pluginVer, src, dataType, callback);
    },

    /**
     * Returns the handle to the Angular services. The services can be used by plugisn to achieve
     * the functional calls or render custom views. Valid services are:
     *     popup - UI service to render popup
     *     content - Provides access to the content API (for loading templates and assets)
     *     assessment - Provides access to the assessment API (for loading questions)
     *     language - Provides access to the wordnet API (for loading words and aksharas)
     *     search - Provides access to search API (for search activities, question, domains)
     *     meta - Provides access to metadata API (for resource bundles, ordinals, definitions)
     *     asset - Provides access to the content API (for save assets)
     *     telemetry - Service to genarate and log telemetry events
     * @param serviceId {string} id of the service to return. Returns undefined if the id is invalid
     * @memberof org.ekstep.contenteditor.api
     */
    getService: function(serviceId) {
        var service = '';
        switch (serviceId) {
            case ServiceConstants.POPUP_SERVICE:
                service = org.ekstep.services.popupService;
                break;
            case ServiceConstants.CONTENT_SERVICE:
                service = org.ekstep.services.contentService;
                break;
            case ServiceConstants.ASSESSMENT_SERVICE:
                service = org.ekstep.services.assessmentService;
                break;
            case ServiceConstants.LANGUAGE_SERVICE:
                service = org.ekstep.services.languageService;
                break;
            case ServiceConstants.SEARCH_SERVICE:
                service = org.ekstep.services.searchService;
                break;
            case ServiceConstants.META_SERVICE:
                service = org.ekstep.services.metaService;
                break;
            case ServiceConstants.ASSET_SERVICE:
                service = org.ekstep.services.assetService;
                break;
            case ServiceConstants.TELEMETRY_SERVICE:
                service = org.ekstep.services.telemetryService;
                break;
        }
        return service;
    },

    /**
     * Returns the angular scope object for the plugins that need angular framework to render. The editor
     * uses Angular 2 and plugins must use this to access the scope instead of instantiating Angular by
     * themselves.
     * @memberof org.ekstep.contenteditor.api
     */
    getAngularScope: function() {
        return org.ekstep.contenteditor.toolbarManager.scope;
    },

    /**
     * Returns the HTML5 canvas for rendering on the editor. By default, the editor uses Fabric.js and recommends
     * the plugins to also use Fabric.js for rendering the WYSIWYG components on the editor canvas. However,
     * this method provides access to the underlying native HTML5 canvas if needed. For example, if your plugin
     * uses some other third-party graphics library for rendering.
     * @memberof org.ekstep.contenteditor.api
     */
    getCanvas: function() {
        return org.ekstep.contenteditor.stageManager.canvas;
    },

    /**
     * Retrns the current stage object to the plugin. Plugins might use this to query other objects on the
     * canvas or access other stage context.
     * @memberof org.ekstep.contenteditor.api
     */
    getCurrentStage: function() {
        return org.ekstep.contenteditor.stageManager.currentStage;
    },

    /**
     * Retrns the specified stage to the plugin. This can be used to build scenarios where a plugin might be
     * linking multiple stages together (e.g. when building navigation plugins).
     * @memberof org.ekstep.contenteditor.api
     */
    getStage: function(stageId) {
        return org.ekstep.contenteditor.stageManager.getStage(stageId);
    },

    /**
     * Refreshes the rendering of stages - plugins can request the stages to be refreshed if any change
     * has been made.
     * @memberof org.ekstep.contenteditor.api
     */
    refreshStages: function() {
        /* istanbul ignore next */
        org.ekstep.contenteditor.api.ngSafeApply(org.ekstep.contenteditor.api.getAngularScope(), function() { org.ekstep.contenteditor.toolbarManager.scope.stages = org.ekstep.contenteditor.stageManager.stages; });
    },

    /**
     * Returns the currently selected active object on the canvas. This can be used by plugins to provide
     * contextual support - e.g. show words for a given text object when the text is selected.
     * @memberof org.ekstep.contenteditor.api
     */
    getCurrentObject: function() {
        var activeObj = org.ekstep.contenteditor.stageManager.canvas.getActiveObject();
        if (!activeObj) return false;
        var pluginId = activeObj.id;
        return org.ekstep.contenteditor.api.getPluginInstance(pluginId);
    },

    /**
     * Returns the current group of selected objects. This is possible when a user does multi-select by
     * clicking on multiple objects or by panning on the canvas.
     * @memberof org.ekstep.contenteditor.api
     */
    getCurrentGroup: function() {
        if(org.ekstep.contenteditor.stageManager.canvas.getActiveGroup()){
        var plugins = org.ekstep.contenteditor.stageManager.canvas.getActiveGroup()._objects;
        var group = [];
        _.forEach(plugins, function(plugins, index) {
            var obj = org.ekstep.contenteditor.api.getPluginInstance(plugins.id);
            group.push(obj);
        });
        return group;
        }
    },

    /**
     * Retrns the current group on the fabric canvas. This provides access to the fabric object. If you
     * want to access the plugin instance that is currently selected, use getCurrentGroup() instead.
     * @memberof org.ekstep.contenteditor.api
     */
    getEditorGroup: function() {
        var group = org.ekstep.contenteditor.stageManager.canvas.getActiveGroup();
        return group;
    },

    /**
     * Retrns the current object on the fabric canvas. This provides access to the fabric object. If you
     * want to access the plugin instance that is currently selected, use getCurrentObject() instead.
     * @memberof org.ekstep.contenteditor.api
     */
    getEditorObject: function() {
        return org.ekstep.contenteditor.stageManager.canvas.getActiveObject();
    },

    /**
     * Notifies the framework to render the canvas once again. This can be done by the plugin when
     * its config or state is modified via the config views.
     * @memberof org.ekstep.contenteditor.api
     */
    render: function() {
        org.ekstep.contenteditor.stageManager.canvas.renderAll();
    },

    /**
     * Returns a plugin instance for the given plugin ID. Plugins can use this work with dependencies
     * or build plugins that enhance the behavior of other plugins.
     * @memberof org.ekstep.contenteditor.api
     */
    getPluginInstance: function(pluginId) {
        return org.ekstep.pluginframework.pluginManager.getPluginInstance(pluginId);
    },

    /**
     * Allows the plugins to request an update to the context menu when one or more objects are selected.
     * This can be used by a plugin to add more actions to the context menu - e.g. when a text is selected,
     * a word parser plugin can add context menu for spell check, or for adding word definition popups.
     * @param menu {object} Menu item to add - see the manifest for the structre of the menu item
     * @memberof org.ekstep.contenteditor.api
     */
    updateContextMenu: function(menu) {
        org.ekstep.contenteditor.toolbarManager.updateContextMenu([menu]);
    },

    /**
     * Allows the plugins to request an update to the context menu by supplying multiple menu items.
     * This can be used by a plugin to add more actions to the context menu - e.g. when a text is selected,
     * a word parser plugin can add context menu for spell check, or for adding word definition popups.
     * @param menu {array} Array of menu items to add - see the manifest for the structre of the menu item
     * @memberof org.ekstep.contenteditor.api
     */
    updateContextMenus: function(menus) {
        org.ekstep.contenteditor.toolbarManager.updateContextMenu(menus);
    },
    updateSidebarMenu: function(menu) {
        org.ekstep.contenteditor.sidebarManager.updateSidebarMenu(menu);        
    },
    /**
     * Allows the plugins to request loading and instantiating another plugin. This is useful when
     * a plugin depends upon other plugins - e.g. a wordpicker might dependend upon an asset picker.
     * @param id {string} Fully qualified plugin id to load and instantiate
     * @param data {object} Data to be passed during instantiation (initial state)
     * @param parent {object} Parent scope - use this
     * @param override {object} Any function overrides - e.g. you can override the handlers of the plugin
     * @see org.ekstep.composite-text-image-shape plugin for a sample of leveraging this.
     * @memberof org.ekstep.contenteditor.api
     */
    instantiatePlugin: function(id, data, parent, override) {
        return org.ekstep.pluginframework.pluginManager.invoke(id, data, parent, override);
    },

    /**
     * Plugins can instantiate a stage and add it to the content. This can be done by special plugins that
     * work at a stage level or cause multiple stages to be added based on the configuration.
     * @param stage {object} Stage to add to the content
     * @memberof org.ekstep.contenteditor.api
     */
    addStage: function(stage) {
        org.ekstep.contenteditor.stageManager.addStage(stage);
    },

    /**
     * Lookup for another plugin in the current plugin manager scope.
     * @param id {string} Plugin id to return. Undefined if the plugin has not been loaded.
     * @memberof org.ekstep.contenteditor.api
     */
    getPlugin: function(id) {
        return org.ekstep.pluginframework.pluginManager.plugins[id];
    },

    /**
     * Adds a plugin instance to the manager. This may be used when a plugin instantiates other plugins. The
     * newly instantiated plugins are added to the framework's registry, making them discoverable by others.
     * Useful for scenarios where plugins depend on others, or composite plugins.
     * @param pluginInstance {object} Plugin object instantiated by this plugin.
     * @memberof org.ekstep.contenteditor.api
     */
    addPluginInstance: function(pluginInstance) {
        org.ekstep.pluginframework.pluginManager.addPluginInstance(pluginInstance);
    },

    /**
     * Removes a plugin instance from the manager. Do this only if you instantiated the plugin using addPluginInstance()
     * @param pluginInstance {object} Plugin object instantiated by this plugin.
     * @memberof org.ekstep.contenteditor.api
     */
    removePluginInstance: function(pluginInstance) {
        org.ekstep.pluginframework.pluginManager.removePluginInstance(pluginInstance);
    },

    /**
     * Creates a deep copy of the given plugin object with an offset x and y position. This is useful when
     * you are building plugins that enable copy paste type functionality for example.
     * @param pluginInstance {object} Plugin object instantiated by this plugin.
     * @memberof org.ekstep.contenteditor.api
     */
    cloneInstance: function(plugin) {
        var data = plugin.getCopy();
        data = _.omit(data, ["id", "event"]);
        if (plugin.parent.id == org.ekstep.contenteditor.api.getCurrentStage().id) {
            data.x = data.x + 2;
            data.y = data.y + 2;
        }
        org.ekstep.contenteditor.api.instantiatePlugin(plugin.manifest.id, data, org.ekstep.contenteditor.api.getCurrentStage());
    },

    /**
     * Returns all stages in the current document. This could be useful when plugins work across stages
     * such as timers that work across stages or page number plugins. Using this, a plugin can get access to all
     * stages, and instantiate plugins on each stage.
     * @memberof org.ekstep.contenteditor.api
     */
    getAllStages: function() {
        return org.ekstep.contenteditor.stageManager.stages;
    },

    /**
     * Selector for plugins of a given type in the document. This can be used by plugins to discover other
     * instances of the same plugin, or other plugins that are compatible with this plugin. E.g. a wordnet
     * plugin might use this to discover all other text plugins in the content.
     * 
     * @param  {String} stage        Stage ID
     * @param  {Array} includeTypes Include plugins
     * @param  {Array} excludeTypes Exclude plugins
     * @param  {Array} excludeIds   Exclude specific plugin instances
     * @return {Array}              Array of plugin instances matching the given criteria
     * @memberof org.ekstep.contenteditor.api
     */
    getStagePluginInstances: function(stage, includeTypes, excludeTypes, excludeIds) {
        // TODO: Add logic to check if stage exists
        var instances = _.clone(org.ekstep.contenteditor.api.getStage(stage).children);
        if (includeTypes) {
            instances = _.filter(instances, function(obj) {
                return includeTypes.indexOf(obj.manifest.id) != -1;
            });
        }
        if (excludeTypes) {
            instances = _.filter(instances, function(obj) {
                return excludeTypes.indexOf(obj.manifest.id) == -1;
            });
        }
        if (excludeIds) {
            instances = _.filter(instances, function(obj) {
                return excludeIds.indexOf(obj.id) == -1;
            });
        }
        return instances;
    },

    /**
     * Get matching plugin instances. This function returns instances across all stages matching the given criteria
     * 
     * @param  {Array} includeTypes Include plugins
     * @param  {Array} excludeTypes Exclude plugins
     * @param  {Array} excludeIds   Exclude specific plugin instances
     * @return {Array}              Array of plugin instances matching the given criteria
     * @memberof org.ekstep.contenteditor.api
     */
    getPluginInstances: function(includeTypes, excludeTypes, excludeIds) {
        var instances = _.clone(org.ekstep.pluginframework.pluginManager.pluginInstances);
        if (includeTypes) {
            instances = _.filter(instances, function(obj) {
                return includeTypes.indexOf(obj.manifest.id) != -1;
            });
        }
        if (excludeTypes) {
            instances = _.filter(instances, function(obj) {
                return excludeTypes.indexOf(obj.manifest.id) == -1;
            });
        }
        if (excludeIds) {
            instances = _.filter(instances, function(obj) {
                return excludeIds.indexOf(obj.id) == -1;
            });
        }
        return instances;
    },

    /**
     * Allows plugins to load a media object that they may depend upon.
     * @param assetId {string} ID of the media asset to load
     * @memberof org.ekstep.contenteditor.api
     */
    getMedia: function(assetId) {
        return org.ekstep.contenteditor.mediaManager.getMedia(assetId);
    },

    /**
     * Get the media asset's reverse proxy URL
     * @param  {String} url Fully qualified URL
     * @return {String}     Reverse proxied URL
     * @memberof org.ekstep.contenteditor.api
     */
    getMediaReverseProxyURL: function(url) {
        return org.ekstep.contenteditor.mediaManager.getMediaOriginURL(url);
    },

    /**
     * API to load a plugin dynamically. Any plugin to be loaded should be ideally declared as dependency in the manifest.
     * 
     * @param  {String} pluginId      Plugin ID
     * @param  {String} pluginVersion Plugin Version
     * @memberof org.ekstep.contenteditor.api
     */
    loadPlugin: function(pluginId, pluginVersion, callback) {
        org.ekstep.pluginframework.pluginManager.loadPluginWithDependencies(pluginId, pluginVersion, "plugin", undefined, [], callback);
    },

    /**
     * Utility API to update the plugin dimenstions once any action like - move, resize etc are performed
     * 
     * @param  {Object} inst Plugin Instance
     * @memberof org.ekstep.contenteditor.api
     */
    updatePluginDimensions: function(inst) {
        inst.attributes.x = inst.editorObj.getLeft();
        inst.attributes.y = inst.editorObj.getTop();
        inst.attributes.w = inst.editorObj.getWidth() - inst.editorObj.getStrokeWidth();
        inst.attributes.h = inst.editorObj.getHeight() - inst.editorObj.getStrokeWidth();
        inst.attributes.rotate = inst.editorObj.getAngle();
        if (_.isFunction(inst.editorObj.getRx))
            inst.attributes.r = inst.editorObj.getRx();
    },
    ngSafeApply: function(scope, fn) {
        if (scope) scope.$safeApply(fn);
    },
    /**
     * API to load and initialize a plugin to the current stage
     * 
     * @param  {String} pluginId      Plugin ID
     * @param  {String} pluginVersion Plugin Version
     * @param  {Long} publishedTime   Plugin published timestamp (for cache busting)
     * @param {Class} parent          Parent for the plugin
     * @memberof org.ekstep.contenteditor.api
     */
    loadAndInitPlugin: function(pluginId, pluginVersion, publishedTime, parent) {
        parent = parent || this.getCurrentStage();
        org.ekstep.pluginframework.pluginManager.loadAndInitPlugin(pluginId, pluginVersion, publishedTime, parent);
    },

    /**
     * API to Resolve plugin resource URL. This API would resolve to the repo the plugin is loaded from.
     * 
     * @param  {String} pluginId      Plugin ID
     * @param  {String} pluginVersion Plugin Version
     * @param  {String} resource resource relative URL
     * @return {String}          Resolved URL
     * @memberof org.ekstep.contenteditor.api
     */
    resolvePluginResource: function (id, ver, resource) {
         return org.ekstep.pluginframework.pluginManager.resolvePluginResource(id, ver, resource);
    },

    /**
     * API to register for a keyboard command
     * 
     * @param  {String}   command  Key combination. For ex: ctrl+s, ctrl+c etc
     * @param  {Function} callback Callback to invoke when the key is pressed
     * @memberof org.ekstep.contenteditor.api
     */
    registerKeyboardCommand: function(command, callback) {
        org.ekstep.pluginframework.keyboardManager.registerKeyCombination(command, callback);
    },
    addResourceRepository: function(repo, position) {
        if (repo) org.ekstep.pluginframework.resourceManager.addRepo(repo, position);
    },
    showSidebarMenu: function(sidebarMenuId) {
        org.ekstep.contenteditor.sidebarManager.showSidebarMenu(sidebarMenuId)
    },
    getCurrentSidebarMenu: function() {
        return org.ekstep.contenteditor.sidebarManager.getCurrentMenu();
    }     
}

window.ecEditor = window.org.ekstep.contenteditor.api;
/**
 * The base plugin class that all editor plugins inherit from. It provides the common support contract for all plugins.
 * Plugins can override specific methods to change the behavior. The most common scenario would be to override the
 * implementation of fabric callback methods to detect interactivity on the canvas.
 *
 * @class org.ekstep.contenteditor.basePlugin
 * @author Santhosh Vasabhaktula <santhosh@ilimi.in>
 */
org.ekstep.contenteditor.basePlugin = Class.extend({
    id: undefined,
    parent: undefined,
    children: [],
    manifest: undefined,
    editorObj: undefined,
    editorData: undefined,
    data: undefined,
    attributes: { x: 0, y: 0, w: 0, h: 0, visible: true, editable: true },
    config: undefined,
    event: undefined,
    events: undefined,
    params: undefined,
    media: undefined,
    configManifest: undefined,

    /**
     * Initializes the plugin with the given manifest and parent object
     * @param manifest {object} Manifest details for this plugin
     * @param data {object} Init parameters for the plugin
     * @param parent {object} Parent plugin object that instantiated this
     * @constructor
     * @memberof org.ekstep.contenteditor.basePlugin
     */
    init: function(manifest, data, parent) {
        var instance = this;
        this.manifest = _.cloneDeep(manifest);
        if (arguments.length == 1) {
            this.registerMenu();
            this.initialize();
            org.ekstep.contenteditor.api.addEventListener(this.manifest.id + ":create", this.create, this);
            console.log(manifest.id + " plugin initialized");
        } else {
            this.editorObj = undefined, this.event = undefined, this.attributes = { x: 0, y: 0, w: 0, h: 0, visible: true }, this.params = undefined, this.data = undefined, this.media = undefined;
            this.editorData = data || {};
            this.children = [];
            this.id = this.editorData.id || UUID();
            this.parent = parent;
            this.config = { opacity: 100, strokeWidth: 1, stroke: "rgba(255, 255, 255, 0)", autoplay: false, visible: true };
        }
        this.configManifest = _.clone(org.ekstep.contenteditor.baseConfigManifest, true);
    },

    /**
     * Initializes the plugin by reading from ECML.
     * @private
     * @memberof org.ekstep.contenteditor.basePlugin
     */
    initPlugin: function() {
        this.fromECML(this.editorData);
        this.newInstance();
        this.postInit();
    },

    /**
     * Post init tasks for the plugin
     * @private
     * @memberof org.ekstep.contenteditor.basePlugin
     */
    postInit: function() {
        this.registerFabricEvents();
        if (this.editorObj) { this.editorObj.set({ id: this.id }); this.editorObj.setVisible(true); }
        if(_.has(this.manifest.editor, 'behaviour')) {
            if(!_.isUndefined(this.manifest.editor.behaviour.rotatable) && (this.manifest.editor.behaviour.rotatable === true)) {
                if (this.editorObj) { this.editorObj.hasRotatingPoint = true; }
            }
        }
        if (this.parent) this.parent.addChild(this);
        if (this.parent && this.parent.type !== 'stage') org.ekstep.contenteditor.api.dispatchEvent('object:modified', { id: this.id });
    },

    /**
     * Registers the menu for this plugin. By default, the base plugin handles the menu additions.
     * Child implementations can use this method to override and register additional menu items.
     * @memberof org.ekstep.contenteditor.basePlugin
     */
    registerMenu: function() {
        var instance = this;
        this.manifest.editor.menu = this.manifest.editor.menu || [];
        this.manifest.editor.sidebarMenu = this.manifest.editor.sidebarMenu || [];
        _.forEach(this.manifest.editor.menu, function(menu) {
            menu.iconImage = menu.iconImage ? instance.relativeURL(menu.iconImage) : menu.iconImage;
            if (menu.submenu) {
                _.forEach(menu.submenu, function(dd) {
                    dd.iconImage = dd.iconImage ? instance.relativeURL(dd.iconImage) : dd.iconImage;
                });
            }
            if (menu.category === 'main') {
                org.ekstep.contenteditor.toolbarManager.registerMenu(menu, instance.manifest);
            } else if (menu.category === 'context') {
                org.ekstep.contenteditor.toolbarManager.registerContextMenu(menu);
            }
        });

        _.forEach(instance.manifest.editor.sidebarMenu, function(sidebarMenu) {
            org.ekstep.contenteditor.sidebarManager.registerSidebarMenu(sidebarMenu, instance.manifest);
        });

        org.ekstep.contenteditor.sidebarManager.loadCustomTemplate(instance.manifest.id);

        _.forEach(instance.manifest.editor.header, function(header) {
            org.ekstep.contenteditor.headerManager.register(header, instance.manifest);
        });
    },

    /**
     * Returns relative URL for a particular asset. Plugins should use this method instead of
     * hard-coding the asset URLs.
     * @memberof org.ekstep.contenteditor.basePlugin
     */
    relativeURL: function(src) {
        return org.ekstep.contenteditor.api.resolvePluginResource(this.manifest.id, this.manifest.ver, src);
    },

    /**
     * Returns the type of this plugin (manifest ID)
     * @memberof org.ekstep.contenteditor.basePlugin
     */
    getType: function() {
        return this.manifest.id;
    },

    /**
     * Returns the version of this plugin (manifest ID)
     * @memberof org.ekstep.contenteditor.basePlugin
     */
    getVersion: function() {
        return this.manifest.ver;
    },

    /**
     * Registers listeners for Fabricjs events from the canvas. Child implementations should override
     * the actual callback methods instead of overriding this one.
     * @private
     * @memberof org.ekstep.contenteditor.basePlugin
     */
    registerFabricEvents: function() {
        if (this.editorObj) {
            this.editorObj.on({
                added: function(options, event) {
                    var inst = org.ekstep.contenteditor.api.getPluginInstance(this.id);
                    inst.added(inst, options, event);
                    if (inst.editorObj) {
                        org.ekstep.contenteditor.api.updatePluginDimensions(inst);
                    }
                },
                removed: function(options, event) {
                    var inst = org.ekstep.contenteditor.api.getPluginInstance(this.id);
                    inst.removed(inst, options, event);
                    _.forEach(inst.children, function(child, index) {
                        child.editorObj.remove();
                    });
                    inst.remove();
                },
                selected: function(options, event) {
                    var inst = org.ekstep.contenteditor.api.getPluginInstance(this.id);
                    inst.selected(inst, options, event)
                },
                deselected: function(options, event) {
                    var inst = org.ekstep.contenteditor.api.getPluginInstance(this.id);
                    inst.deselected(inst, options, event)
                },
                modified: function(options, event) {
                    var inst = org.ekstep.contenteditor.api.getPluginInstance(this.id);
                    /* istanbul ignore else. This cannot be reached */
                    if (inst.editorObj) {
                        org.ekstep.contenteditor.api.updatePluginDimensions(inst);
                    }
                    inst.changed(inst, options, event)
                },
                rotating: function(options, event) {
                    var inst = org.ekstep.contenteditor.api.getPluginInstance(this.id);
                    inst.rotating(inst, options, event)
                },
                scaling: function(options, event) {
                    var inst = org.ekstep.contenteditor.api.getPluginInstance(this.id);
                    inst.scaling(inst, options, event);
                },
                moving: function(options, event) {
                    var inst = org.ekstep.contenteditor.api.getPluginInstance(this.id);
                    inst.moving(inst, options, event)
                },
                skewing: function(options, event) {
                    var inst = org.ekstep.contenteditor.api.getPluginInstance(this.id);
                    inst.skewing(inst, options, event)
                }
            });
        }
    },

    /**
     * Helper method to load a given resource relative to the plugin.
     * @memberof org.ekstep.contenteditor.basePlugin
     */
    loadResource: function(src, dataType, cb) {
        org.ekstep.contenteditor.api.loadPluginResource(this.manifest.id, this.manifest.ver, src, dataType, cb);
    },

    /**
     * Removes the plugin from the stage. This can be used to perform self cleanup. If this method is called
     * from newInstance(), plugin won't be added to stage children.
     * @memberof org.ekstep.contenteditor.basePlugin
     */
    remove: function() {
        if (this.parent) {
            this.parent.removeChild(this);
            this.parent =  undefined; // if this method is called from newInstance(), plugin won't be added to stage children    
        }
        delete org.ekstep.pluginframework.pluginManager.pluginInstances[this.id];
    },

    /**
     * Creates the instance of the plugin when a new object is added to the canvas.
     * @private
     * @memberof org.ekstep.contenteditor.basePlugin
     */
    create: function(event, data) {
        org.ekstep.contenteditor.api.instantiatePlugin(this.manifest.id, _.clone(data), org.ekstep.contenteditor.stageManager.currentStage);
    },

    /**
     * Adds a child to this object. This can be useful for composite scenarios.
     * @memberof org.ekstep.contenteditor.basePlugin
     */
    addChild: function(plugin) {
        this.children.push(plugin);
    },

    /**
     * Removes a child from this plugin. Use this to dynamically manage composite children.
     * @memberof org.ekstep.contenteditor.basePlugin
     */
    removeChild: function(plugin) {
        this.children = _.reject(this.children, { id: plugin.id });
    },

    /**
     * Initialize the plugin when it is loaded. This is a no-op implementation and child classes must
     * provide the complete functional implementation.
     * @memberof org.ekstep.contenteditor.basePlugin
     */
    /* istanbul ignore next */initialize: function(data) {},

    /**
     * Instantiate an object of the plugin type. This is a no-op implementation and child classes must
     * provide the complete functional implementation.
     * @memberof org.ekstep.contenteditor.basePlugin
     */
    /* istanbul ignore next */newInstance: function(data) {},

    /**
     * Called when the plugin is added to the canvas. This is a no-op implementation and child classes must
     * provide the complete functional implementation.
     * @memberof org.ekstep.contenteditor.basePlugin
     */
    added: function(instance, options, event) {},

    /**
     * Called when the plugin is removed from the canvas. This is a no-op implementation and child classes must
     * provide the complete functional implementation.
     * @memberof org.ekstep.contenteditor.basePlugin
     */
    removed: function(instance, options, event) {},

    /**
     * Called when the object is selected on the canvas. This is a no-op implementation and child classes must
     * provide the complete functional implementation.
     * @memberof org.ekstep.contenteditor.basePlugin
     */
    selected: function(instance, options, event) {},

    /**
     * Called when the object loses focus on the canvas. This is a no-op implementation and child classes must
     * provide the complete functional implementation.
     * @memberof org.ekstep.contenteditor.basePlugin
     */
    deselected: function(instance, options, event) {},

    /**
     * Called when the object is modified (dragged, resized or rotated). This is a no-op implementation and child classes must
     * provide the complete functional implementation.
     * @memberof org.ekstep.contenteditor.basePlugin
     */
    changed: function(instance, options, event) {},

    /**
     * Called continuously while the object is rotating. This is a no-op implementation and child classes must
     * provide the complete functional implementation.
     * @memberof org.ekstep.contenteditor.basePlugin
     */
    rotating: function(instance, options, event) {},

    /**
     * Called continuously while the object is scaling. This is a no-op implementation and child classes must
     * provide the complete functional implementation.
     * @memberof org.ekstep.contenteditor.basePlugin
     */
    scaling: function(instance, options, event) {},

    /**
     * Called continuously while the object is being dragged. This is a no-op implementation and child classes must
     * provide the complete functional implementation.
     * @memberof org.ekstep.contenteditor.basePlugin
     */
    moving: function(instance, options, event) {},

    /**
     * Called continuously while the object is being skewed. This is a no-op implementation and child classes must
     * provide the complete functional implementation.
     * @memberof org.ekstep.contenteditor.basePlugin
     */
    skewing: function(instance, options, event) {},

    /**
     * Allows plugins to create a copy of the object. Default implementation just creates a clone. Child
     * classes can override the logic to customize how copy is done.
     * @memberof org.ekstep.contenteditor.basePlugin
     */
    doCopy: function() {
        return this.editorObj;
    },

    /**
     * Returns a copy of the object by converting it to ECML markup.
     * @private
     * @memberof org.ekstep.contenteditor.basePlugin
     */
    getCopy: function() {
        return this.toECML();
    },

    /**
     * Renders the plugin to canvas. Default implementation adds the editor fabric object to canvas.
     * Complex plugins and templates should override this if necessary.
     * @memberof org.ekstep.contenteditor.basePlugin
     */
    render: function(canvas) {
        if (this.editorObj) canvas.add(this.editorObj);
    },

    /**
     * Returns the metadata of the object. This is a no-op implementation. Child plugins should override
     * this method to return custom metadata.
     * @memberof org.ekstep.contenteditor.basePlugin
     */    
    /* istanbul ignore next */
    getMeta: function() {},

    /**
     * Utility method to convert canvas pixels to relative units. By design, all rendering must work with
     * relative units to allow content to be rendered on different types of devices with different pixel
     * ratios and density. Plugins must always use the relative units for rendering.
     * @memberof org.ekstep.contenteditor.basePlugin
     */
    pixelToPercent: function(obj) {
        obj.x = parseFloat(((obj.x / 720) * 100).toFixed(2));
        obj.y = parseFloat(((obj.y / 405) * 100).toFixed(2));
        obj.w = parseFloat(((obj.w / 720) * 100).toFixed(2));
        obj.h = parseFloat(((obj.h / 405) * 100).toFixed(2));
        obj.rotate = parseFloat(obj.rotate);
    },

    /**
     * Utility method to convert relative units to pixels on canvas. By design, all rendering must work with
     * relative units to allow content to be rendered on different types of devices with different pixel
     * ratios and density. Plugins must always use the relative units for rendering.
     * @memberof org.ekstep.contenteditor.basePlugin
     */
    percentToPixel: function(obj) {
        obj.x = obj.x * (720 / 100);
        obj.y = obj.y * (405 / 100);
        obj.w = obj.w * (720 / 100);
        obj.h = obj.h * (405 / 100);
        obj.rotate = obj.rotate;
    },

    /**
     * Sets the config for this object. Override this method to parse the config if necessary.
     * @memberof org.ekstep.contenteditor.basePlugin
     */
    setConfig: function(data) {
        this.config = data;
    },

    /**
     * Adds a given config key and value pair to the config for this plugin instance.
     * @memberof org.ekstep.contenteditor.basePlugin
     */
    addConfig: function(key, value) {
        if (_.isUndefined(this.config)) this.config = {};
        this.config[key] = value;
    },

    /**
     * Returns the config for this plugin. Child plugins should override this method to generate the
     * custom plugin JSON objects.
     * @memberof org.ekstep.contenteditor.basePlugin
     */
    getConfig: function() {
        return this.config;
    },

    /**
     * Returns the data that this plugin might set and use at runtime. As a best practice, plugins should
     * differentiate between config (e.g. rendering colors, font size, levels etc) and data (actual
     * word details to use).
     * @memberof org.ekstep.contenteditor.basePlugin
     */
    setData: function(data) {
        this.data = data;
    },

    /**
     * Returns the data for this plugin. Data includes actual drivers - such as the words in a word game
     * or questions in a quiz. Plugins should set their data is they want to differentiate from
     * the config.
     * @memberof org.ekstep.contenteditor.basePlugin
     */
    getData: function() {
        return this.data;
    },

    /**
     * Manages the ECML attributes for the plugins. This includes x,y,w,h and rotation related attributes
     * that are common to all plugins.
     * @private
     * @memberof org.ekstep.contenteditor.basePlugin
     */
    setAttributes: function(attr) {
        _.merge(this.attributes, attr);
    },

    /**
     * Returns the ECML attributes for the plugins. This includes x,y,w,h and rotation related attributes
     * that are common to all plugins.
     * @private
     * @memberof org.ekstep.contenteditor.basePlugin
     */
    getAttributes: function() {
        return _.omit(this.attributes, ['top', 'left', 'width', 'height']);
    },

    /**
     * Modigies the ECML attributes for the plugins. This includes x,y,w,h and rotation related attributes
     * that are common to all plugins.
     * @private
     * @memberof org.ekstep.contenteditor.basePlugin
     */
    setAttribute: function(key, value) {
        this.attributes[key] = value;
    },

    /**
     * Returns the individual ECML attribute for the plugins. This includes x,y,w,h and rotation related attributes
     * that are common to all plugins.
     * @param key {string} Attribute name
     * @private
     * @memberof org.ekstep.contenteditor.basePlugin
     */
    getAttribute: function(key) {
        return this.attributes[key];
    },

    /**
     * Adds a runtime event listener for this plugin. Plugins can respond to events on the renderer
     * such as stage entry, exit or results of evaluation.
     * @param event {object} Event object
     * @private
     * @memberof org.ekstep.contenteditor.basePlugin
     */
    addEvent: function(event) {        
        if (_.isUndefined(this.event)) this.event = [];
        if (_.isArray(this.event)) this.event.push(event)
        else this.event = [event];
    },

    /**
     * Returns the list of runtime events configured for this plugin. Plugins can respond to events on the renderer
     * such as stage entry, exit or results of evaluation.
     * @param event {object} Event object
     * @memberof org.ekstep.contenteditor.basePlugin
     */
    getEvents: function() {
        return this.event;
    },

    /**
     * Adds a runtime param - such as teacher instructions to the ECML output. Params are like shared variables
     * that can be used for evaluation across stages on the renderer.
     * @param key {string} Name of the runtime parameter
     * @param value {object} Data of the parameter
     * @memberof org.ekstep.contenteditor.basePlugin
     */
    addParam: function(key, value) {
        if (_.isUndefined(this.params)) this.params = {};
        this.params[key] = value;
    },

    /**
     * Removes a runtime param for this plugin.
     * @param key {string} Name of the param to remove.
     * @memberof org.ekstep.contenteditor.basePlugin
     */
    deleteParam: function(key){
        if(this.params) delete this.params[key];
    },

    /**
     * Returns the list of runtime params for this plugin.
     * @memberof org.ekstep.contenteditor.basePlugin
     */
    getParams: function() {
        return this.params;
    },

    /**
     * Returns the specified runtime parameter details. Note that the value of the parameter
     * is only available at runtime.
     * @param key {string} Name of the param to return.
     * @memberof org.ekstep.contenteditor.basePlugin
     */
    getParam: function(key) {
        return this.params ? this.params[key] : undefined;
    },

    /**
     * Adds media to the manifest of this plugin. You can add media such as images, audios, or even
     * other runtime dependencies such as JS, CSS and other plugin files. If you don't declare a
     * media, it will not be included in the content download archive.
     * @param media {object} Media to be included at runtime.
     * @memberof org.ekstep.contenteditor.basePlugin
     */
    addMedia: function(media) {
        if (_.isUndefined(this.media)) this.media = {};
        this.media[media.id] = media;
    },

    /**
     * Returns the media manifest of this plugin. You can add media such as images, audios, or even
     * other runtime dependencies such as JS, CSS and other plugin files. If you don't declare a
     * media, it will not be included in the content download archive.
     * @param media {object} Media to be included at runtime.
     * @memberof org.ekstep.contenteditor.basePlugin
     */
    getMedia: function() {
        return this.media;
    },

    /**
     * Returns the renderer dimensions for this plugin. This includes the x,y,w,h bounding box,
     * and the rotation of the object.
     * @memberof org.ekstep.contenteditor.basePlugin
     */
    getRendererDimensions: function() {
        var attr = this.getAttributes();
        var dims = {
            x: attr.x,
            y: attr.y,
            w: attr.w,
            h: attr.h,
            rotate: attr.rotate
        }
        this.pixelToPercent(dims);
        return dims;
    },

    /**
     * Generates and returns the ECML string for this plugin.
     * @private
     * @memberof org.ekstep.contenteditor.basePlugin
     */
    toECML: function() {
        if(this.editorObj) org.ekstep.contenteditor.api.updatePluginDimensions(this);
        var attr = _.clone(this.getAttributes());
        attr.id = this.id;
        this.pixelToPercent(attr);
        if (!_.isUndefined(this.getData())) {
            attr.data = {
                "__cdata": JSON.stringify(this.getData())
            };
        }
        if (!_.isUndefined(this.getConfig())) {
            attr.config = {
                "__cdata": JSON.stringify(this.getConfig())
            };
        }
        if (!_.isUndefined(this.getEvents())) {
            // attr.config = {
            //     "__cdata": JSON.stringify(this.getEvents())
            // };
            attr.event = this.getEvents();
        }
        if (!_.isUndefined(this.getParams())) {
            attr.param = [];
            _.forIn(this.getParams(), function(value, key) {
                attr.param.push({ name: key, value: value });
            });
        }
        return attr;
    },

    /**
     * Parses the ECML to construct this object.
     * @private
     * @param data {object} ECML to recontruct from
     * @memberof org.ekstep.contenteditor.basePlugin
     */
    fromECML: function(data) {
        var instance = this;
        this.attributes = data;
        if (!_.isUndefined(this.attributes.data)) {
            this.data = this.attributes.data.__cdata ? JSON.parse(this.attributes.data.__cdata) : this.attributes.data;
            delete this.attributes.data;
        }
        if (!_.isUndefined(this.attributes.config)) {
            this.config = this.attributes.config.__cdata ? JSON.parse(this.attributes.config.__cdata) : this.attributes.config;
            delete this.attributes.config;
        }
        if (!_.isUndefined(this.attributes.events)) {
            //this.events = JSON.parse(this.attributes.event.__cdata);
            delete this.attributes.events;
        }
        if (!_.isUndefined(this.attributes.event)) {
            //this.events = JSON.parse(this.attributes.event.__cdata);
            this.event = this.attributes.event;
            delete this.attributes.event;
        }
        if (!_.isUndefined(this.attributes.param)) {
            _.forEach(this.attributes.param, function(param) {
                instance.addParam(param.name, param.value);
            })
            delete this.attributes.param;
        }
        if (!_.isUndefined(this.attributes.asset)) {
            if (!_.isUndefined(this.attributes.assetMedia)) {
                instance.addMedia(this.attributes.assetMedia);
                delete this.attributes.assetMedia;
            } else {
                var media = org.ekstep.contenteditor.mediaManager.getMedia(this.attributes.asset);
                if (!_.isUndefined(media)) {
                    instance.addMedia(media);
                }
            }
        }
        this.percentToPixel(this.attributes);
    },

    /**
     * Utility function to conver the data of the object to Fabric properties - a simple variable
     * transformation that returns the corresponding fabric parameter names.
     * @param data {object} Data of the current plugin instance.
     * @memberof org.ekstep.contenteditor.basePlugin
     */
    convertToFabric: function(data) {
        var retData = _.clone(data);
        if (data.x) retData.left = data.x;
        if (data.y) retData.top = data.y;
        if (data.w) retData.width = data.w;
        if (data.h) retData.height = data.h;
        if (data.radius) retData.rx = data.radius;
        if (data.color) retData.fill = data.color;
        if (data.rotate) retData.angle = data.rotate;
        return retData;
    },
    getConfigManifest: function() {
        if (!this.manifest.editor.configManifest) { this.manifest.editor.configManifest = []; }
        var configManifest = this.manifest.editor.configManifest
        if (this.configManifest) {
            configManifest = _.uniqBy(_.clone(_.concat(this.manifest.editor.configManifest, this.configManifest),true),'propertyName');
        }
        if (!(this.manifest.editor.playable && this.manifest.editor.playable === true)) {
          _.remove(configManifest, function (cm) {return cm.propertyName === 'autoplay'})
        }
        return configManifest
    },

    /**
     * Allows a plugin to update the context menu when the plugin instance is selected. Plugins can use
     * this method to change any specific custom context menu actions.
     * @memberof org.ekstep.contenteditor.basePlugin
     */
    /* istanbul ignore next */
    updateContextMenu: function() {},

    /**
     * Plugins can override this to reset their configuration.
     * @memberof org.ekstep.contenteditor.basePlugin
     */    
    /* istanbul ignore next */
    reConfig: function() {},

    onConfigChange: function() {},

    /**
     * Called when the configuration is modified for the plugin. This is useful if the plugin
     * has to provide WYSIWYG feedback on the fabric canvas.
     * @param key {string} Config property name
     * @param value {string} Value of the config setting.
     * @memberof org.ekstep.contenteditor.basePlugin
     */
    _onConfigChange: function(key, value) {
        this.addConfig(key, value);
        var currentInstace = org.ekstep.contenteditor.api.getCurrentObject();
        if (currentInstace) {
            if (currentInstace.config === undefined) { currentInstace.config = {} }
            switch (key) {
                case 'opacity':
                    currentInstace.editorObj.setOpacity(value/100);
                    currentInstace.attributes.opacity = value/100;
                    currentInstace.config.opacity = value;
                    break;
                case 'strokeWidth':
                    value = parseInt(value);
                    currentInstace.editorObj.set('strokeWidth', value);
                    currentInstace.attributes['stroke-width'] = value;
                    currentInstace.attributes['strokeWidth'] = value;
                    currentInstace.config.strokeWidth = value;
                    break;
                case 'stroke':
                    currentInstace.editorObj.setStroke(value);
                    currentInstace.attributes.stroke = value;
                    currentInstace.config.stroke = value;
                    break;
                case 'autoplay':
                    currentInstace.attributes.autoplay = value;
                    currentInstace.config.autoplay = value;
                    break;
                case 'visible':
                    currentInstace.attributes.visible = value;
                    currentInstace.config.visible = value;
                    break;
            }
            org.ekstep.contenteditor.api.render();
            org.ekstep.contenteditor.api.dispatchEvent('object:modified', { target: org.ekstep.contenteditor.api.getEditorObject() });
        }
    },

    /**
     * Returns the help text for this plugin by reading the help markdown file. Plugins can override this
     * to return custom help.
     * @memberof org.ekstep.contenteditor.basePlugin
     */
    /* istanbul ignore next. test case failing */
    getHelp: function(cb) {        
        var helpText = "Help is not available."
        try {
            this.loadResource(this.manifest.editor.help.src, this.manifest.editor.help.dataType, function(err, help) {
                if (!err) {
                    helpText = help;
                    cb(helpText);
                }
            });
        } catch (e) {
            console.log(e)
            cb(helpText);
        }
    },

    /**
     * Returns the properties that editable for this plugin instance.
     * @private
     * @memberof org.ekstep.contenteditor.basePlugin
     */
    getProperties: function() {
        var props = _.omitBy(_.clone(this.attributes), _.isObject);
        props = _.omitBy(props, _.isNaN);
        this.pixelToPercent(props);
        return props;
    },

    /**
     * Renders the configuration view for this plugin. Default functionality is to launch the config
     * property editor. Plugins can override this method to change the way config is rendered.
     * @memberof org.ekstep.contenteditor.basePlugin
     */    
    /* istanbul ignore next */renderConfig: function() {},

    /**
     * Returns the manifest ID of this object
     * @memberof org.ekstep.contenteditor.basePlugin
     */
    getManifestId: function () {
      return (this.manifest.shortId || this.manifest.id);
    },

    /**
     * Returns the displayName of this object
     * @memberof org.ekstep.contenteditor.basePlugin
     */
    getDisplayName: function () {
         return (this.manifest.displayName || this.manifest.id);
    }
});

/**
 * @author Santhosh Vasabhaktula <santhosh@ilimi.in>
 */
org.ekstep.contenteditor.toolbarManager = new(Class.extend({
    menuItems: [],
    contextMenuItems: [],
    configMenuItems: [],
    scope: undefined,
    setScope: function(scope) {
        this.scope = scope;
    },
    registerMenu: function(menu) {
        if (!_.isObject(_.find(this.menuItems, { id: menu.id }))) {
            this.menuItems.push(menu);
        }
        if(this.scope) this.scope.refreshToolbar();
    },
    registerContextMenu: function(menu) {
        if (!_.isObject(_.find(this.contextMenuItems, { id: menu.id }))) {
            this.contextMenuItems.push(menu);
        }
        if(this.scope) this.scope.refreshToolbar();
    },
    resetContextMenu: function() {
        _.forEach(this.contextMenuItems, function(cmenu) {
            cmenu.state = 'HIDE';
            cmenu.selected = false;
        });
    },
    updateContextMenu: function(menus) {
        var instance = this;
        _.forEach(menus, function(cmenu) {
            instance._updateContextMenu(cmenu.id, cmenu);
        });
        /* istanbul ignore next. Angular functions cannot be tested now */
        org.ekstep.contenteditor.api.ngSafeApply(this.scope, function() {
            instance.scope.contextMenus = instance.contextMenuItems;
        });
        org.ekstep.contenteditor.jQuery(document).ready(function() {
            org.ekstep.contenteditor.jQuery(".ui.dropdown").dropdown();
            org.ekstep.contenteditor.jQuery(".popup-item").popup();
        });

    },
    _updateContextMenu: function(menuId, props) {
        //console.log('menu', menuId, 'props', props);
        var menu = _.find(this.contextMenuItems, { id: menuId });
        _.forIn(props, function(value, key) {
            if (key != 'data') {
                menu[key] = value;
                org.ekstep.pluginframework.eventManager.dispatchEvent(menuId + ':' + key, props.data);
            }
        });
    },
    getRegisterConfigMenu: function() {
        return this.configMenuItems;
    },
    cleanUp: function() {
        this.menuItems = [];
        this.contextMenus = [];
    }
}));

/**
 * @author Santhosh Vasabhaktula <santhosh@ilimi.in>
 */
org.ekstep.contenteditor.mediaManager = new(Class.extend({
    mediaMap: {},
    migratedMediaMap: {},
    addMedia: function(media) {
        if (_.isObject(media) && _.isString(media.id)) {
            this.mediaMap[media.id] = media;
        }
    },
    getMedia: function(asset) {
        return this.mediaMap[asset];
    },
    getMediaOriginURL: function(src) {
        var assetReverseProxyUrl = "/assets/public/";
        var replaceText = org.ekstep.contenteditor.config.baseURL + assetReverseProxyUrl;

        _.forEach(org.ekstep.contenteditor.config.aws_s3_urls, function(url){
            if(src.indexOf(url) !== -1){
                src = src.replace(url, replaceText);
            }
        });
        return src;
    },
    addToMigratedMedia: function(media) {
        if (_.isObject(media) && _.isString(media.id)) {
            this.migratedMediaMap[media.id] = media;
        }
    }
}));

org.ekstep.contenteditor.sidebarManager = new(Class.extend({
    loadNgModules: undefined,
    sidebarMenu: [],
    init: function() {
        this.setSidebarHeight();
    },
    initialize: function(config) {
        this.loadNgModules = config.loadNgModules;
        this.scope = config.scope
    },
    registerSidebarMenu: function(menu, manifest) {
        var instance = this;
        if (!_.isObject(_.find(this.sidebarMenu, { id: "sidebar:" + menu.id }))) {
            menu.onclick = menu.onclick || { id: "sidebar:" + menu.id };
            this.sidebarMenu.push(menu);
            this.loadSidebar(menu, manifest);
            ecEditor.addEventListener("sidebar:" + menu.id, function(event, data) {
                instance.showSidebarMenu(event.type.substring(event.type.indexOf(':') + 1));
            }, instance);
        }
    },
    loadSidebar: function(menu, manifest) {
        var instance = this;
        menu.state = menu.state || 'SHOW';
        if (menu.templateURL) {
            menu.templateURL = org.ekstep.contenteditor.api.resolvePluginResource(manifest.id, manifest.ver, menu.templateURL);
            instance.loadNgModules(menu.templateURL);

            if (menu.controllerURL) {
                menu.controllerURL = org.ekstep.contenteditor.api.resolvePluginResource(manifest.id, manifest.ver, menu.controllerURL);
                instance.loadNgModules(undefined, menu.controllerURL)
                    .then(function() {
                        instance.scope.addToSidebar(menu);
                    }, function() {
                        throw "unable to load controller :" + menu.controllerURL;
                    });
            } else {
                instance.scope.addToSidebar(menu);
            }
        };
    },
    loadCustomTemplate: function(pluginId) {
        var instance = this;
        var manifest = org.ekstep.pluginframework.pluginManager.getPluginManifest(pluginId);
        manifest.editor.configManifest = manifest.editor.configManifest || [];
        _.forEach(manifest.editor.configManifest, function(config) {
            if (config.type == "custom_template") {
                if (config.controllerURL) {
                    instance.loadNgModules(undefined, org.ekstep.contenteditor.api.resolvePluginResource(manifest.id, manifest.ver, config.controllerURL));
                }

                if (config.templateURL) {
                    var path = org.ekstep.contenteditor.api.resolvePluginResource(manifest.id, manifest.ver, config.templateURL);
                    org.ekstep.pluginframework.resourceManager.loadResource(path, 'HTML', function(err, data) {
                        if (err) throw "unable to load custom template";
                        if (data) config.template = data;
                    });
                }
            }
        });
    },
    updateSidebarMenu: function(menu) {
        var menuObject = _.find(this.sidebarMenu, { id: menu.id });
        _.forIn(menu, function(value, key) {
            if (key != 'id') menuObject[key] = value
        });
        this.scope.refreshSidebar();
    },
    getSidebarMenu: function() {
        return this.sidebarMenu;
    },
    setSidebarHeight: function() {
        var newheight = $(window).innerHeight() - 212;
        $('.sidebar-holder').css("height", newheight + "px");
    },
    getCurrentMenu: function() {
        return this.scope.configCategory.selected;
    },
    showSidebarMenu: function(sidebarMenuId) {        
        if (sidebarMenuId) {
            var menu = _.find(this.sidebarMenu, function(menu) {
                return menu.id === sidebarMenuId;
            });
            if (menu.state !== "HIDE") this.scope.configCategory.selected = sidebarMenuId;
            this.scope.refreshSidebar();
        }
    }
}));

org.ekstep.contenteditor.headerManager = new(Class.extend({
	registeredHeaders: [],
	initialize: function(config) {
        this.loadNgModules = config.loadNgModules;
        this.scope = config.scope
    },
    register: function(header, manifest) {
    	this.registeredHeaders.push({ id: manifest.id, header: header });
    	this.load(header, manifest);
    },
    load: function(header, manifest) {
        var instance = this;        
        if (header.templateURL) {
            header.templateURL = org.ekstep.contenteditor.api.resolvePluginResource(manifest.id, manifest.ver, header.templateURL);
            instance.loadNgModules(header.templateURL);

            if (header.controllerURL) {
                header.controllerURL = org.ekstep.contenteditor.api.resolvePluginResource(manifest.id, manifest.ver, header.controllerURL);
                instance.loadNgModules(undefined, header.controllerURL)
                    .then(function() {
                        instance.scope.addToHeader(header);
                    }, function() {
                        throw "unable to load controller :" + header.controllerURL;
                    });
            } else {
                instance.scope.addToHeader(header);
            }
        };
    }   
}));
/**
 * 
 * Popup service helps to show interactive popup modal/dialog window from plugin
 * 
 * @class org.ekstep.services.popupService
 * @author Sunil A S <sunils@ilimi.in>
 */
org.ekstep.services.popupService = new(org.ekstep.services.iService.extend({
    loadModules: undefined,
    openModal: undefined,
    initService: function(loadModuleFn, openModalFn) {
        this.loadModules = loadModuleFn;
        this.openModal = openModalFn;
    },
    /**
     *
     * loads HTML template and angular module 
     * @param templatePath {string} path to HTML template
     * @param controllerPath {string} path to angular module
     * @memberof org.ekstep.services.popupService
     */
    loadNgModules: function(templatePath, controllerPath) {
        this.loadModules && this.loadModules(templatePath, controllerPath);
    },
    /**
     *
     * opens popup modal/dialog window
     * @param config {object} config object refers to ngDialog open method parameter. please refer [ngDialog docs]{@link https://github.com/likeastore/ngDialog#openoptions}
     * @param callback {function} pre close Callback 
     * @memberof org.ekstep.services.popupService
     */
    open: function(config, callback) {
        /* istanbul ignore else */
        if (this.openModal) {
            this.openModal(config, callback);
            org.ekstep.services.telemetryService.interact({ "type": "click", "subtype": "open", "target": "popup", "pluginid": "", "pluginver": '', "objectid": "", "stage": ecEditor.getCurrentStage().id });
        }
    }
}));

/*// toECML
//     1. For each stage
//         1. for each plugin
            1. generate ecml
            2. add media to manifest
            3. add plugin to plugins used
        2. generate ecml
        3. add media to manifest
        4. add thumbnail
// 2. ManifestGenerator - generate plugin and media manifest using pluginsUsed array
// 3. Merge the media manifest generated by stages with the media manifest generated by the manifest generator
// 4. If there is migrated media - merge the migrated media with manifest media

// Pre-condition. toECML would generate the pluginUsed array
*/

var _PM_ = org.ekstep.pluginframework.pluginManager;
var ManifestGenerator = new(Class.extend({
    visitedPlugins: {},
    pluginManifest: [],
    mediaManifest: [],
    compatibilityVersion: 0,
    reset: function() {
        this.visitedPlugins = {};
        this.pluginManifest = [];
        this.mediaManifest = [];
    },
    getPluginManifest: function() {
        return this.pluginManifest;
    },
    getMediaManifest: function() {
        return this.mediaManifest;
    },
    isVisited: function(pluginId) {
        return this.visitedPlugins[pluginId] ? true : false;
    },
    visit: function(pluginId) {
        this.visitedPlugins[pluginId] = true;
    },
    generate: function(pluginUsedArray) {
        this.reset();
        this._generate(pluginUsedArray);
    },
    _generate: function(pluginArray) {
        var instance = this;
        _.forEach(pluginArray, function(pluginId) {
            instance._generateManifest(pluginId);
        })
    },
    _generateManifest: function(pluginId) {
        if(!this.isVisited(pluginId)) {
            this.visit(pluginId);
            var manifest = _PM_.getPluginManifest(pluginId);
            if(!_.isUndefined(manifest)) {
                this._generatePluginManifest(manifest);
                this._generateMediaManifest(manifest);
            }
        }
    },
    _getDependencies: function(pluginManifest) {
        var depends = undefined;
        if(pluginManifest.dependencies && pluginManifest.dependencies.length > 0) {
            var dependencies = _.map(_.filter(pluginManifest.dependencies, function(dependency) {
                return ['all','renderer'].indexOf(dependency.scope) != -1;
            }), function(dep) { return dep.plugin });
            if(dependencies.length > 0) {
                depends = dependencies;
            }
        }
        return depends;
    },
    _generatePluginManifest: function(manifest) {
        var depends = this._getDependencies(manifest);
        var dependsStr = '';
        if(!_.isUndefined(depends) && depends.length > 0) {
            this._generate(depends);
            dependsStr = depends.join(',');    
        } 
        manifest.type = manifest.type || "plugin";
        if (manifest.renderer) this.pluginManifest.push({id: manifest.id, ver: manifest.ver, type: manifest.type, depends: dependsStr});       
    },
    _generateMediaManifest: function(manifest) {
        var instance = this;
        if(manifest.renderer) {
            if (manifest.renderer.compatibilityVersion && (manifest.renderer.compatibilityVersion > instance.compatibilityVersion)) instance.compatibilityVersion = manifest.renderer.compatibilityVersion;

            // Add js/css/custom plugin dependencies
            if(manifest.renderer.dependencies && manifest.renderer.dependencies.length > 0) {
                _.forEach(manifest.renderer.dependencies, function(dependency) {
                    instance.mediaManifest.push({
                        id: dependency.id || UUID(),
                        plugin: manifest.id,
                        ver: manifest.ver,
                        src: _PM_.resolvePluginResource(manifest.id, manifest.ver, dependency.src),
                        type: dependency.type
                    })
                });
            }
            // Add main renderer script file
            if(manifest.renderer.main) {
                instance.mediaManifest.push({
                    id: manifest.id,
                    plugin: manifest.id,
                    ver: manifest.ver,
                    src: _PM_.resolvePluginResource(manifest.id, manifest.ver, manifest.renderer.main),
                    type: 'plugin'
                });
            }
            // Add the manifest.json of the renderer plugin
            instance.mediaManifest.push({
                id: manifest.id + '_manifest',
                plugin: manifest.id,
                ver: manifest.ver,
                src: _PM_.resolvePluginResource(manifest.id, manifest.ver, 'manifest.json'),
                type: 'json'
            });
        }
    },
    getCompatibilityVersion: function() {
        if (this.compatibilityVersion) return this.compatibilityVersion;
        return;
    }
}));
/**
 *
 * Telemetry service helps to log telemetry events. Telemetry service generates below listed events
 * and logs to registered dispatchers.
 * <ol>
 *  <li>CE_START
 *  <li>CE_API_CALL
 *  <li>CE_INTERACT
 *  <li>CE_PLUGIN_LIFECYCLE
 *  <li>CE_ERROR
 *  <li>CE_END
 * </ol>
 *
 * @class org.ekstep.services.telemetryService
 * @author Santhosh Vasabhaktula <santhosh@ilimi.in>
 */
org.ekstep.services.telemetryService = new(org.ekstep.services.iService.extend({
    context: {},
    dispatchers: [],
    initialized: true,
    start_event: undefined,
    startEventData: undefined,
    /**
     * 
     * Initialize the service with context and dispatcher.     
     * @param context {object} context object can have uid, sid, context_id. 
     * context should have content id, otherwise telemetry service cannot be initialized.
     * @param dispatcher {string} There are 3 types of dispatcher available, anyone of dispatcher 
     * is allowed and same dispatcher is used throughout the editor session. 
     * <ol>
     *   <li>Local dispatcher - dev environment only, logs to file (telemetry.log) - value: "local"
     *   <li>piwik dispatcher - logs to piwik endpoint - value: "piwik"
     *   <li>console dispatcher - logs to client console, default dispatcher - value: undefined
     * </ol>
     * 
     * @memberof org.ekstep.services.telemetryService
     *
     */
    initialize: function(context, dispatcher) {
        var instance = this;
        this.context = context;
        /* istanbul ignore else */
        if (this.context.cdata == undefined) {
            this.context.cdata = [];
        }
        if ((this.context.uid == undefined) || (this.context.sid == undefined) || (this.context.content_id == undefined)) {
            console.error('Unable to instantiate telemetry service');
            this.initialized = false;
        }
        this.addDispatcher(dispatcher);

        window.addEventListener('unload', /* istanbul ignore next */ function() {
            instance.end();
        });

        this.startEventData = { defaultPlugins: Object.keys(org.ekstep.pluginframework.pluginManager.plugins), loadtimes: {}, client: {} };
    },
    /**
     *
     * to populate data for start event (CE_START)  
     * @param autoplublish {boolean} if "true" logs the events through dispatcher. 
     * @returns {object} returns method chain. 
     * <ol>
     *   <li> <pre>getData()</pre>: return start event data
     *   <li> <pre>append(param, dataObj)</pre>: appends only "loadtimes" param of CE_START with dataObj(type: object). 
     * <ol> 
     * @memberof org.ekstep.services.telemetryService
     *
     */
    startEvent: function(autopublish) {
        var instance = this;
        return {
            getData: function() {
                return instance.startEventData;
            },
            append: function(param, dataObj) {
                for (var key in dataObj) {
                    instance.startEventData[param][key] = dataObj[key];
                }
                if (autopublish) instance.start();
            }
        }
    },
    /**
     *
     * returns dispatcher instance
     * @param dispatcherId {string}     
     * <ol>
     *   <li>Local dispatcher: value: "local"
     *   <li>piwik dispatcher: value: "piwik"
     *   <li>(default) console dispatcher: value: undefined 
     * </ol>
     * @returns dispatcher {object}
     * @memberof org.ekstep.services.telemetryService
     *
     */
    getDispatcher: function(dispatcherId) {
        switch (dispatcherId) {
            case "local":
                return org.ekstep.contenteditor.localDispatcher;
            case "piwik":
                return org.ekstep.contenteditor.piwikDispatcher;
            default:
                return org.ekstep.contenteditor.consoleDispatcher;
        }
    },
    /**
     * 
     * To add a dispatcher to the dispatcher registry
     * @param dispatcherId {string}
     * <ol>
     *   <li>Local dispatcher: value: "local"
     *   <li>piwik dispatcher: value: "piwik"
     *   <li>(default) console dispatcher: value: undefined 
     * </ol>
     * @memberof org.ekstep.services.telemetryService
     *
     */
    addDispatcher: function(dispatcherId) {
        var dispatcher = this.getDispatcher(dispatcherId);
        var dispatcherExist = this.dispatchers.find(function(obj) {
            return obj.type === dispatcher.type;
        });
        if (!dispatcherExist) this.dispatchers.push(dispatcher);
    },
    /**
     *
     * dispatch event to all registered dipatchers
     * @private
     * @param message {event} structured event
     * @memberof org.ekstep.services.telemetryService
     *
     */
    _dispatch: function(message) {
        if (this.initialized) {
            message.mid = 'CE:' + CryptoJS.MD5(JSON.stringify(message)).toString();
            _.forEach(this.dispatchers, function(dispatcher) {
                dispatcher.dispatch(message);
            });
        }
    },
    /**
     *
     * returns structured telemetry event for the given data
     * @param eventId {string} 
     * <ol>
     *  <li>CE_START
     *  <li>CE_API_CALL
     *  <li>CE_INTERACT
     *  <li>CE_PLUGIN_LIFECYCLE
     *  <li>CE_ERROR
     *  <li>CE_END
     * </ol>
     * @param data {object} telemetry data object specified for each telemetry event.
     * @memberof org.ekstep.services.telemetryService
     *
     */
    getEvent: function(eventId, data) {
        return {
            "eid": eventId,
            "mid": "",
            "ets": (new Date()).getTime(),
            "channel": this.context.channel,
            "ver": "2.1",
            "pdata": this.context.pdata,
            "cdata": this.context.cdata, //TODO: No correlation data as of now. Needs to be sent by portal in context
            "uid": this.context.uid, // uuid of the requester
            "context": { "sid": this.context.sid, "content_id": this.context.content_id },
            "rid": "", // Leave blank.
            "edata": { "eks": data },
            "etags": this.context.etags

        }
    },
    /**
     *
     * validates telemetry data with mandatory fields
     * @param data {object} telemetry data
     * @param mandatoryFields {array} required fields for the specific telemetry to validate
     * @memberof org.ekstep.services.telemetryService
     *
     */
    hasRequiredData: function(data, mandatoryFields) {
        var isValid = true;
        mandatoryFields.forEach(function(key) {
            if (!data.hasOwnProperty(key)) isValid = false;
        });
        return isValid;
    },
    interactRequiredFields: ["type", "subtype", "target", "pluginid", "pluginver", "objectid", "stage"],
    lifecycleRequiredFields: ["type", "pluginid", "pluginver", "objectid", "stage"],
    errorRequiredFields: ["env", "stage", "action", "err", "type", "data", "severity", "objectid", "objecttype"],
    apiCallRequiredFields: ["path", "method", "request", "response", "responseTime", "status", "uip"],
    /**
     *
     * dispatches interact event (CE_INTERACT)
     * @param data {object} interact event data
     * @memberof org.ekstep.services.telemetryService
     *
     */
    interact: function(data) {
        if (!this.hasRequiredData(data, this.interactRequiredFields)) {
            console.error('Invalid interact data');
            return;
        }
        this._dispatch(this.getEvent('CE_INTERACT', data))
    },
    /**
     *
     * dispatches end event (CE_END)
     * @memberof org.ekstep.services.telemetryService
     *
     */
    end: function() {
        var endEvent = this.getEvent('CE_END', {});
        endEvent.edata.eks.duration = (new Date()).getTime() - this.start_event.ets;
        this._dispatch(endEvent);
    },
    /**
     *
     * dispatches plugin lifecycle event (CE_PLUGIN_LIFECYCLE)
     * @param data {object} plugin lifecycle event data
     * @memberof org.ekstep.services.telemetryService
     *
     */
    pluginLifeCycle: function(data) {
        if (!this.hasRequiredData(data, this.lifecycleRequiredFields)) {
            console.error('Invalid plugin lifecycle event data');
            return;
        }
        this._dispatch(this.getEvent('CE_PLUGIN_LIFECYCLE', data))
    },
    /**
     *
     * dispatches error event (CE_ERROR)
     * @param data {object} error event data
     * @memberof org.ekstep.services.telemetryService
     *
     */
    error: function(data) {
        if (!this.hasRequiredData(data, this.errorRequiredFields)) {
            console.error('Invalid error data');
            return;
        }
        this._dispatch(this.getEvent('CE_ERROR', data))
    },
    /**
     *
     * dispatches start event (CE_START)
     * @memberof org.ekstep.services.telemetryService
     *
     */
    start: function() {
        this.startEventData.client = this.detectClient();
        this.start_event = this.getEvent('CE_START', this.startEventData);
        this._dispatch(this.start_event);
    },
    /**
     *
     * dispatches api call event (CE_API_CALL)
     * @param data {object} api call event data
     * @memberof org.ekstep.services.telemetryService
     *
     */
    apiCall: function(data) {
        if (!this.hasRequiredData(data, this.apiCallRequiredFields)) {
            console.error('Invalid api call data');
            return;
        }
        this._dispatch(this.getEvent('CE_API_CALL', data))
    },
    /**
     *
     * returns client machine info such as OS, browser, browser version
     * @memberof org.ekstep.services.telemetryService
     *
     */
    detectClient: function() {

        var nAgt = navigator.userAgent;
        var browserName = navigator.appName;
        var fullVersion = '' + parseFloat(navigator.appVersion);
        var nameOffset, verOffset, ix;

        // In Opera
        /* istanbul ignore next. Cannot test this as the test cases runs in phatomjs browser */
        if ((verOffset = nAgt.indexOf("Opera")) != -1) {
            browserName = "opera";
            fullVersion = nAgt.substring(verOffset + 6);
            if ((verOffset = nAgt.indexOf("Version")) != -1)
                fullVersion = nAgt.substring(verOffset + 8);
        }
        // In MSIE
        else if ((verOffset = nAgt.indexOf("MSIE")) != -1) {
            browserName = "IE";
            fullVersion = nAgt.substring(verOffset + 5);
        }
        // In Chrome
        else if ((verOffset = nAgt.indexOf("Chrome")) != -1) {
            browserName = "chrome";
            fullVersion = nAgt.substring(verOffset + 7);
        }
        // In Safari
        else if ((verOffset = nAgt.indexOf("Safari")) != -1) {
            browserName = "safari";
            fullVersion = nAgt.substring(verOffset + 7);
            if ((verOffset = nAgt.indexOf("Version")) != -1)
                fullVersion = nAgt.substring(verOffset + 8);
        }
        // In Firefox
        else if ((verOffset = nAgt.indexOf("Firefox")) != -1) {
            browserName = "firefox";
            fullVersion = nAgt.substring(verOffset + 8);
        }

        // trim the fullVersion string at semicolon/space if present
        /* istanbul ignore next. Cannot test this as the test cases runs in phatomjs browser */
        if ((ix = fullVersion.indexOf(";")) != -1)
            fullVersion = fullVersion.substring(0, ix);
        /* istanbul ignore next. Cannot test this as the test cases runs in phatomjs browser */
        if ((ix = fullVersion.indexOf(" ")) != -1)
            fullVersion = fullVersion.substring(0, ix);

        return { browser: browserName, browserver: fullVersion, os: navigator.platform };
    }
}));

org.ekstep.contenteditor.IDispatcher = Class.extend({
    init: function() {
        this.initDispatcher();
    },
    initDispatcher: function() {throw 'Subclass should implement initDispatcher'},
    dispatch: function(event) {throw 'Subclass should implement dispatch'}
});
org.ekstep.contenteditor.consoleDispatcher = new(org.ekstep.contenteditor.IDispatcher.extend({
    type: "consoleDispatcher",
    initDispatcher: function() {},
    dispatch: function(event) {
        console.log(event);
    }
}));

org.ekstep.contenteditor.localDispatcher = new(org.ekstep.contenteditor.IDispatcher.extend({
    type: "localDispatcher",
    initDispatcher: function() {},
    dispatch: function(event) {        
        event = (typeof event === "string") ? event : JSON.stringify(event);
        org.ekstep.contenteditor.jQuery.ajax({
            type: 'POST',
            url: org.ekstep.contenteditor.config.localDispatcherEndpoint,
            data: {event: event},
            success: function(res) {}
        });
    }
}));

org.ekstep.contenteditor.piwikDispatcher = new(org.ekstep.contenteditor.IDispatcher.extend({
    type: "piwikDispatcher",
    piwikEndPoint: function() {
        return org.ekstep.contenteditor.config.baseURL + "/piwik/piwik.php";
    },
    idsite: 1,
    initDispatcher: function() {},
    dispatch: function(event) {
        if (!event) return;

        try {
            event = (typeof event === "string") ? event : JSON.stringify(event);
            /* istanbul ignore next. Cannot test jquery post */
            org.ekstep.contenteditor.jQuery.post(this.piwikEndPoint(), 'idsite=' + this.idsite + '&url=' + org.ekstep.contenteditor.config.absURL + location.pathname + '&e_c=ContentEditor&e_a=' + event + '&rec=1', function() {
            })
            .fail(function() {
                console.log("error: while piwik dispatch");
            });
        } catch (e) {
            console.log('error: piwik event cannot be stringify', e);
        }
    }
}));

/**
 * @author Santhosh Vasabhaktula <santhosh@ilimi.in>
 */
/* istanbul ignore next. Fabric extension - cannot be tested */

var collection_editor = function() {};
collection_editor.prototype.jQuery = window.$;
collection_editor.prototype._ = window._;
window.org.ekstep.collectioneditor = new collection_editor();

window.ServiceConstants.COLLECTION_SERVICE = "collection";
org.ekstep.contenteditor.config = _.assign(org.ekstep.contenteditor.config, {
    plugins: [
        { "id": "org.ekstep.collectionheader", "ver": "1.0", "type": "plugin" },
        { "id": "org.ekstep.download", "ver": "1.0", "type": "plugin" }
    ]
});

org.ekstep.collectioneditor.cache = {
    nodesModified: {}
};
window.org.ekstep.collectioneditor.api = _.assign(org.ekstep.contenteditor.api, {
    initEditor: function(config, cb) {
        var startTime = Date.now();
        if (config) org.ekstep.services.collectionService.initialize(config);
        org.ekstep.pluginframework.pluginManager.loadAllPlugins(ecEditor.getConfig('collectionEditorPlugins'), undefined, function () {
            org.ekstep.services.telemetryService.initialize({
                uid: ecEditor.getContext('uid'),
                sid: ecEditor.getContext('sid'),
                content_id: ecEditor.getContext('contentId'),
                etags: ecEditor.getContext('etags') || {},
                channel: ecEditor.getContext('channel')  || "",
                pdata: ecEditor.getContext('pdata') || {}
            }, ecEditor.getConfig('dispatcher'));
            org.ekstep.services.telemetryService.startEvent(true).append("loadtimes", { plugins: (Date.now() - startTime) });        
            if (cb) cb();    
        });        
    },
    /**
     * Retrns the current stage object to the plugin. Plugins might use this to query other objects on the
     * canvas or access other stage context.
     * @memberof org.ekstep.contenteditor.api
     */
    getCurrentStage: function() {
        return org.ekstep.services.collectionService.getActiveNode().data;
    },
    /**
     * Returns the handle to the Angular services. The services can be used by plugisn to achieve
     * the functional calls or render custom views. Valid services are:
     *     popup - UI service to render popup
     *     content - Provides access to the content API (for loading templates and assets)
     *     assessment - Provides access to the assessment API (for loading questions)
     *     language - Provides access to the wordnet API (for loading words and aksharas)
     *     search - Provides access to search API (for search activities, question, domains)
     *     meta - Provides access to metadata API (for resource bundles, ordinals, definitions)
     *     asset - Provides access to the content API (for save assets)
     *     telemetry - Service to genarate and log telemetry events
     *     collection - collection service
     * @param serviceId {string} id of the service to return. Returns undefined if the id is invalid
     * @memberof org.ekstep.contenteditor.api
     */
    getService: function(serviceId) {
        var service = '';
        switch (serviceId) {
            case ServiceConstants.POPUP_SERVICE:
                service = org.ekstep.services.popupService;
                break;
            case ServiceConstants.CONTENT_SERVICE:
                service = org.ekstep.services.contentService;
                break;
            case ServiceConstants.ASSESSMENT_SERVICE:
                service = org.ekstep.services.assessmentService;
                break;
            case ServiceConstants.LANGUAGE_SERVICE:
                service = org.ekstep.services.languageService;
                break;
            case ServiceConstants.SEARCH_SERVICE:
                service = org.ekstep.services.searchService;
                break;
            case ServiceConstants.META_SERVICE:
                service = org.ekstep.services.metaService;
                break;
            case ServiceConstants.ASSET_SERVICE:
                service = org.ekstep.services.assetService;
                break;
            case ServiceConstants.TELEMETRY_SERVICE:
                service = org.ekstep.services.telemetryService;
                break;
            case ServiceConstants.COLLECTION_SERVICE:
                service = org.ekstep.services.collectionService;
                break;
        }
        return service;
    },
    registerMetaPage: function(config) {
        if(config) org.ekstep.collectioneditor.metaPageManager.register(config);
    }
});

window.ecEditor = window.org.ekstep.collectioneditor.api;
/**
 * The base plugin class that all collection editor plugins inherit from. It provides the common support contract for all plugins.
 * Plugins can override specific methods to change the behavior.
 *
 * @class org.ekstep.collectioneditor.basePlugin
 * @author Santhosh Vasabhaktula <sunils@ilimi.in>
 */
org.ekstep.collectioneditor.basePlugin = Class.extend({
    id: undefined,
    parent: undefined,
    children: [],
    manifest: undefined,
    editorData: undefined,
    data: undefined,
    /**
     * Initializes the plugin with the given manifest and parent object
     * @param manifest {object} Manifest details for this plugin
     * @param data {object} Init parameters for the plugin
     * @param parent {object} Parent plugin object that instantiated this
     * @constructor
     * @memberof org.ekstep.collectioneditor.basePlugin
     */
    init: function(manifest, data, parent) {
        var instance = this;
        this.manifest = _.cloneDeep(manifest);
        if (arguments.length == 1) {
            this.registerMenu();
            this.initialize();
            org.ekstep.contenteditor.api.addEventListener(this.manifest.id + ":create", this.create, this);
            console.log(manifest.id + " plugin initialized");
        } else {
            this.data = undefined,
            this.editorData = data || {};
            this.children = [];
            this.id = this.editorData.id || UUID();
            this.parent = parent;            
        }
    },

    /**
     * Initializes the plugin.
     * @private
     * @memberof org.ekstep.collectioneditor.basePlugin
     */
    initPlugin: function() {        
        this.newInstance();
        this.postInit();
    },

    /**
     * Post init tasks for the plugin
     * @private
     * @memberof org.ekstep.collectioneditor.basePlugin
     */
    postInit: function() {                
        if (this.parent) this.parent.addChild(this);        
    },

    /**
     * Registers the menu for this plugin. By default, the base plugin handles the menu additions.
     * Child implementations can use this method to override and register additional menu items.
     * @memberof org.ekstep.collectioneditor.basePlugin
     */
    registerMenu: function() {
        var instance = this;
        _.forEach(instance.manifest.editor.header, function(header) {
            org.ekstep.contenteditor.headerManager.register(header, instance.manifest);
        });

        _.forEach(instance.manifest.editor.container, function(container) {
            org.ekstep.contenteditor.containerManager.register(container, instance.manifest);
        });
    },

    /**
     * Returns relative URL for a particular asset. Plugins should use this method instead of
     * hard-coding the asset URLs.
     * @memberof org.ekstep.collectioneditor.basePlugin
     */
    relativeURL: function(src) {
        return org.ekstep.contenteditor.api.resolvePluginResource(this.manifest.id, this.manifest.ver, src);
    },

    /**
     * Returns the type of this plugin (manifest ID)
     * @memberof org.ekstep.collectioneditor.basePlugin
     */
    getType: function() {
        return this.manifest.id;
    },

    /**
     * Returns the version of this plugin (manifest ID)
     * @memberof org.ekstep.collectioneditor.basePlugin
     */
    getVersion: function() {
        return this.manifest.ver;
    },
    /**
     * Helper method to load a given resource relative to the plugin.
     * @memberof oorg.ekstep.collectioneditor.basePlugin
     */
    loadResource: function(src, dataType, cb) {
        org.ekstep.contenteditor.api.loadPluginResource(this.manifest.id, this.manifest.ver, src, dataType, cb);
    },

    /**
     * Removes the plugin from the stage. This can be used to perform self cleanup. If this method is called
     * from newInstance(), plugin won't be added to stage children.
     * @memberof org.ekstep.collectioneditor.basePlugin
     */
    remove: function() {
        if (this.parent) {
            this.parent.removeChild(this);
            this.parent =  undefined; // if this method is called from newInstance(), plugin won't be added to stage children    
        }
        delete org.ekstep.pluginframework.pluginManager.pluginInstances[this.id];
    },

    /**
     * Creates the instance of the plugin when a new object is added to the canvas.
     * @private
     * @memberof org.ekstep.collectioneditor.basePlugin
     */
    create: function(event, data, parent) {        
        org.ekstep.contenteditor.api.instantiatePlugin(this.manifest.id, _.clone(data), parent);
    },

    /**
     * Adds a child to this object. This can be useful for composite scenarios.
     * @memberof org.ekstep.collectioneditor.basePlugin
     */
    addChild: function(plugin) {
        this.children.push(plugin);
    },

    /**
     * Removes a child from this plugin. Use this to dynamically manage composite children.
     * @memberof org.ekstep.collectioneditor.basePlugin
     */
    removeChild: function(plugin) {
        this.children = _.reject(this.children, { id: plugin.id });
    },

    /**
     * Initialize the plugin when it is loaded. This is a no-op implementation and child classes must
     * provide the complete functional implementation.
     * @memberof org.ekstep.collectioneditor.basePlugin
     */
    /* istanbul ignore next */initialize: function(data) {},

    /**
     * Instantiate an object of the plugin type. This is a no-op implementation and child classes must
     * provide the complete functional implementation.
     * @memberof org.ekstep.collectioneditor.basePlugin
     */
    /* istanbul ignore next */newInstance: function(data) {},
    /**
     * Returns the data that this plugin might set and use at runtime. As a best practice, plugins should
     * differentiate between config (e.g. rendering colors, font size, levels etc) and data (actual
     * word details to use).
     * @memberof org.ekstep.collectioneditor.basePlugin
     */
    setData: function(data) {
        this.data = data;
    },

    /**
     * Returns the data for this plugin. Data includes actual drivers - such as the words in a word game
     * or questions in a quiz. Plugins should set their data is they want to differentiate from
     * the config.
     * @memberof org.ekstep.collectioneditor.basePlugin
     */
    getData: function() {
        return this.data;
    },
    /**
     * Returns the help text for this plugin by reading the help markdown file. Plugins can override this
     * to return custom help.
     * @memberof org.ekstep.collectioneditor.basePlugin
     */
    /* istanbul ignore next. test case failing */
    getHelp: function(cb) {        
        var helpText = "Help is not available."
        try {
            this.loadResource(this.manifest.editor.help.src, this.manifest.editor.help.dataType, function(err, help) {
                if (!err) {
                    helpText = help;
                    cb(helpText);
                }
            });
        } catch (e) {
            console.log(e)
            cb(helpText);
        }
    },
    getManifestId: function () {
      return (this.manifest.shortId || this.manifest.id);
    },

    /**
     * Returns the displayName of this object
     * @memberof org.ekstep.collectioneditor.basePlugin
     */
    getDisplayName: function () {
         return (this.manifest.displayName || this.manifest.id);
    }
});

org.ekstep.contenteditor.containerManager = new(Class.extend({
	registeredContainer: [],
	initialize: function(config) {
        this.loadNgModules = config.loadNgModules;
        this.scope = config.scope
    },
    register: function(container, manifest) {
    	this.registeredContainer.push({ id: manifest.id, container: container });
    	this.load(container, manifest);
    },
    load: function(container, manifest) {
        var instance = this;        
        if (container.templateURL) {
            container.templateURL = org.ekstep.contenteditor.api.resolvePluginResource(manifest.id, manifest.ver, container.templateURL);
            instance.loadNgModules(container.templateURL);

            if (container.controllerURL) {
                container.controllerURL = org.ekstep.contenteditor.api.resolvePluginResource(manifest.id, manifest.ver, container.controllerURL);
                instance.loadNgModules(undefined, container.controllerURL)
                    .then(function() {
                        instance.scope.addToContainer(container);
                    }, function() {
                        throw "unable to load controller :" + container.controllerURL;
                    });
            } else {
                instance.scope.addToContainer(container);
            }
        };
    }   
}));
org.ekstep.collectioneditor.metaPageManager = new(Class.extend({
    registeredPages: [],
    initialize: function(config) {
        this.loadNgModules = config.loadNgModules;
    },
    register: function(config) {
        var instance = this;
        if (config.templateURL) {
            instance.loadNgModules(config.templateURL);
            if (config.controllerURL) {
                instance.loadNgModules(undefined, config.controllerURL)
                    .then(function() {
                        instance.registeredPages.push(config);
                    }, function() {
                        throw "unable to load controller :" + config.controllerURL;
                    });
            }
        };
    },
    getPages: function() {
        return this.registeredPages;
    }
}));

org.ekstep.services.collectionService = new(Class.extend({
    config: undefined,
    data: {},
    initialize: function(config) {
        if (config) this.config = config;
    },
    getConfig: function() {
        return this.config;
    },
    getTreeObject: function() {
        return ecEditor.jQuery("#collection-tree").fancytree("getTree").toDict(true);
    },
    expandAll: function(flag) {
        ecEditor.jQuery('#collection-tree').fancytree('getTree').visit(function(node){node.setExpanded(flag);});
    },
    getActiveNode: function() {
        return ecEditor.jQuery("#collection-tree").fancytree("getTree").getActiveNode();
    },
    getNodeById: function(id) {
        var _node;
        ecEditor.jQuery('#collection-tree').fancytree('getTree').visit(function(node){
            if (node.data.id === id) _node = node;
        });
        return _node;
    },
    setNodeTitle: function(title) {
        var instance = this;
        if (title) ecEditor.jQuery("#collection-tree").fancytree("getTree").getActiveNode().applyPatch({ 'title': (title.length > 22) ? title.substring(0,22)+'...' : title }).done(function(a, b) {
            instance.onRenderNode(undefined, { node: ecEditor.jQuery("#collection-tree").fancytree("getTree").getActiveNode() }, true);
        });
    },
    setActiveNode: function(key) {
        if (key) ecEditor.jQuery("#collection-tree").fancytree("getTree").getNodeByKey(key).setActive();
    },
    clearFilter: function() {
        ecEditor.jQuery("#collection-tree").fancytree("getTree").clearFilter();
    },
    filterNode: function(text) {
        if (text) ecEditor.jQuery("#collection-tree").fancytree("getTree").filterNodes(text, { autoExpand: true });
    },
    addNode: function(objectType, data) {
        var newNode;
        data = data || {};
        var selectedNode = this.getActiveNode();
        objectType = this.getObjectType(objectType);
        var node = {};
        node.title = data.name ? data.name : 'Untitled ' + objectType.label;
        node.objectType = data.contentType || objectType.type;
        node.id = data.identifier ? data.identifier : UUID();
        node.root = false;
        node.folder = (objectType.childrenTypes.length > 0);
        node.icon = objectType.iconClass;
        node.metadata = data;
        if (node.folder) { 
            if (selectedNode.getLevel() === this.config.rules.levels - 1) return;
            newNode = selectedNode.addChildren(node);
            newNode.setActive();
            org.ekstep.collectioneditor.cache.nodesModified[node.id] = { isNew: true, root: false, metadata: { mimeType: "application/vnd.ekstep.content-collection" } };
        } else { 
            newNode = selectedNode.addChildren(node); 
        };
        //selectedNode.sortChildren(null, true);
        selectedNode.setExpanded();
        ecEditor.dispatchEvent("org.ekstep.collectioneditor:node:added", newNode);
    },
    removeNode: function() {
        var selectedNode = this.getActiveNode();
        if (!selectedNode.data.root) {
            ecEditor.getService('popup').open({
                template: '<div class="ui icon negative message remove-unit-popup"><i class="close icon" ng-click="closeThisDialog()"></i><div class="content"><div class="header"><i class="fa fa-exclamation-triangle"></i> Do you want to remove this?</div><div class="remove-unit-buttons" style="padding-right:0; text-align:right;"><div class="ui red button button-overrides" id="remove-yes-button" ng-click="confirm()">Yes</div><div class="ui basic primary button button-overrides" id="remove-no-button" ng-click="closeThisDialog()">No</div></div></div></div>',
                controller: ["$scope", function($scope) {
                    $scope.confirm = function() {
                        selectedNode.remove();
                        $scope.closeThisDialog();
                        delete org.ekstep.collectioneditor.cache.nodesModified[selectedNode.data.id];
                        ecEditor.dispatchEvent("org.ekstep.collectioneditor:node:removed", selectedNode.data.id);
                    };
                }],
                plain: true,
                showClose: false
            });
        }
    },
    getContextMenuTemplate: function(node) {
        var instance = this, removeTemplate= "", contextMenu = "";
        var childrenTypes = this.getObjectType(node.data.objectType).childrenTypes;
        if (!node.data.root) removeTemplate = '<i class="fa fa-trash-o" onclick="org.ekstep.services.collectionService.removeNode(); org.ekstep.services.collectionService.__telemetry({ subtype: \'remove\', target: \'removeNodeBtn\'});"></i>';
        if (childrenTypes && childrenTypes.length === 0) return;
        ecEditor._.forEach(childrenTypes, function(types) {
            if (instance.getObjectType(types).addType === "Browser") {
                contextMenu = contextMenu + '<div class="item" onclick="org.ekstep.services.collectionService.addLesson(\'' + types + '\'); org.ekstep.services.collectionService.__telemetry({ subtype: \'addLesson\', target: \''+ types + '\' });"><i class="' + instance.getObjectType(types).iconClass + '"></i>&nbsp;' + instance.getObjectType(types).label + '</div>';
            } else if (node.getLevel() !== (instance.config.rules.levels - 1)) {
                contextMenu = contextMenu + '<div class="item" onclick="org.ekstep.services.collectionService.addNode(\'' + types + '\'); org.ekstep.services.collectionService.__telemetry({ subtype: \'addNode\', target: \''+ types + '\' });"><i class="' + instance.getObjectType(types).iconClass + '"></i>&nbsp;' + instance.getObjectType(types).label + '</div>';
            }            
        });        
        return '<span style="padding-left: 20px;left: 65%;">' + '<div class="ui inline dropdown">' + '<i class="add square icon"></i>' + '<div class="menu">' + contextMenu + '</div>' + '</div>' + removeTemplate + '</span>'
    },
    addLesson: function(type) {
        var instance = this;
        ecEditor.dispatchEvent("org.ekstep.lessonbrowser:show", {
            filters: { lessonType: [type] },
            callback: function(err, res) {
                if (res) {
                    _.forEach(res, function(obj) {
                        instance.addNode(obj.contentType, obj);
                    });
                }
            }
        });
    },
    addTree: function(tree) {
        var instance = this;
        ecEditor.jQuery("#collection-tree").fancytree({
            extensions: ["dnd", "filter"],
            source: tree,
            modifyChild: function(event, data) {
                if (data && data.operation === "remove") {
                    org.ekstep.services.telemetryService.interact({ "type": 'click', "subtype": 'remove', "target": 'node', "pluginid": "org.ekstep.collectioneditor", "pluginver": "1.0", "objectid": data.node.data.id, "stage": data.node.data.id });
                    ecEditor.jQuery("#collection-tree").fancytree("getRootNode").getFirstChild().setActive();
                }
            },
            activate: function(event, data) {
                ecEditor.dispatchEvent('org.ekstep.collectioneditor:node:selected', data.node);
                ecEditor.dispatchEvent('org.ekstep.collectioneditor:node:selected:' + data.node.data.objectType, data.node);
                org.ekstep.services.telemetryService.interact({ "type": 'click', "subtype": 'select', "target": 'node', "pluginid": "org.ekstep.collectioneditor", "pluginver": "1.0", "objectid": data.node.data.id, "stage": data.node.data.id });
            },
            dnd: {
                autoExpandMS: 400,
                focusOnClick: true,
                preventVoidMoves: true, // Prevent dropping nodes 'before self', etc.
                preventRecursiveMoves: true, // Prevent dropping nodes on own descendants
                dragStart: function(node, data) {
                    var config = instance.getConfig();
                    if (config.mode === "Edit") return true;
                    if (config.mode === "Read") return false;
                },
                dragEnter: function(node, data) {
                    return true;
                },
                dragDrop: function(node, data) {
                    if ((data.hitMode === "before" || data.hitMode === "after") && data.node.data.root) return false;
                    if (instance.config.rules && instance.config.rules.levels) return instance._dropNode(node, data);
                },
                filter: {
                    autoApply: true,
                    autoExpand: false,
                    counter: true,
                    fuzzy: false,
                    hideExpandedCounter: true,
                    hideExpanders: false,
                    highlight: true,
                    leavesOnly: false,
                    nodata: true,
                    mode: "dimm"
                }
            },
            renderNode: function(event, data) {
                instance.onRenderNode(event, data)
            }
        });
        var node = ecEditor.jQuery("#collection-tree").fancytree("getRootNode");
        //node.sortChildren(null, true);
        node.getFirstChild().setActive(); //select the first node by default
    },
    _dropNode: function(node, data) {
        var instance = this,
            objectType;
        if ((data.otherNode.getLevel() === node.getLevel()) && data.hitMode === "over") {
            ecEditor.dispatchEvent("org.ekstep.toaster:warning", {
                title: 'This operation is not allowed!',
                position: 'topCenter',
                icon: 'fa fa-warning'
            });
            return false;
        } else if (data.otherNode.getLevel() === node.getLevel()) {
            objectType = node.getParent().data.objectType;
        } else if ((instance.maxTreeDepth(data.otherNode) + node.getLevel()) > instance.config.rules.levels) {
            ecEditor.dispatchEvent("org.ekstep.toaster:warning", {
                title: 'This operation is not allowed!',
                position: 'topCenter',
                icon: 'fa fa-warning'
            });
            return false;
        } else if (data.hitMode === "before" || data.hitMode === "after") {
            objectType = node.getParent().data.objectType;
        } else {
            objectType = node.data.objectType;
        };

        var dropAllowed = _.includes(instance.getObjectType(objectType).childrenTypes, data.otherNode.data.objectType);
        if (dropAllowed) {
            data.otherNode.moveTo(node, data.hitMode);
            org.ekstep.services.telemetryService.interact({ "type": 'click', "subtype": 'dragndrop', "target": 'node', "pluginid": "org.ekstep.collectioneditor", "pluginver": "1.0", "objectid": data.node.data.id, "stage": data.node.data.id });
            ecEditor.dispatchEvent("org.ekstep.collectioneditor:node:reorder", { src: data.otherNode.data.id, dst: data.node.data.id });
            return true;
        } else {
            ecEditor.dispatchEvent("org.ekstep.toaster:warning", {
                title: "\"" + data.otherNode.title + "\"" + " cannot be added to " + "\"" + data.node.title + "\"",
                position: 'topCenter',
                icon: 'fa fa-warning'
            });
            return false;
        }
    },
    onRenderNode: function(event, data, force) {
        var instance = this;
        var node = data.node;
        var $nodeSpan = $(node.span);
        var config = this.config;
        var objectType = this.getObjectType(data.node.data.objectType);
        // for read mode do not add context menu on node
        if (config.mode === "Read" || _.isEmpty(objectType)) return;
        // limit adding nodes depending on config levels for nested stucture
        if (((!$nodeSpan.data('rendered') || force) && data.node.getLevel() >= config.rules.levels) || (!$nodeSpan.data('rendered') && objectType.childrenTypes.length == 0)) {
            var contextButton = $('<span style="padding-left: 20px;left: 65%;"><i class="fa fa-trash-o" onclick="org.ekstep.services.collectionService.removeNode()"></i></span>');
            $nodeSpan.append(contextButton);
            contextButton.hide();
            $nodeSpan.hover(function() { contextButton.show(); }, function() { contextButton.hide(); });
            $nodeSpan.data('rendered', true);
        }

        if ((!$nodeSpan.data('rendered') || force) && (objectType.childrenTypes.length > 0)) {
            if (org.ekstep.services.collectionService.getContextMenuTemplate(data.node)) {
                var contextButton = $(org.ekstep.services.collectionService.getContextMenuTemplate(data.node));
                $nodeSpan.append(contextButton);
                $nodeSpan.hover(function() { contextButton.show(); }, function() { contextButton.hide(); });
                $nodeSpan.data('rendered', true);
                contextButton.hide();
                instance.initContextMenuDropDown();
            }
        }
    },
    initContextMenuDropDown: function() {
        setTimeout(function() {
            ecEditor.jQuery('.ui.inline.dropdown').dropdown({ on: 'hover' });
        }, 200);
    },
    getObjectType: function(type) {
        return _.find(this.config.rules.objectTypes, function(obj) {
            return obj.type === type
        });
    },
    fromCollection: function(data) {
        var treeData = this._buildTree(data);
        var instance = this;
        this.addTree([{
            "id": data.identifier || UUID(),
            "title": (data.name.length > 22) ? data.name.substring(0,22)+'...' : data.name,
            "objectType": data.contentType,
            "metadata": _.omit(data, ["children", "collections"]),
            "folder": true,
            "children": treeData,
            "root": true,
            "icon": instance.getObjectType(data.contentType).iconClass
        }]);
    },
    _buildTree: function(data, tree) {
        var instance = this,
            tree = tree || [];
        if (data.children) data.children = _.sortBy(data.children, ['index']);
        _.forEach(data.children, function(child) {
            var objectType = instance.getObjectType(child.contentType);
            var childTree = [];
            if (objectType) {
                tree.push({
                    "id": child.identifier || UUID(),
                    "title": (child.name.length > 22) ? child.name.substring(0,22)+'...' : child.name,
                    "objectType": child.contentType,
                    "metadata": _.omit(child, ["children", "collections"]),
                    "folder": (objectType.childrenTypes.length > 0),
                    "children": childTree,
                    "root": false,
                    "icon": instance.getObjectType(child.contentType).iconClass
                });
                if (objectType.childrenTypes.length > 0) {
                    instance._buildTree(child, childTree);
                }
            }
        });

        return tree;
    },
    getCollectionHierarchy: function() {
        var instance = this;
        this.data = {};
        var data = ecEditor.jQuery("#collection-tree").fancytree("getRootNode").getFirstChild();
        return {
            nodesModified: org.ekstep.collectioneditor.cache.nodesModified,
            hierarchy: instance._toFlatObj(data)
        };
    },
    _toFlatObj: function(data) {
        var instance = this;                
        if (data && data.data) {
            instance.data[data.data.id] = {
                "name": data.title,
                "contentType": data.data.objectType,
                "children": ecEditor._.map(data.children, function(child) {
                    return child.data.id
                }),
                "root": data.data.root
            }

            ecEditor._.forEach(data.children, function(collection) {
                instance._toFlatObj(collection);
            });
        }

        return instance.data;
    },
    maxTreeDepth: function(root) {
        var buffer = [{ node: root, depth: 1 }];
        var current = buffer.pop();
        var max = 0;

        while (current && current.node) {
            // Find all children of this node.
            _.forEach(current.node.children, function(child) {
                buffer.push({ node: child, depth: current.depth + 1 });
            });
            if (current.depth > max) max = current.depth;
            current = buffer.pop();
        }
        return max;
    },
    clearCache: function() {
        org.ekstep.collectioneditor.cache = {
            hierarchy: {},
            nodesModified: {}
        }
    },
    __telemetry: function(data) {
        org.ekstep.services.telemetryService.interact({ "type": 'click', "subtype": data.subtype, "target": data.target, "pluginid": "org.ekstep.collectioneditor", "pluginver": "1.0", "objectid": ecEditor.getCurrentStage().id, "stage": ecEditor.getCurrentStage().id });
    }
}));

/**
 * @author Santhosh Vasabhaktula <santhosh@ilimi.in>
 */
'use strict';

angular.module('editorApp', ['ngDialog', 'oc.lazyLoad', 'Scope.safeApply']).config(['$locationProvider', function($locationProvider) {
    $locationProvider.html5Mode({
        enabled: true,
        requireBase: false
    });
}]);
angular.module('editorApp').controller('popupController', ['ngDialog', '$ocLazyLoad', function(ngDialog, $ocLazyLoad) {
    function loadNgModules(templatePath, controllerPath) {
        return $ocLazyLoad.load([
            { type: 'html', path: templatePath },
            { type: 'js', path: controllerPath }
        ]);
    };

    function openModal(config, callback) {
        if (config && callback) config.preCloseCallback = callback;
        if (config) ngDialog.open(config);
    };
    org.ekstep.contenteditor.api.getService('popup').initService(loadNgModules, openModal);
}]);
angular.module('editorApp').controller('MainCtrl', ['$scope', '$ocLazyLoad', '$location',
    function($scope, $ocLazyLoad, $location) { 

        $scope.loadNgModules = function(templatePath, controllerPath) {
            var files = [];
            if (templatePath) files.push({ type: 'html', path: templatePath });
            if (controllerPath) files.push({ type: 'js', path: controllerPath });
            if (files.length) return $ocLazyLoad.load(files)
        };  

        org.ekstep.contenteditor.containerManager.initialize({loadNgModules: $scope.loadNgModules, scope: $scope });
        org.ekstep.collectioneditor.metaPageManager.initialize({loadNgModules: $scope.loadNgModules });

        // container scope starts
        $scope.editorContainer = undefined;
        $scope.addToContainer = function(container) {
            $scope.editorContainer = container;
            $scope.$safeApply();            
        }
        // container scope ends

        document.title = 'Collection-Editor';

        /** Initialize base editor */
        var context = org.ekstep.contenteditor.getWindowContext();
        context.uid = context.user ? context.user.id : context.uid;
        context.etags = context.etags || {};
        context.etags.app = context.app || context.etags.app || [];
        context.etags.partner = context.partner || context.etags.partner || [];
        context.etags.dims = context.dims || context.etags.dims || [];
        
        var config = org.ekstep.contenteditor.getWindowConfig();
        config.absURL = $location.protocol() + '://' + $location.host() + ':' + $location.port() // Required

        config.collectionEditorPlugins = config.plugins || org.ekstep.contenteditor.config.plugins;
        config.plugins = [        
            { "id": "org.ekstep.collectioneditor", "ver": "1.0", "type": "plugin" }
        ]
        org.ekstep.contenteditor.init(context, config, $scope, undefined, function() {
            $scope.contentService = org.ekstep.contenteditor.api.getService(ServiceConstants.CONTENT_SERVICE);            
            $scope.popupService = org.ekstep.contenteditor.api.getService(ServiceConstants.POPUP_SERVICE);            
        });           
    }
]);

angular.module('editorApp').directive('compilehtml', ['$compile', function($compile) {
    return {
        restrict: 'A',
        replace: true,        
        link: function(scope, ele, attrs) {
            scope.$watch(attrs.compilehtml, function(html) {
                ele.html(html);
                $compile(ele.contents())(scope);
            });           
        }
    };
}]);
