// https://tc39.github.io/ecma262/#sec-array.prototype.find
//source: https://github.com/Modernizr/Modernizr/wiki/HTML5-Cross-Browser-Polyfills


/*
compiled by <sunils@ilimi.in> Sunil A S

Polyfill for Array:
1. find
2. filter
3. forEach
4. every
5. indexOf
6. map
7. lastIndexOf
8. reduce
9. reduceRight
10. isArray

*/
if (!Array.prototype.find) {
  Object.defineProperty(Array.prototype, 'find', {
    value: function(predicate) {
     // 1. Let O be ? ToObject(this value).
      if (this == null) {
        throw new TypeError('"this" is null or not defined');
      }

      var o = Object(this);

      // 2. Let len be ? ToLength(? Get(O, "length")).
      var len = o.length >>> 0;

      // 3. If IsCallable(predicate) is false, throw a TypeError exception.
      if (typeof predicate !== 'function') {
        throw new TypeError('predicate must be a function');
      }

      // 4. If thisArg was supplied, let T be thisArg; else let T be undefined.
      var thisArg = arguments[1];

      // 5. Let k be 0.
      var k = 0;

      // 6. Repeat, while k < len
      while (k < len) {
        // a. Let Pk be ! ToString(k).
        // b. Let kValue be ? Get(O, Pk).
        // c. Let testResult be ToBoolean(? Call(predicate, T, « kValue, k, O »)).
        // d. If testResult is true, return kValue.
        var kValue = o[k];
        if (predicate.call(thisArg, kValue, k, o)) {
          return kValue;
        }
        // e. Increase k by 1.
        k++;
      }

      // 7. Return undefined.
      return undefined;
    }
  });
}

if (!Array.prototype.filter) {
  Array.prototype.filter = function(fun/*, thisArg*/) {
    'use strict';

    if (this === void 0 || this === null) {
      throw new TypeError();
    }

    var t = Object(this);
    var len = t.length >>> 0;
    if (typeof fun !== 'function') {
      throw new TypeError();
    }

    var res = [];
    var thisArg = arguments.length >= 2 ? arguments[1] : void 0;
    for (var i = 0; i < len; i++) {
      if (i in t) {
        var val = t[i];

        // NOTE: Technically this should Object.defineProperty at
        //       the next index, as push can be affected by
        //       properties on Object.prototype and Array.prototype.
        //       But that method's new, and collisions should be
        //       rare, so use the more-compatible alternative.
        if (fun.call(thisArg, val, i, t)) {
          res.push(val);
        }
      }
    }

    return res;
  };
}

// Production steps of ECMA-262, Edition 5, 15.4.4.18
// Reference: http://es5.github.io/#x15.4.4.18
if (!Array.prototype.forEach) {

  Array.prototype.forEach = function(callback/*, thisArg*/) {

    var T, k;

    if (this == null) {
      throw new TypeError('this is null or not defined');
    }

    // 1. Let O be the result of calling toObject() passing the
    // |this| value as the argument.
    var O = Object(this);

    // 2. Let lenValue be the result of calling the Get() internal
    // method of O with the argument "length".
    // 3. Let len be toUint32(lenValue).
    var len = O.length >>> 0;

    // 4. If isCallable(callback) is false, throw a TypeError exception. 
    // See: http://es5.github.com/#x9.11
    if (typeof callback !== 'function') {
      throw new TypeError(callback + ' is not a function');
    }

    // 5. If thisArg was supplied, let T be thisArg; else let
    // T be undefined.
    if (arguments.length > 1) {
      T = arguments[1];
    }

    // 6. Let k be 0
    k = 0;

    // 7. Repeat, while k < len
    while (k < len) {

      var kValue;

      // a. Let Pk be ToString(k).
      //    This is implicit for LHS operands of the in operator
      // b. Let kPresent be the result of calling the HasProperty
      //    internal method of O with argument Pk.
      //    This step can be combined with c
      // c. If kPresent is true, then
      if (k in O) {

        // i. Let kValue be the result of calling the Get internal
        // method of O with argument Pk.
        kValue = O[k];

        // ii. Call the Call internal method of callback with T as
        // the this value and argument list containing kValue, k, and O.
        callback.call(T, kValue, k, O);
      }
      // d. Increase k by 1.
      k++;
    }
    // 8. return undefined
  };
}


if (!Array.prototype.every) {
  Array.prototype.every = function(callbackfn, thisArg) {
    'use strict';
    var T, k;

    if (this == null) {
      throw new TypeError('this is null or not defined');
    }

    // 1. Let O be the result of calling ToObject passing the this 
    //    value as the argument.
    var O = Object(this);

    // 2. Let lenValue be the result of calling the Get internal method
    //    of O with the argument "length".
    // 3. Let len be ToUint32(lenValue).
    var len = O.length >>> 0;

    // 4. If IsCallable(callbackfn) is false, throw a TypeError exception.
    if (typeof callbackfn !== 'function') {
      throw new TypeError();
    }

    // 5. If thisArg was supplied, let T be thisArg; else let T be undefined.
    if (arguments.length > 1) {
      T = thisArg;
    }

    // 6. Let k be 0.
    k = 0;

    // 7. Repeat, while k < len
    while (k < len) {

      var kValue;

      // a. Let Pk be ToString(k).
      //   This is implicit for LHS operands of the in operator
      // b. Let kPresent be the result of calling the HasProperty internal 
      //    method of O with argument Pk.
      //   This step can be combined with c
      // c. If kPresent is true, then
      if (k in O) {

        // i. Let kValue be the result of calling the Get internal method
        //    of O with argument Pk.
        kValue = O[k];

        // ii. Let testResult be the result of calling the Call internal method
        //     of callbackfn with T as the this value and argument list 
        //     containing kValue, k, and O.
        var testResult = callbackfn.call(T, kValue, k, O);

        // iii. If ToBoolean(testResult) is false, return false.
        if (!testResult) {
          return false;
        }
      }
      k++;
    }
    return true;
  };
}


// Production steps of ECMA-262, Edition 5, 15.4.4.14
// Reference: http://es5.github.io/#x15.4.4.14
if (!Array.prototype.indexOf) {
  Array.prototype.indexOf = function(searchElement, fromIndex) {

    var k;

    // 1. Let o be the result of calling ToObject passing
    //    the this value as the argument.
    if (this == null) {
      throw new TypeError('"this" is null or not defined');
    }

    var o = Object(this);

    // 2. Let lenValue be the result of calling the Get
    //    internal method of o with the argument "length".
    // 3. Let len be ToUint32(lenValue).
    var len = o.length >>> 0;

    // 4. If len is 0, return -1.
    if (len === 0) {
      return -1;
    }

    // 5. If argument fromIndex was passed let n be
    //    ToInteger(fromIndex); else let n be 0.
    var n = fromIndex | 0;

    // 6. If n >= len, return -1.
    if (n >= len) {
      return -1;
    }

    // 7. If n >= 0, then Let k be n.
    // 8. Else, n<0, Let k be len - abs(n).
    //    If k is less than 0, then let k be 0.
    k = Math.max(n >= 0 ? n : len - Math.abs(n), 0);

    // 9. Repeat, while k < len
    while (k < len) {
      // a. Let Pk be ToString(k).
      //   This is implicit for LHS operands of the in operator
      // b. Let kPresent be the result of calling the
      //    HasProperty internal method of o with argument Pk.
      //   This step can be combined with c
      // c. If kPresent is true, then
      //    i.  Let elementK be the result of calling the Get
      //        internal method of o with the argument ToString(k).
      //   ii.  Let same be the result of applying the
      //        Strict Equality Comparison Algorithm to
      //        searchElement and elementK.
      //  iii.  If same is true, return k.
      if (k in o && o[k] === searchElement) {
        return k;
      }
      k++;
    }
    return -1;
  };
}

// Production steps of ECMA-262, Edition 5, 15.4.4.19
// Reference: http://es5.github.io/#x15.4.4.19
if (!Array.prototype.map) {

  Array.prototype.map = function(callback/*, thisArg*/) {

    var T, A, k;

    if (this == null) {
      throw new TypeError('this is null or not defined');
    }

    // 1. Let O be the result of calling ToObject passing the |this| 
    //    value as the argument.
    var O = Object(this);

    // 2. Let lenValue be the result of calling the Get internal 
    //    method of O with the argument "length".
    // 3. Let len be ToUint32(lenValue).
    var len = O.length >>> 0;

    // 4. If IsCallable(callback) is false, throw a TypeError exception.
    // See: http://es5.github.com/#x9.11
    if (typeof callback !== 'function') {
      throw new TypeError(callback + ' is not a function');
    }

    // 5. If thisArg was supplied, let T be thisArg; else let T be undefined.
    if (arguments.length > 1) {
      T = arguments[1];
    }

    // 6. Let A be a new array created as if by the expression new Array(len) 
    //    where Array is the standard built-in constructor with that name and 
    //    len is the value of len.
    A = new Array(len);

    // 7. Let k be 0
    k = 0;

    // 8. Repeat, while k < len
    while (k < len) {

      var kValue, mappedValue;

      // a. Let Pk be ToString(k).
      //   This is implicit for LHS operands of the in operator
      // b. Let kPresent be the result of calling the HasProperty internal 
      //    method of O with argument Pk.
      //   This step can be combined with c
      // c. If kPresent is true, then
      if (k in O) {

        // i. Let kValue be the result of calling the Get internal 
        //    method of O with argument Pk.
        kValue = O[k];

        // ii. Let mappedValue be the result of calling the Call internal 
        //     method of callback with T as the this value and argument 
        //     list containing kValue, k, and O.
        mappedValue = callback.call(T, kValue, k, O);

        // iii. Call the DefineOwnProperty internal method of A with arguments
        // Pk, Property Descriptor
        // { Value: mappedValue,
        //   Writable: true,
        //   Enumerable: true,
        //   Configurable: true },
        // and false.

        // In browsers that support Object.defineProperty, use the following:
        // Object.defineProperty(A, k, {
        //   value: mappedValue,
        //   writable: true,
        //   enumerable: true,
        //   configurable: true
        // });

        // For best browser support, use the following:
        A[k] = mappedValue;
      }
      // d. Increase k by 1.
      k++;
    }

    // 9. return A
    return A;
  };
}

// Production steps of ECMA-262, Edition 5, 15.4.4.15
// Reference: http://es5.github.io/#x15.4.4.15
if (!Array.prototype.lastIndexOf) {
  Array.prototype.lastIndexOf = function(searchElement /*, fromIndex*/) {
    'use strict';

    if (this === void 0 || this === null) {
      throw new TypeError();
    }

    var n, k,
      t = Object(this),
      len = t.length >>> 0;
    if (len === 0) {
      return -1;
    }

    n = len - 1;
    if (arguments.length > 1) {
      n = Number(arguments[1]);
      if (n != n) {
        n = 0;
      }
      else if (n != 0 && n != (1 / 0) && n != -(1 / 0)) {
        n = (n > 0 || -1) * Math.floor(Math.abs(n));
      }
    }

    for (k = n >= 0 ? Math.min(n, len - 1) : len - Math.abs(n); k >= 0; k--) {
      if (k in t && t[k] === searchElement) {
        return k;
      }
    }
    return -1;
  };
}

// Production steps of ECMA-262, Edition 5, 15.4.4.21
// Reference: http://es5.github.io/#x15.4.4.21
// https://tc39.github.io/ecma262/#sec-array.prototype.reduce
if (!Array.prototype.reduce) {
  Object.defineProperty(Array.prototype, 'reduce', {
    value: function(callback /*, initialValue*/) {
      if (this === null) {
        throw new TypeError( 'Array.prototype.reduce ' + 
          'called on null or undefined' );
      }
      if (typeof callback !== 'function') {
        throw new TypeError( callback +
          ' is not a function');
      }

      // 1. Let O be ? ToObject(this value).
      var o = Object(this);

      // 2. Let len be ? ToLength(? Get(O, "length")).
      var len = o.length >>> 0; 

      // Steps 3, 4, 5, 6, 7      
      var k = 0; 
      var value;

      if (arguments.length >= 2) {
        value = arguments[1];
      } else {
        while (k < len && !(k in o)) {
          k++; 
        }

        // 3. If len is 0 and initialValue is not present,
        //    throw a TypeError exception.
        if (k >= len) {
          throw new TypeError( 'Reduce of empty array ' +
            'with no initial value' );
        }
        value = o[k++];
      }

      // 8. Repeat, while k < len
      while (k < len) {
        // a. Let Pk be ! ToString(k).
        // b. Let kPresent be ? HasProperty(O, Pk).
        // c. If kPresent is true, then
        //    i.  Let kValue be ? Get(O, Pk).
        //    ii. Let accumulator be ? Call(
        //          callbackfn, undefined,
        //          « accumulator, kValue, k, O »).
        if (k in o) {
          value = callback(value, o[k], k, o);
        }

        // d. Increase k by 1.      
        k++;
      }

      // 9. Return accumulator.
      return value;
    }
  });
}

// Production steps of ECMA-262, Edition 5, 15.4.4.22
// Reference: http://es5.github.io/#x15.4.4.22
if ('function' !== typeof Array.prototype.reduceRight) {
  Array.prototype.reduceRight = function(callback /*, initialValue*/) {
    'use strict';
    if (null === this || 'undefined' === typeof this) {
      throw new TypeError('Array.prototype.reduce called on null or undefined');
    }
    if ('function' !== typeof callback) {
      throw new TypeError(callback + ' is not a function');
    }
    var t = Object(this), len = t.length >>> 0, k = len - 1, value;
    if (arguments.length >= 2) {
      value = arguments[1];
    } else {
      while (k >= 0 && !(k in t)) {
        k--;
      }
      if (k < 0) {
        throw new TypeError('Reduce of empty array with no initial value');
      }
      value = t[k--];
    }
    for (; k >= 0; k--) {
      if (k in t) {
        value = callback(value, t[k], k, t);
      }
    }
    return value;
  };
}

if (!Array.isArray) {
  Array.isArray = function(arg) {
    return Object.prototype.toString.call(arg) === '[object Array]';
  };
}
/* Simple JavaScript Inheritance
 * By John Resig http://ejohn.org/
 * MIT Licensed.
 */
// Inspired by base2 and Prototype
(function() {
    /* istanbul ignore next */
    var initializing = false,
        fnTest = /xyz/.test(function() {
            xyz;
        }) ? /\b_super\b/ : /.*/;

    // The base Class implementation (does nothing)
    this.Class = function() {};

    // Create a new Class that inherits from this class
    Class.extend = function(prop) {
        var _super = this.prototype;

        // Instantiate a base class (but only create the instance,
        // don't run the init constructor)
        initializing = true;
        var prototype = new this();
        initializing = false;

        // Copy the properties over onto the new prototype
        for (var name in prop) {
            // Check if we're overwriting an existing function
            prototype[name] = typeof prop[name] == "function" &&
                typeof _super[name] == "function" && fnTest.test(prop[name]) ?
                (function(name, fn) {
                    return function() {
                        var tmp = this._super;

                        // Add a new ._super() method that is the same method
                        // but on the super-class
                        this._super = _super[name];

                        // The method only need to be bound temporarily, so we
                        // remove it when we're done executing
                        var ret = fn.apply(this, arguments);
                        this._super = tmp;

                        return ret;
                    };
                })(name, prop[name]) :
                prop[name];
        }

        // The dummy class constructor
        function Class() {
            // All construction is actually done in the init method
            if (!initializing && this.init)
                this.init.apply(this, arguments);
        }

        // Populate our constructed prototype object
        Class.prototype = prototype;

        // Enforce the constructor to be what we expect
        Class.prototype.constructor = Class;

        // And make this class extendable
        Class.extend = arguments.callee;

        return Class;
    };
})();

(function(root,factory){if(typeof exports==="object"&&typeof module==="object")module.exports=factory();else if(typeof define==="function"&&define.amd)define("EventBus",[],factory);else if(typeof exports==="object")exports["EventBus"]=factory();else root["EventBus"]=factory()})(this,function(){var EventBusClass={};EventBusClass=function(){this.listeners={}};EventBusClass.prototype={addEventListener:function(type,callback,scope){var args=[];var numOfArgs=arguments.length;for(var i=0;i<numOfArgs;i++){args.push(arguments[i])}args=args.length>3?args.splice(3,args.length-1):[];if(typeof this.listeners[type]!="undefined"){this.listeners[type].push({scope:scope,callback:callback,args:args})}else{this.listeners[type]=[{scope:scope,callback:callback,args:args}]}},removeEventListener:function(type,callback,scope){if(typeof this.listeners[type]!="undefined"){var numOfCallbacks=this.listeners[type].length;var newArray=[];for(var i=0;i<numOfCallbacks;i++){var listener=this.listeners[type][i];if(listener.scope==scope&&listener.callback==callback){}else{newArray.push(listener)}}this.listeners[type]=newArray}},hasEventListener:function(type,callback,scope){if(typeof this.listeners[type]!="undefined"){var numOfCallbacks=this.listeners[type].length;if(callback===undefined&&scope===undefined){return numOfCallbacks>0}for(var i=0;i<numOfCallbacks;i++){var listener=this.listeners[type][i];if((scope?listener.scope==scope:true)&&listener.callback==callback){return true}}}return false},dispatch:function(type,target){var numOfListeners=0;var event={type:type,target:target};var args=[];var numOfArgs=arguments.length;for(var i=0;i<numOfArgs;i++){args.push(arguments[i])}args=args.length>2?args.splice(2,args.length-1):[];args=[event].concat(args);if(typeof this.listeners[type]!="undefined"){var numOfCallbacks=this.listeners[type].length;for(var i=0;i<numOfCallbacks;i++){var listener=this.listeners[type][i];if(listener&&listener.callback){var concatArgs=args.concat(listener.args);listener.callback.apply(listener.scope,concatArgs);numOfListeners+=1}}}},getEvents:function(){var str="";for(var type in this.listeners){var numOfCallbacks=this.listeners[type].length;for(var i=0;i<numOfCallbacks;i++){var listener=this.listeners[type][i];str+=listener.scope&&listener.scope.className?listener.scope.className:"anonymous";str+=" listen for '"+type+"'\n"}}return str}};var EventBus=new EventBusClass;return EventBus});
/* mousetrap v1.6.0 craig.is/killing/mice */
(function(r,t,g){function u(a,b,h){a.addEventListener?a.addEventListener(b,h,!1):a.attachEvent("on"+b,h)}function y(a){if("keypress"==a.type){var b=String.fromCharCode(a.which);a.shiftKey||(b=b.toLowerCase());return b}return k[a.which]?k[a.which]:p[a.which]?p[a.which]:String.fromCharCode(a.which).toLowerCase()}function D(a){var b=[];a.shiftKey&&b.push("shift");a.altKey&&b.push("alt");a.ctrlKey&&b.push("ctrl");a.metaKey&&b.push("meta");return b}function v(a){return"shift"==a||"ctrl"==a||"alt"==a||
"meta"==a}function z(a,b){var h,c,e,g=[];h=a;"+"===h?h=["+"]:(h=h.replace(/\+{2}/g,"+plus"),h=h.split("+"));for(e=0;e<h.length;++e)c=h[e],A[c]&&(c=A[c]),b&&"keypress"!=b&&B[c]&&(c=B[c],g.push("shift")),v(c)&&g.push(c);h=c;e=b;if(!e){if(!n){n={};for(var l in k)95<l&&112>l||k.hasOwnProperty(l)&&(n[k[l]]=l)}e=n[h]?"keydown":"keypress"}"keypress"==e&&g.length&&(e="keydown");return{key:c,modifiers:g,action:e}}function C(a,b){return null===a||a===t?!1:a===b?!0:C(a.parentNode,b)}function c(a){function b(a){a=
a||{};var b=!1,m;for(m in n)a[m]?b=!0:n[m]=0;b||(w=!1)}function h(a,b,m,f,c,h){var g,e,k=[],l=m.type;if(!d._callbacks[a])return[];"keyup"==l&&v(a)&&(b=[a]);for(g=0;g<d._callbacks[a].length;++g)if(e=d._callbacks[a][g],(f||!e.seq||n[e.seq]==e.level)&&l==e.action){var q;(q="keypress"==l&&!m.metaKey&&!m.ctrlKey)||(q=e.modifiers,q=b.sort().join(",")===q.sort().join(","));q&&(q=f&&e.seq==f&&e.level==h,(!f&&e.combo==c||q)&&d._callbacks[a].splice(g,1),k.push(e))}return k}function g(a,b,m,f){d.stopCallback(b,
b.target||b.srcElement,m,f)||!1!==a(b,m)||(b.preventDefault?b.preventDefault():b.returnValue=!1,b.stopPropagation?b.stopPropagation():b.cancelBubble=!0)}function e(a){"number"!==typeof a.which&&(a.which=a.keyCode);var b=y(a);b&&("keyup"==a.type&&x===b?x=!1:d.handleKey(b,D(a),a))}function k(a,c,m,f){function e(c){return function(){w=c;++n[a];clearTimeout(r);r=setTimeout(b,1E3)}}function h(c){g(m,c,a);"keyup"!==f&&(x=y(c));setTimeout(b,10)}for(var d=n[a]=0;d<c.length;++d){var p=d+1===c.length?h:e(f||
z(c[d+1]).action);l(c[d],p,f,a,d)}}function l(a,b,c,f,e){d._directMap[a+":"+c]=b;a=a.replace(/\s+/g," ");var g=a.split(" ");1<g.length?k(a,g,b,c):(c=z(a,c),d._callbacks[c.key]=d._callbacks[c.key]||[],h(c.key,c.modifiers,{type:c.action},f,a,e),d._callbacks[c.key][f?"unshift":"push"]({callback:b,modifiers:c.modifiers,action:c.action,seq:f,level:e,combo:a}))}var d=this;a=a||t;if(!(d instanceof c))return new c(a);d.target=a;d._callbacks={};d._directMap={};var n={},r,x=!1,p=!1,w=!1;d._handleKey=function(a,
c,e){var f=h(a,c,e),d;c={};var k=0,l=!1;for(d=0;d<f.length;++d)f[d].seq&&(k=Math.max(k,f[d].level));for(d=0;d<f.length;++d)f[d].seq?f[d].level==k&&(l=!0,c[f[d].seq]=1,g(f[d].callback,e,f[d].combo,f[d].seq)):l||g(f[d].callback,e,f[d].combo);f="keypress"==e.type&&p;e.type!=w||v(a)||f||b(c);p=l&&"keydown"==e.type};d._bindMultiple=function(a,b,c){for(var d=0;d<a.length;++d)l(a[d],b,c)};u(a,"keypress",e);u(a,"keydown",e);u(a,"keyup",e)}if(r){var k={8:"backspace",9:"tab",13:"enter",16:"shift",17:"ctrl",
18:"alt",20:"capslock",27:"esc",32:"space",33:"pageup",34:"pagedown",35:"end",36:"home",37:"left",38:"up",39:"right",40:"down",45:"ins",46:"del",91:"meta",93:"meta",224:"meta"},p={106:"*",107:"+",109:"-",110:".",111:"/",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'"},B={"~":"`","!":"1","@":"2","#":"3",$:"4","%":"5","^":"6","&":"7","*":"8","(":"9",")":"0",_:"-","+":"=",":":";",'"':"'","<":",",">":".","?":"/","|":"\\"},A={option:"alt",command:"meta","return":"enter",
escape:"esc",plus:"+",mod:/Mac|iPod|iPhone|iPad/.test(navigator.platform)?"meta":"ctrl"},n;for(g=1;20>g;++g)k[111+g]="f"+g;for(g=0;9>=g;++g)k[g+96]=g;c.prototype.bind=function(a,b,c){a=a instanceof Array?a:[a];this._bindMultiple.call(this,a,b,c);return this};c.prototype.unbind=function(a,b){return this.bind.call(this,a,function(){},b)};c.prototype.trigger=function(a,b){if(this._directMap[a+":"+b])this._directMap[a+":"+b]({},a);return this};c.prototype.reset=function(){this._callbacks={};this._directMap=
{};return this};c.prototype.stopCallback=function(a,b){return-1<(" "+b.className+" ").indexOf(" mousetrap ")||C(b,this.target)?!1:"INPUT"==b.tagName||"SELECT"==b.tagName||"TEXTAREA"==b.tagName||b.isContentEditable};c.prototype.handleKey=function(){return this._handleKey.apply(this,arguments)};c.addKeycodes=function(a){for(var b in a)a.hasOwnProperty(b)&&(k[b]=a[b]);n=null};c.init=function(){var a=c(t),b;for(b in a)"_"!==b.charAt(0)&&(c[b]=function(b){return function(){return a[b].apply(a,arguments)}}(b))};
c.init();r.Mousetrap=c;"undefined"!==typeof module&&module.exports&&(module.exports=c);"function"===typeof define&&define.amd&&define(function(){return c})}})("undefined"!==typeof window?window:null,"undefined"!==typeof window?document:null);

/**
 * @author Santhosh Vasabhaktula <santhosh@ilimi.in>
 */

// Declare Namespace
window.org = { ekstep: {} }

var plugin_framework = function() {};
plugin_framework.prototype.initialize = function(config) {
    config = config || {};
    org.ekstep.pluginframework.config = org.ekstep.pluginframework.config || {};
    if (!config.env) throw "Framework should be initialized with environment!";
    org.ekstep.pluginframework.env = config.env;
    org.ekstep.pluginframework.jQuery = config.jQuery || window.$;
    org.ekstep.pluginframework.async = config.async || window.async;
    org.ekstep.pluginframework.config.build_number = config.build_number || 'BUILD_NUMBER';
    org.ekstep.pluginframework.config.pluginRepo = config.pluginRepo || '/content-plugins';
};

window.org.ekstep.pluginframework = new plugin_framework();
plugin_framework = undefined;

var services_framework = function() {};
window.org.ekstep.services = new services_framework();
services_framework = undefined;
/**
 * @author Harish kumar Gangula<harishg@ilimi.in>
 */
org.ekstep.pluginframework.resourceManager = new(Class.extend({
    init: function() {},
    buildNumber: undefined,
    registeredRepos: [],    
    discoverManifest: function(pluginId, pluginVer, cb, publishedTime) {
        var ayncTasks = [];
        
        if (typeof pluginVer === "number") pluginVer = pluginVer.toFixed(1);

        this.registeredRepos.forEach(function(repo, index) {
            var Fns = function() {
                if (index == 0) {
                    return function(callback) {
                        repo.discoverManifest(pluginId, pluginVer, callback, publishedTime);
                    }
                } else {
                    return function(data, callback) {
                        if (data.manifest == undefined) {
                            repo.discoverManifest(pluginId, pluginVer, callback, publishedTime);
                        } else {
                            callback(null, data);
                        }
                    }
                }
            };

            ayncTasks.push(Fns());
        });

        org.ekstep.pluginframework.async.waterfall(ayncTasks, function(err, result) {
            if (result && result.manifest !== undefined)
                cb(undefined, result);
            else
                cb('Plugin not found in any repo or manifest', undefined);
        });

    },
    addRepo: function(repo, position) {
        var repoFound = this.registeredRepos.find(function(rp) {
            return rp.id == repo.id;
        });

        if (!repoFound) {
            if (typeof position === 'number') this.registeredRepos.splice(position, 0, repo)
            else this.registeredRepos.push(repo);
        } else {
            console.error(repo.id + ': Repo already registered!');
        }
    },
    getResource: function(pluginId, pluginVer, src, dataType, repo, callback, publishedTime) {
        var resource = repo.resolveResource(pluginId, pluginVer, src);
        this.loadResource(resource, dataType, callback, publishedTime);
    },
    loadExternalPluginResource: function(type, pluginId, pluginVer, src, repo, publishedTime, callback) {
        var resource = repo.resolveResource(pluginId, pluginVer, src);
        this.loadExternalResource(resource, type, publishedTime, callback);
    },
    loadExternalResource: function(resource, type, publishedTime, callback) {
        switch (type) {
            case 'js':
                if (callback)
                    this.loadResource(resource, 'script', callback, publishedTime);
                else
                    org.ekstep.pluginframework.jQuery("body").append($("<script type='text/javascript' src=" + resource + "?" + org.ekstep.pluginframework.config.build_number + "&" + (publishedTime || "") + ">"));
                break;
            case 'css':
                org.ekstep.pluginframework.jQuery("head").append("<link rel='stylesheet' type='text/css' href='" + resource + "?" + org.ekstep.pluginframework.config.build_number + "&" + (publishedTime || "") + "'>");
                if (callback) callback();
                break;
            default:
                if (callback) callback();
        }
    },
    loadResource: function(url, dataType, callback, publishedTime) {
        url = url + "?" + (org.ekstep.pluginframework.config ? org.ekstep.pluginframework.config.build_number : '');
        if (publishedTime) {
            url = url + "&" + publishedTime;
        }
        org.ekstep.pluginframework.jQuery.ajax({
            async: false,
            url: url,
            dataType: dataType
        }).done(function(data) {
            callback(null, data);
        }).fail(function(jqXHR, textStatus, errorThrown) {
            if(jqXHR.statusText === 'OK') {
                console.log('Unable to load resource:', url, 'error:', errorThrown);
            }
            callback(errorThrown)
        });
    }
}));

/**
 * @author Santhosh Vasabhaktula <santhosh@ilimi.in>
 */
org.ekstep.pluginframework.eventManager = new (Class.extend({
	enableEvents: true,
	addEventListener: function(type, callback, scope) {
		EventBus.addEventListener(type, callback, scope)
	},
	dispatchEvent: function(type, data, target) {
		if(this.enableEvents) EventBus.dispatch(type, target, data);
	},
	removeEventListener: function(type, callback, scope) {
		EventBus.removeEventListener(type, callback, scope);
	}
}));
/**
 * @author Santhosh Vasabhaktula <santhosh@ilimi.in>
 */
org.ekstep.pluginframework.pluginManager = new(Class.extend({
    pluginManifests: {},
    plugins: {},
    pluginObjs: {},
    pluginInstances: {},
    errors: [],
    init: function() {        
        console.log("Plugin manager initialized");        
    },
    _registerPlugin: function(pluginId, pluginVer, plugin, manifest, repo) {
        this.plugins[pluginId] = { p: plugin, m: manifest, repo: repo };
        this._registerNameSpace(pluginId, plugin);
        if (manifest) this.pluginManifests[manifest.id] =  { m: manifest, repo: repo };
        org.ekstep.pluginframework.eventManager.dispatchEvent('plugin:load', { plugin: pluginId, version: pluginVer });
        org.ekstep.pluginframework.eventManager.dispatchEvent(pluginId + ':load');
        var p = new plugin(manifest); 
        if (manifest) this.pluginObjs[manifest.id] = p;        
    },
    registerPlugin: function(manifest, plugin, repo) {
        repo = repo || org.ekstep.pluginframework.publishedRepo;
        this._registerPlugin(manifest.id, manifest.ver, plugin, manifest, repo);        
    },
    loadCustomPlugin: function(dependency, callback, publishedTime) {
        var instance = this;
        org.ekstep.pluginframework.resourceManager.loadResource(dependency.src, 'text', function(err, data) {
            if (err) {
                org.ekstep.pluginframework.eventManager.dispatchEvent('plugin:error', { plugin: dependency.id, version: dependency.ver, action: "load", err: err });                
                instance.addError({ error:'Fails to load Customplugin', plugin: dependency.id, version: dependency.ver, action: "load", stackTrace: err })
                console.error('Unable to load editor plugin', 'plugin:' + dependency.id + '-' + dependency.ver, 'resource:', 'Error:', err);
            } else {
                try {
                    if (!instance.isPluginDefined(dependency.id)) {
                        data = eval(data);
                        instance._registerPlugin(dependency.id, undefined, data, undefined, undefined);
                    } else {
                        console.info("Plugin is already registered: ", dependency.id);
                    }
                } catch (e) {
                    org.ekstep.pluginframework.eventManager.dispatchEvent('plugin:error', { plugin: dependency.id, version: dependency.ver, action: "load", err: e });
                    instance.addError({ error:'Fails to load Customplugin', plugin: dependency.id, version: dependency.ver, action: "load", stackTrace: e })
                    console.error("Error while loading plugin", 'plugin:' + dependency.id + '-' + dependency.ver, 'Error:', e);
                }
            }
            callback && callback();
        }, publishedTime);
    },
    loadPluginByManifest: function(manifest, repo, pluginType, publishedTime) {
        var instance = this;
        var scope = org.ekstep.pluginframework.env;        
        if(manifest[scope] && manifest[scope].main) org.ekstep.pluginframework.resourceManager.getResource(manifest.id, manifest.ver, manifest[scope].main, 'text', repo, function(err, data) {
            if (err) {
                org.ekstep.pluginframework.eventManager.dispatchEvent('plugin:error', { plugin: manifest.id, version: manifest.ver, action: "load", err: err });
                instance.addError({error:'Fails to load plugin!', plugin: manifest.id, version: manifest.ver, action: "load", stackTrace: err })
                console.error('Unable to load editor plugin', 'plugin:' + manifest.id + '-' + manifest.ver, 'resource:' + manifest[scope].main, 'Error:', err);
            } else {
                try {
                    if (!instance.isPluginDefined(manifest.id)) {
                        if (pluginType == 'library') {
                            org.ekstep.pluginframework.jQuery.globalEval(data);
                        } else {
                            if (data) instance.registerPlugin(manifest, eval(data), repo);
                        }
                    } else {
                        console.info("Plugin is already registered: ", manifest.id);
                    }
                } catch (e) {
                    org.ekstep.pluginframework.eventManager.dispatchEvent('plugin:error', { plugin: manifest.id, version: manifest.ver, action: "load", err: e });
                    instance.addError({error:'Fails to load plugin!',  plugin: manifest.id, version: manifest.ver, action: "load", stackTrace: e })
                    console.error("Error while loading plugin", 'plugin:' + manifest.id + '-' + manifest.ver, 'Error:', e);
                }
            }
        }, publishedTime);
    },
    _registerNameSpace: function(pluginId, clazz) {
        console.info("Registering namespace for plugin:", pluginId);
        var names = pluginId.split('.')
        var baseNameSpace = names[0];
        var lastKey = names[names.length-1];
        names.splice(0, 1);

        var pluginClazz = (org.ekstep.pluginframework.env === 'editor') ? Class.extend({
            init: function(data, parent, override) {
                org.ekstep.pluginframework.pluginManager.invoke(pluginId, data, parent, override);
            }
        }) : Class.extend({
            init: function(data, parent, stage, theme) {
                org.ekstep.pluginframework.pluginManager.invokeRenderer(pluginId, data, parent, stage, theme);
            }
        });
        pluginClazz.extend = function(subClazz) {
            return clazz.extend(subClazz);
        }

        if(names.length > 0) {
            if (!window[baseNameSpace]) {
                window[baseNameSpace] = {};
            }
            names.reduce(function(o, s) {
                var val = ((s === lastKey) ? pluginClazz : {});
                return (o[s] === undefined) ? o[s] = val : o[s] 
            }, window[baseNameSpace]);
        } else {
            if(window[baseNameSpace] === undefined) window[baseNameSpace] = pluginClazz;
        }
    },
    loadAndInitPlugin: function(pluginId, version, publishedTime, parent) {
        var self = this;
        if (this.isPluginDefined(pluginId)) {
            var pluginManifest = this.getPluginManifest(pluginId);
            if (pluginManifest.type && (pluginManifest.type.toLowerCase() === "widget")) {
                this.invoke(pluginId, JSON.parse(JSON.stringify(pluginManifest[org.ekstep.pluginframework.env]['init-data'] || {})), parent);
            }
        } else {
            this.loadPluginWithDependencies(pluginId, version, undefined, publishedTime, [], function() {
                if (self.isPluginDefined(pluginId)) {
                    var pluginManifest = self.getPluginManifest(pluginId);
                    if (pluginManifest.type && (pluginManifest.type.toLowerCase() === "widget")) {
                        self.invoke(pluginId, JSON.parse(JSON.stringify(pluginManifest[org.ekstep.pluginframework.env]['init-data'] || {})), parent);
                    }
                }
            });
        }
    },
    loadPluginWithDependencies: function(pluginId, pluginVer, pluginType, publishedTime, parents, callback) {
        var instance = this;
        if (this.plugins[pluginId]) {
            console.info('A plugin with id "' + pluginId + '" and ver "' + pluginVer + '" is already loaded');
            callback && callback();
            return;
        }

        if(parents.indexOf(pluginId) != -1) {
            console.warn('Detected a cyclic dependency with the plugin: "' + pluginId + '". Breaking the chain...');
            callback && callback();
            return;
        }

        parents.push(pluginId);
        org.ekstep.pluginframework.resourceManager.discoverManifest(pluginId, pluginVer, function(err, data) {
            if (err || (data == undefined)) {
                org.ekstep.pluginframework.eventManager.dispatchEvent('plugin:error', { plugin: pluginId, version: pluginVer, action: "load", err: err });
                instance.addError({ error: "Manifest not found!", plugin: pluginId, version: pluginVer, action: "discoverManifest", stackTrace: err })
                console.error('Unable to load plugin manifest', 'plugin:' + pluginId + '-' + pluginVer, 'Error:', err);
                callback && callback(); // TODO: probably pass the error
            } else {
                instance.loadManifestDependencies(data.manifest.dependencies, publishedTime, parents, function() {
                    if (!data.manifest.editor || Object.keys(data.manifest.editor).length === 0) {
                        instance.pluginManifests[data.manifest.id] = { m: data.manifest, repo: data.repo };                        
                    }                    
                    var queue = instance.queueDependencies(data.manifest, data.repo, publishedTime, parents);
                    if (queue.length() > 0) {
                        queue.drain = function() {
                            instance.loadPluginByManifest(data.manifest, data.repo, pluginType, publishedTime);
                            callback && callback();
                        };
                    } else {
                        instance.loadPluginByManifest(data.manifest, data.repo, pluginType, publishedTime);
                        callback && callback();
                    }
                });
            }
        }, publishedTime);
    },
    queueDependencies: function(manifest, repo, publishedTime, parents) {
        var scope = org.ekstep.pluginframework.env;
        var queue = org.ekstep.pluginframework.async.queue(function(task, callback) {
            if (task.type == 'plugin') {
                if (org.ekstep.pluginframework.env == 'renderer') {
                    instance.loadCustomPlugin({id: task.plugin, src: task.repo.resolveResource(task.id, task.ver, task.src)}, callback, undefined);
                } else {
                    instance.loadPluginWithDependencies(task.plugin, task.ver, task.type, publishedTime, parents, callback);
                }
            } else {
                org.ekstep.pluginframework.resourceManager.loadExternalPluginResource(task.type, task.id, task.ver, task.src, task.repo, task.publishedTime, callback);
            }
        }, 1);
        var instance = this;
        if (manifest[scope] && Array.isArray(manifest[scope].dependencies)) {
            manifest[scope].dependencies.forEach(function(dependency) {
                if (dependency.type == 'plugin') {
                    if (org.ekstep.pluginframework.env == 'renderer') {
                        queue.push({
                            type: dependency.type,
                            id: manifest.id,
                            ver: manifest.ver,
                            src: dependency.src,
                            repo: repo,
                            plugin: dependency.id
                        }, function() {});
                    } else {
                        queue.push(dependency, function() {});
                    }
                } else if(dependency.type == 'js' || dependency.type == 'css') {
                    queue.push({
                        type: dependency.type,
                        id: manifest.id,
                        ver: manifest.ver,
                        src: dependency.src,
                        repo: repo,
                        publishedTime: publishedTime
                    }, function() {});
                }
            });
        }
        return queue;
    },
    loadManifestDependencies: function(dependencies, publishedTime, parents, callback) {
        var instance = this;
        if (Array.isArray(dependencies) && dependencies.length > 0) {
            var queue = org.ekstep.pluginframework.async.queue(function(plugin, pluginCallback) {
                instance.loadPluginWithDependencies(plugin.id, plugin.ver, plugin.type, plugin.pt, parents, pluginCallback);
            }, 1);
            dependencies.forEach(function(dep) {
                if (org.ekstep.pluginframework.env == 'renderer') {
                    if (dep.scope == org.ekstep.pluginframework.env || dep.scope == 'all') {
                        queue.push({ 'id': dep.plugin, 'ver': dep.ver, 'type': dep.type, 'pt': publishedTime }, function(err) {});
                    }
                } else {
                    queue.push({ 'id': dep.plugin, 'ver': dep.ver, 'type': dep.type, 'pt': publishedTime }, function(err) {});
                }
            });
            if (queue.length() > 0) {
                queue.drain = function() {
                    callback && callback();
                };
            } else {
                callback && callback();
            }
        } else {
            callback && callback();
        }
    },
    isManifestDefined: function(id) {
        if (this.pluginManifests[id]) {
            return true;
        } else {
            return false;
        }
    },
    isPluginDefined: function(id) {
        if (this.plugins[id]) {
            return true;
        } else {
            return false;
        }
    },
    loadPlugin: function(pluginId, pluginVer, callback) {
        this.loadPluginWithDependencies(pluginId, pluginVer, "plugin", undefined, [], function() {
           callback && callback();
        });
    },
    loadAllPlugins: function(plugins, otherDependencies, callback) {
        var instance = this;
        if (Array.isArray(plugins) && plugins.length) {
            var preloadPlugin = plugins.find(function(plugin) {
                return (plugin.preload === true || plugin.preload === 'true');
            });
            if(preloadPlugin) {
                instance.loadPlugin(preloadPlugin.id, preloadPlugin.ver, function() {
                    instance._loadPlugins(plugins, otherDependencies, callback);
                })
            } else {
                instance._loadPlugins(plugins, otherDependencies, callback);
            }
        } else if (Array.isArray(otherDependencies) && otherDependencies.length) {
            instance.loadOtherDependencies(otherDependencies, callback);
        } else {
            callback && callback();
        }
    },
    _loadPlugins: function(plugins, otherDependencies, callback) {
        var instance = this;
        var q = org.ekstep.pluginframework.async.queue(function(plugin, pluginCallback) {
            instance.loadPluginWithDependencies(plugin.id, plugin.ver, plugin.type, plugin.pt, [], pluginCallback);
        }, 6);
        q.drain = function() {
            instance.loadOtherDependencies(otherDependencies, callback);
        };
        plugins.forEach(function(plugin) {
            q.push({ 'id': plugin.id, 'ver': plugin.ver, 'type': plugin.type, 'pt': undefined }, function(err) {});
        });
    },
    loadOtherDependencies: function(otherDependencies, callback) {
        var instance = this;
        if (Array.isArray(otherDependencies) && otherDependencies.length) {
            var queue = org.ekstep.pluginframework.async.queue(function(dependency, cb) {
                if (dependency.type == 'plugin') {
                    instance.loadCustomPlugin(dependency, cb);
                } else {
                    org.ekstep.pluginframework.resourceManager.loadExternalResource(dependency.src, dependency.type, undefined, cb);
                }
            }, 1);
            otherDependencies.forEach(function(dep) {
                queue.push(dep, function(err) {});
            });
            if (queue.length() > 0) {
                queue.drain = function() {
                    callback && callback();
                };
            } else {
                callback && callback();
            }
        } else {
            callback && callback();
        }
    },
    invoke: function(id, data, parent, override) {
        var instance = this;
        var p = undefined;
        var plugin = this.plugins[id];
        if (!plugin) {
            this.addError({error:"Plugin not found!", plugin:id, version:" ", stackTrace:" "});
        } else {
            var pluginClass = override ? plugin.p.extend(override) : plugin.p;
            var pluginManifest = plugin.m;
            try {
                if (Array.isArray(data)) {
                    data.forEach(function(d) {
                        p = new pluginClass(pluginManifest, d, parent);
                        instance.addPluginInstance(p);
                        p.initPlugin();
                        org.ekstep.pluginframework.eventManager.dispatchEvent('plugin:add', { plugin: pluginManifest.id, version: pluginManifest.ver, instanceId: p.id });
                        org.ekstep.pluginframework.eventManager.dispatchEvent(pluginManifest.id + ':add');
                    })
                } else {
                    p = new pluginClass(pluginManifest, data, parent);
                    instance.addPluginInstance(p);
                    p.initPlugin();
                    org.ekstep.pluginframework.eventManager.dispatchEvent('plugin:add', { plugin: pluginManifest.id, version: pluginManifest.ver, instanceId: p.id });
                    org.ekstep.pluginframework.eventManager.dispatchEvent(pluginManifest.id + ':add');
                }
            } catch (e) {
                org.ekstep.pluginframework.eventManager.dispatchEvent('plugin:error', { plugin: pluginManifest.id, version: pluginManifest.ver, action: "invoke", err: e });
                instance.addError({error:"Fails to invoke!", plugin: pluginManifest.id, version: pluginManifest.ver, action: "invoke", stackTrace: e })
                if(p) delete instance.pluginInstances[p.id];
                throw "Error: when instantiating plugin: "+ id;
            }
        }
        return p;
    },
    invokeRenderer: function(id, data, parent, stage, theme) {
        var instance = this;
        var p = undefined;
        var plugin = this.plugins[id];
        if (!plugin) {
            this.addError({error: "Plugin not found!", plugin:id, version:" ", stackTrace:" "});
        } else {
            try {
                var pluginClass = plugin.p;
                var pluginManifest = plugin.m || { id: id, ver: undefined };
                if (Array.isArray(data)) {
                    data.forEach(function(d) {
                        p = new pluginClass(d, parent, stage, theme);
                        instance.addPluginInstance(p);
                        org.ekstep.pluginframework.eventManager.dispatchEvent('plugin:add', { plugin: pluginManifest.id, version: pluginManifest.ver, instanceId: p.id });
                        org.ekstep.pluginframework.eventManager.dispatchEvent(pluginManifest.id + ':add');
                    })
                } else {
                    p = new pluginClass(data, parent, stage, theme);
                    instance.addPluginInstance(p);
                    org.ekstep.pluginframework.eventManager.dispatchEvent('plugin:add', { plugin: pluginManifest.id, version: pluginManifest.ver, instanceId: p.id });
                    org.ekstep.pluginframework.eventManager.dispatchEvent(pluginManifest.id + ':add');
                }
            } catch (e) {
                org.ekstep.pluginframework.eventManager.dispatchEvent('plugin:error', { plugin: pluginManifest.id, version: pluginManifest.ver, action: "invoke", err: e });
                instance.addError({ error:'Fails to invoke!', plugin: pluginManifest.id, version: pluginManifest.ver, action: "invoke", stackTrace: e })
                if(p) delete instance.pluginInstances[p.id];
                throw "Error: when instantiating plugin: "+ id;
            }
        }
        return p;
    },
    addPluginInstance: function(pluginObj) {
        this.pluginInstances[pluginObj.id] = pluginObj;
    },
    removePluginInstance: function(pluginObj) {        
        if (pluginObj) pluginObj.remove();
    },
    getPluginInstance: function(id) {
        return this.pluginInstances[id];
    },
    getPluginInstances: function() {
        return this.pluginInstances;
    },
    getPluginManifest: function(id) {
        var plugin = this.plugins[id] || this.pluginManifests[id];
        if (plugin) {
            return plugin.m;
        } else {
            return undefined;
        }
    },
    addError: function(error) {
        this.errors.push(error);
    },
    getErrors: function() {
        return this.errors;
    },
    cleanUp: function() {
        this.pluginInstances = {};
        this.pluginManifests = {};
        this.plugins = {};
        this.errors = [];
    },
    getPlugins: function() {
        return Object.keys(this.plugins);
    },
    getPluginType: function(id) {
        if (this.pluginInstances[id]) {
            return this.pluginInstances[id].getType();
        } else {
            return '';
        }
    },
    loadPluginResource: function(pluginId, pluginVer, src, dataType, callback) {
        if (this.plugins[pluginId]) {
            org.ekstep.pluginframework.resourceManager.getResource(pluginId, pluginVer, src, dataType, this.plugins[pluginId]['repo'], callback)
        } else {
            callback(new Error("unable load plugin resource " + src), undefined)
        }
    },
    getPluginVersion: function(id) {
        if (this.pluginInstances[id]) {
            return this.pluginInstances[id].getVersion();
        } else {
            return '';

        }
    },
    resolvePluginResource: function(id, ver, resource) {
        if (this.plugins[id] && this.plugins[id]["repo"]) {
            return this.plugins[id]["repo"].resolveResource(id, ver, resource);
        } else if(this.pluginManifests[id] && this.pluginManifests[id]["repo"]) {
            return this.pluginManifests[id]["repo"].resolveResource(id, ver, resource);
        } else {
            return false;
        }
    }
}));

/**
 * @author Santhosh Vasabhaktula <santhosh@ilimi.in>
 */
org.ekstep.pluginframework.keyboardManager = new (Class.extend({
	registry: {},
	registerKeyCombination: function(command, callback) {
		if(command !== undefined && callback !== undefined){
			Mousetrap.bind(command, callback);
		} else {
			throw "The given key combination is invalid.";
		}
	}
}));
/* istanbul ignore next */
org.ekstep.services.iService = Class.extend({
    /** 
     * @member {object} requestHeaders
     * @memberof org.ekstep.services.iService
     */
    requestHeaders: {
        "headers": {
            "content-type": "application/json",
            "user-id": "content-editor"
        }
    },
    getBaseURL: function() {
        return org.ekstep.services.config.baseURL;
    },
    getAPISlug: function() {
        return org.ekstep.services.config.apislug;
    },
    getConfig: function(configKey, _default) {
        return org.ekstep.services.config[configKey] || _default;
    },
    init: function(config) {
        this.initService(config);
    },
    initService: function(config) {},                
    _dispatchTelemetry: function(data) {
        var status = data.res.responseCode || data.res.statusText;
        org.ekstep.services.telemetryService.apiCall({ "path": encodeURIComponent(data.url), "method": data.method, "request": data.request, "response": "", "responseTime": data.res.responseTime, "status": status, "uip": "" });
    },
    _call: function(ajaxSettings, config, cb) {
        
        var requestTimestamp, instance = this;
        config = config || {};
        ajaxSettings.headers = config.headers || {};
        ajaxSettings.beforeSend = function(xhrObject, settings) {
            requestTimestamp = (new Date()).getTime();
        }
        ajaxSettings.success = function(res) {
            res.responseTime = (new Date()).getTime() - requestTimestamp;
            var request = ajaxSettings.type === 'POST' ? ajaxSettings.data : {};
            instance._dispatchTelemetry({url: ajaxSettings.url, method: ajaxSettings.type, request: request, res: res }); 
            res = { data: res };
            cb(null, res);                
        }
        ajaxSettings.error = function(err) {
            err.responseTime = (new Date()).getTime() - requestTimestamp;
            cb(err, null);
            var request = ajaxSettings.type === 'POST' ? ajaxSettings.data : {};
            instance._dispatchTelemetry({url: ajaxSettings.url, method: ajaxSettings.type, request: request, res: err });
        }

        if (!_.isUndefined(config.contentType)) ajaxSettings.contentType = config.contentType;
        if (!_.isUndefined(config.cache)) ajaxSettings.cache = config.cache;
        if (!_.isUndefined(config.processData)) ajaxSettings.processData = config.processData;
        if (!_.isUndefined(config.enctype)) ajaxSettings.enctype = config.enctype;

        org.ekstep.pluginframework.jQuery.ajax(ajaxSettings);
    },
    get: function(url, config, cb) {
        this._call({type: "GET", url: url}, config, cb);
    },
    put: function(url, data, config, cb) {
        if (typeof cb !== 'function') throw "iservice expects callback to be function";
        if (typeof data === 'object' && _.isUndefined(config.contentType)) data = JSON.stringify(data);
        this._call({type: "PUT", url: url, data: data}, config, cb);
    },
    post: function(url, data, config, cb) {
        if (typeof cb !== 'function') throw "iservice expects callback to be function";
        if (typeof data === 'object' && _.isUndefined(config.contentType)) data = JSON.stringify(data);
        this._call({type: "POST", url: url, data: data}, config, cb);
    },
    patch: function(url, data, config, cb) {
        if (typeof cb !== 'function') throw "iservice expects callback to be function";
        if (typeof data === 'object' && _.isUndefined(config.contentType)) data = JSON.stringify(data);
        this._call({type: "PATCH", url: url, data: data}, config, cb);
    },
    delete: function(url, config, cb) {
        if (typeof cb !== 'function') throw "iservice expects callback to be function";
        this._call({type: "DELETE", url: url}, config, cb);
    },
    /**
     * Utility function which is used to call http post request
     * @param  {string}   url      API url
     * @param  {object}   data     APT request data
     * @param  {object}   headers  API headers
     * @param  {Function} callback returns error and response as arguments
     * @memberof org.ekstep.services.iService
     */
    postFromService: function(url, data, headers, callback) {
        this.post(url, data, headers, function(err, res) {
            callback(err, res)
        });
    },
    /**
     * Utility function which is used to call http get request
     * @param  {string}   url      API url
     * @param  {object}   headers  API headers
     * @param  {Function} callback returns error and response as arguments
     * @memberof org.ekstep.services.iService
     */
    getFromService: function(url, headers, callback) {
        this.get(url, headers, function(err, res) {
            callback(err, res);
        });
    }

});

/**
 * Content service helps to retrieve/save the content, content meta details by making call to learning API.
 * It also helps to download the content.
 *
 * @class org.ekstep.services.contentService
 * @author Sunil A S <sunils@ilimi.in>
 */
org.ekstep.services.contentService = new(org.ekstep.services.iService.extend({
    serviceURL: function() {
        return this.getBaseURL() + this.getAPISlug() + this.getConfig('contentEndPoint', '/content');
    },
    learningURL: function() {
        return this.getBaseURL() + this.getAPISlug() + this.getConfig('learningEndPoint', '/learning');
    },
    content: {},
    initService: function() {},
    /**
     *
     * content meta data fields
     *
     * @memberof org.ekstep.services.contentService
     */
    contentFields: "body,collaborators,editorState,stageIcons,templateId,languageCode,template,gradeLevel,status,concepts,versionKey,name,appIcon,contentType,owner,domain,code,visibility,createdBy,description,language,mediaType,mimeType,osId,languageCode,createdOn,lastUpdatedOn,audience,ageGroup,attributions,artifactUrl,board,subject,keywords,config,resourceType,medium,publisher,year,pkgVersion",
    /**
     *
     * sets content meta for the given content id
     * @param id {string}
     * @param contentMeta {object} content meta object
     * @private
     * @memberof org.ekstep.services.contentService
     */
    _setContentMeta: function(id, contentMeta) {
        /* istanbul ignore else */
        if (id && contentMeta) {
            var meta = {};
            for (k in contentMeta) {
                if (k != 'body' && k != 'stageIcons') {
                    meta[k] = contentMeta[k];
                }
            }
            this.content[id] = meta;
        }
    },
    /**
     *
     * returns content meta details
     * @param id {string} content id
     * @returns {object} if id is "undefined" returns empty object
     *
     * @memberof org.ekstep.services.contentService
     */
    getContentMeta: function(id) {
        return Object.assign({}, this.content[id] || {});
    },
    /**
     *
     * saves content body by making call to learing API
     * @param contentId {string} content id
     * @param metadata {object} meta data object
     * @param body {object} ECML JSON object of content
     * @param callback {function} callback function
     *
     * @memberof org.ekstep.services.contentService
     */
    saveContent: function(contentId, metadata, body, callback) {
        this._saveContent(contentId, metadata, body, callback);
    },
    /**
     *
     * saves content body by making call to learing API
     * @param contentId {string} content id
     * @param metadata {object} meta data object
     * @param body {object} ECML JSON object of content
     * @param callback {function} callback function
     * @private
     * @memberof org.ekstep.services.contentService
     *
     */
    _saveContent: function(contentId, metadata, body, callback) {

        var instance = this;
        var versionKey = instance.content[contentId] && instance.content[contentId].versionKey;

        if (contentId && versionKey) {
            var update = false;
            var content = {
                versionKey: versionKey,
                lastUpdatedBy: ecEditor.getContext('user') && ecEditor.getContext('user').id
            }
            if (metadata) {
                update = true;
                for (k in metadata) {
                    content[k] = metadata[k];
                }
            }
            if (body) {
                content.compatibilityLevel = body.theme.compatibilityVersion;
                content['body'] = JSON.stringify(body);
                update = true;
            }
            if (update) {
                var requestObj = { request: { content: content } };
                instance.patch(this.serviceURL() + this.getConfig('contentUpdateUrl', '/v3/update/') + contentId, requestObj, this.requestHeaders, function(saveContentError, saveContentResponse) {
                    /* istanbul ignore else */
                    if (saveContentResponse && saveContentResponse.data.responseCode == "OK") {
                        instance.content[contentId].versionKey = saveContentResponse.data.result.versionKey;
                        instance.getContent(contentId, function(metaError, metaResponse){
                            metaError &&  console.error("Unable to update the Metadata context after save");
                            callback(undefined, saveContentResponse);
                        })
                    } else {
                        callback(true, saveContentError);
                    }
                });
            } else {
                callback('Nothing to save');
            }
        } else {
            callback('Cannot find content id or version key to update content');
        }
    },
    /**
     *
     *
     * retrieves the content and content meta details
     * @param contentId {string} content id
     * @param callback {function} callback function
     *
     * @memberof org.ekstep.services.contentService
     */
    getContent: function(contentId, callback) {
        var instance = this;
        if (contentId) {
            var metaDataFields = "?mode=edit&fields=" + instance.contentFields;
            instance.get(this.serviceURL() + this.getConfig('contentReadUrl', '/v3/read/') + contentId + metaDataFields, this.requestHeaders, function(err, res) {
                /* istanbul ignore else */                
                if (res && res.data && res.data.responseCode === "OK") {
                    instance._setContentMeta(contentId, res.data.result.content);
                    callback(err, res.data.result.content);
                } else {
                    callback(new Error('no content found!'), undefined)
                }

            });
        } else {
            callback('Content id is required to get content from platform', undefined);
        }
    },
    /**
     *
     *
     * retrieves the versionKey
     * @param contentId {string} content id
     * @param callback {function} callback function
     *
     * @memberof org.ekstep.services.contentService
     */
    getContentVersionKey: function(contentId, callback) {
        var instance = this;
        if (contentId) {
            var metaDataFields = "?mode=edit&fields=" + "versionKey";
            instance.get(this.serviceURL() + this.getConfig('contentReadUrl', '/v3/read/') + contentId + metaDataFields, this.requestHeaders, function(err, res) {
                if (res && res.data && res.data.responseCode === "OK") {
                    instance.getContentMeta(contentId).versionKey = res.data.result.content && res.data.result.content.versionKey;
                    callback(err, res.data.result.content);
                } else {
                    callback(new Error('no content found!'), undefined)
                }
            });
        } else {
            callback('Content id is required to get versionKey from platform', undefined);
        }
    },
    /**
     * retrieves template data of selected templateid
     * @param templateId {string} template id
     * @param callback {function} callback function
     * @memberof org.ekstep.services.contentService
     */
    getTemplateData: function(templateId, callback) {
        var instance = this;
        var templateMetaFields = "?taxonomyId=literacy_v2&fields=body,editorState,templateId,languageCode";
        instance.get(this.serviceURL() + this.getConfig('contentReadUrl', '/v3/read/') + templateId + templateMetaFields, this.requestHeaders, function(err, res) {
            callback(err, res)
        });
    },
    /**
     *
     *
     * retrieves downloadable URL link to content
     * @param contentId {string} content id
     * @param fileName {string} "name" parameter of meta data object
     * @param callback {function} callback function
     *
     * @memberof org.ekstep.services.contentService
     */
    downloadContent: function(contentId, fileName, callback) {
        var data = { "request": { "content_identifiers": [contentId], "file_name": fileName } };
        this.postFromService(this.serviceURL() + this.getConfig('contentBundleUrl', '/v3/bundle'), data, this.requestHeaders, callback);
    },
    /**
     *
     *
     * retrieves collection in hierarchical order
     * @param data {object} "contentId" : String. Content ID to get
     * @param callback {function} callback function
     *
     * @memberof org.ekstep.services.contentService
     */
    getCollectionHierarchy: function(data, callback) {
        var instance = this;
        var metaFields = "fields=versionKey"
        if (data.mode === "edit") metaFields = "mode=edit&" + metaFields;
        this.getFromService(this.serviceURL() + this.getConfig('collectionHierarchyGetUrl', '/v3/hierarchy/') + data.contentId + "?" + metaFields, this.requestHeaders, function(err, res) {            
            if (res && res.data && res.data.responseCode === "OK") {
                instance._setContentMeta(data.contentId, res.data.result.content);
                callback(err, res);
            } else {
                callback(new Error('no content found!'), undefined)
            }
        });
    },
    /**
     * saves collection in hierarchical order
     * @param data {object} "body": Object. content body to save
     * @param callback {function} callback function
     *
     * @memberof org.ekstep.services.contentService
     */
    saveCollectionHierarchy: function(data, callback) {
        //Versionkey not considered for hierarchy patch
        var instance = this;
        if (!data) {
            callback("nothing to save!");        
            return;
        }
        data.body.lastUpdatedBy = ecEditor.getContext('user') && ecEditor.getContext('user').id;
        var requestObj = { request: { data: data.body } };
        this.patch(this.serviceURL() + this.getConfig('collectionHierarchyUpdateUrl', '/v3/hierarchy/update/'), requestObj, this.requestHeaders, function(hierarchyServiceError, hierarchyServiceResponse) {
            if (hierarchyServiceResponse && hierarchyServiceResponse.data.responseCode == "OK") {
                instance.getContent(ecEditor.getContext('contentId'), function(metaError, metaResponse){
                    metaError && console.error("Unable to update the Metadata context after save");
                    callback(undefined, hierarchyServiceResponse);
                })
            } else {
                callback(true, hierarchyServiceError);
            }
        });
    },
    /**
     * Content sent for review call
     * @param data {object} "contentId" : String. Content ID
     * @param callback {function} callback function
     * @memberof org.ekstep.services.contentService
     */
    sendForReview: function(data, callback) {
        var requestObj = {"request":{"content":{}}};
        this.postFromService(this.serviceURL() + this.getConfig('sendfortReviewURL', '/v3/review/') + data.contentId, requestObj, this.requestHeaders, callback);
    },
    /**
     * Content sent for review call
     * @param data {object} "contentId" : String. Content ID
     * @param callback {function} callback function
     * @memberof org.ekstep.services.contentService
     */
    publishContent: function(data, callback) {
        var requestObj = {
            "request": {
                "content" : {
                    "lastPublishedBy" : ecEditor.getContext('uid')
                }
            }
        };
        this.postFromService(this.serviceURL() + this.getConfig('contentPublishURL', '/v3/publish/') + data.contentId, requestObj, this.requestHeaders, callback);
    },
    /**
     * Get pre-signed url for content upload
     * @param data {object} "contentId" : String. Content ID, "fileName" : String. File Name
     * @param callback {function} callback function
     * @memberof org.ekstep.services.contentService
     */
    getPresignedURL: function(contentId, fileName, callback) {
        var requestObj = {
            "request": {
                "content" : {
                    "fileName" : fileName
                }
            }
        };
        this.postFromService(this.serviceURL() + this.getConfig('contentPresignURL', '/v3/upload/url/') + contentId, requestObj, this.requestHeaders, callback);
    },

    /**
     * Upload file to given url
     * @param url {string} String.
     * @param data {file} File Data.
     * @param callback {function} callback function
     * @memberof org.ekstep.services.contentService
     */
    uploadDataToSignedURL: function(url, data, config, callback) {
        this.put(url, data, config, callback);
    },

    /**
     * Content sent for review call
     * @param data {object} "contentId" : String. Content ID
     * @param callback {function} callback function
     * @memberof org.ekstep.services.contentService
     */
    rejectContent: function(data, callback) {
        var requestObj = {"request":{}};
        this.postFromService(this.serviceURL() + this.getConfig('contentRejectURL', '/v3/reject/') + data.contentId, requestObj, this.requestHeaders, callback);

    },
    retireContent: function(data, callback) {
        this.delete(this.serviceURL() + this.getConfig('contentRejectURL', '/v3/retire/') + data.contentId, this.requestHeaders, callback);
    },
    acceptContentFlag: function(data, callback) {
        var requestObj = {"request":{}};
        this.postFromService(this.serviceURL() + this.getConfig('acceptContentFlag', '/v3/flag/accept/') + data.contentId, requestObj, this.requestHeaders, callback);
    },
    discardContentFlag: function(data, callback) {
        var requestObj = {"request":{}};
        this.postFromService(this.serviceURL() + this.getConfig('discardContentFlag', '/v3/flag/reject/') + data.contentId, requestObj, this.requestHeaders, callback);
    },
    uploadContent: function(contentId, data, config, callback){
        this.postFromService(this.serviceURL() + this.getConfig('uploadContentURL', '/v3/upload/') + contentId, data, config, callback);
    },
    createContent: function(data, callback) {
        this.postFromService(this.serviceURL() + this.getConfig('createContentURL', '/v3/create'), data, this.requestHeaders, callback);
    },
    unlistedPublishContent: function(data, callback) {
        var requestObj = {
            "request": {
                "content" : {
                    "lastPublishedBy" : ecEditor.getContext('uid')
                }
            }
        };
        this.postFromService(this.serviceURL() + this.getConfig('contentUnlistedPublishURL', '/v3/unlisted/publish/') + data.contentId, requestObj, this.requestHeaders, callback);
    }
}));

/**
 *
 * Assessment service helps to get questions(items)
 * @class org.ekstep.services.assessmentService
 * @author Santhosh Vasabhaktula <santhosh@ilimi.in>
 */
org.ekstep.services.assessmentService = new(org.ekstep.services.iService.extend({
    /** 
     * @member {string} learningURL
     * @memberof org.ekstep.services.assessmentService
     */
    assessmentURL: function() {
        return this.getBaseURL() + this.getAPISlug() + this.getConfig('assessmentEndPoint', '/assessment');
    },
    /**
     * Get Questions from search API
     * @param  {object}   data     search filter data
     * @param  {Function} callback returns error and response as arguments
     * @memberof org.ekstep.services.assessmentService
     */
    getQuestions: function(data, callback) {
        org.ekstep.services.searchService.search(data, callback);
    },
    /**
     * Get selected Question(assessmentitem)
     * @param  {string}   itemId   selected question(assessmentitem) id
     * @param  {Function} callback returns error and response as arguments
     * @memberof org.ekstep.services.assessmentService
     */
    getItem: function(itemId, callback) {
        this.getFromService(this.assessmentURL() + this.getConfig('itemReadUrl', '/v3/items/read/') + itemId, this.requestHeaders, callback);
    },
    /**
     * Get template data of selected question from content service API
     * @param  {string}   templateId selected question(assessmentitem) template id
     * @param  {Function} callback   returns error and response as arguments
     * @memberof org.ekstep.services.assessmentService
     */
    getTemplate: function(templateId, callback) {
        org.ekstep.services.contentService.getTemplateData(templateId, callback);
    },
    /**
     * This method is used to save question
     * @param  {string}   assessmentId
     * @param  {object}   requestObj
     * @param  {Function} callback returns error and response as arguments
     * @memberof org.ekstep.services.assessmentService
     */
    saveQuestion: function(assessmentId, requestObj, callback) {
        var instance = this;
        /*If assessment Id exists then update the question else create*/
        if (assessmentId) {
            instance.patch(this.assessmentURL() + 'assessmentitems/update/' + assessmentId, requestObj, this.requestHeaders, function(err, res) {
                callback(err, res)
            });
        } else {
            instance.post(this.assessmentURL() + 'assessmentitems/create', requestObj, this.requestHeaders, function(err, res) {
                callback(err, res)
            });
        }
    },
    /**
     * Get Questions from search assesmentItems
     * @param  {object}   data     search filter data
     * @param  {Function} callback returns error and response as arguments
     * @memberof org.ekstep.services.assessmentService
     */
    getQuestionItems: function(data, callback) {
        this.postFromService(this.assessmentURL() + '/v3/items/search', data, this.requestHeaders, callback);
    },
    /**
     * This method is used to save v3 question
     * @param  {string}   assessmentId
     * @param  {object}   requestObj
     * @param  {Function} callback returns error and response as arguments
     * @memberof org.ekstep.services.assessmentService
     */
    saveQuestionV3: function(assessmentId, requestObj, callback) {
        var instance = this;
        /*If assessment Id exists then update the question else create*/
        if (assessmentId) {
            instance.patch(this.assessmentURL() + '/v3/items/update/' + assessmentId, requestObj, this.requestHeaders, function(err, res) {
                callback(err, res)
            });
        } else {
            instance.post(this.assessmentURL() + '/v3/items/create', requestObj, this.requestHeaders, function(err, res) {
                callback(err, res)
            });
        }
    }
}));

/**
 * Asset service provides access to the content API to save assets.
 * @class org.ekstep.services.assetService
 * @author Santhosh Vasabhaktula <santhosh@ilimi.in>
 */
org.ekstep.services.assetService = new(org.ekstep.services.iService.extend({
     /** 
     * @member {string} searchURL
     * @memberof org.ekstep.services.assetService
     */
    contentURL: function() {
        return this.getBaseURL() + this.getAPISlug() + this.getConfig('contentEndPoint', '/content');
    },
    asset: {},
    initService: function() {},
    /**
     * Set asset object
     * @param {string} id        
     * @param {object} assetMeta 
     * @memberof org.ekstep.services.assetService
     */
    setAssetMeta: function(id, assetMeta) {
        if (id && assetMeta) {
            if(this.asset[id] == undefined) this.asset[id] = {};
            this.asset[id].assetMeta = assetMeta;
        }
    },
    /**
     * get asset object
     * @param  {string} id 
     * @memberof org.ekstep.services.assetService
     */
    getAssetMeta: function(id) {
        return this.asset[id] || {};
    },
    /**
     * This method is used to save assets(audio & image)
     * @param  {string}   assetId
     * @param  {string}   content
     * @param  {Function} callback returns error and response as arguments
     * @memberof org.ekstep.services.assetService
     */
    saveAsset: function(assetId, content, callback) {
        var instance = this;

        var requestObj = {
            request: {
                content: content
            }
        };
        if (assetId) {
            instance.patch(this.contentURL() + this.getConfig('contentUpdateUrl', '/v3/update/'), requestObj, this.requestHeaders, function(err, res) {
                callback(err, res)
            });
        } else {
            instance.post(this.contentURL() + this.getConfig('contentCreateUrl', '/v3/create'), requestObj, this.requestHeaders, function(err, res) {
                callback(err, res)
            });
        }
    }
}));

/**
 * Service to get meta information from platform
 * 
 * @class org.ekstep.services.metaService
 * @author Santhosh Vasabhaktula <santhosh@ilimi.in>
 */
org.ekstep.services.metaService = new(org.ekstep.services.iService.extend({
    /** 
     * @member {string} learningURL
     * @memberof org.ekstep.services.metaService
     */
    learningURL: function() {
        return this.getBaseURL() + this.getAPISlug() + this.getConfig('learningEndPoint', '/learning')
    },
    /** 
     * @member {string} learningURL
     * @memberof org.ekstep.services.metaService
     */
    metaURL: function() {
        return this.getBaseURL() + this.getAPISlug() + this.getConfig('metaEndPoint', '/meta')
    },
    /** 
     * @member {string} configURL
     * @memberof org.ekstep.services.metaService
     */
    configURL: function() {
        return this.getBaseURL() + this.getAPISlug() + this.getConfig('configEndPoint', '/domain')
    },
    /** 
     * @member {string} domainURL
     * @memberof org.ekstep.services.metaService
     */
    domainURL: function(){
        return this.getBaseURL() + this.getAPISlug() + this.getConfig('domainEndPoint', '/domain')
    },
    /** 
     * @member {string} frameworkURL
     * @memberof org.ekstep.services.metaService
     */
    frameworkURL: function(){
        return this.getBaseURL() + this.getAPISlug() + this.getConfig('frameworkEndPoint', '/framework')
    },
    /** 
     * @member {string} channelURL
     * @memberof org.ekstep.services.metaService
     */
    channelURL: function(){
        return this.getBaseURL() + this.getAPISlug() + this.getConfig('channelEndPoint', '/channel')
    },
    /** 
     * @member {string} vocabularyURL
     * @memberof org.ekstep.services.metaService
     */
    vocabularyURL: function(){
        return this.getBaseURL() + this.getAPISlug() + this.getConfig('vocabularyEndPoint','/vocabulary')
    },

    /** 
     * @member {string} pageAssembleUrl
     * @memberof org.ekstep.services.metaService
     */
    pageAssembleUrl: function(){
        return this.getBaseURL() + this.getAPISlug() + this.getConfig('pageAssembleEndPoint','/data')
    },


    /**
     * Returns the schema of the specified object. The schema will contain all the properties details (name, code, datatype, identifier etc,.).
     * @param  {string}   objectType  eg.AssessmentItem, Language etc.
     * @param  {Function} callback    returns error and response as arguments
     * @memberof org.ekstep.services.metaService
     */
    getDefinitions: function(objectType, callback) {
        this.getFromService(this.learningURL() + this.getConfig('definitionsGetUrl', '/taxonomy/domain/definition/') + objectType, { "headers": { "content-type": "application/json", "user-id": "content-editor" } }, callback);
    },
    /**
     * Returns all property values in the specified language.
     * @param  {string}   languageCode  eg. en, hi etc.
     * @param  {Function} callback      returns error and response as arguments
     * @memberof org.ekstep.services.metaService
     */
    getResourceBundles: function(languageCode, callback) {
        this.getFromService(this.metaURL() + this.getConfig('resourceBundleUrl', '/v3/resourcebundles/read/') + languageCode, this.requestHeaders, callback);
    },
    /**
     * Get config items from learning api terms list
     * @param  {Function} callback returns error and response as arguments
     * @memberof org.ekstep.services.configService
     */
    getLearningConfig: function(callback) {
        this.getFromService(this.domainURL() + this.getConfig('termsListUrl', '/v3/terms/list'), this.requestHeaders, callback);
    },
    /**
     * Get config items from config api ordinals
     * @param  {Function} callback returns error and response as arguments
     * @memberof org.ekstep.services.configService
     */
    getConfigOrdinals: function(callback) {
        this.getFromService(this.metaURL() + this.getConfig('ordinalsGetUrl', '/v3/ordinals/list'), this.requestHeaders, callback);
    },

    /**
     * Get config items from vocabulary api 
     * @param  {Function} callback returns error and response as arguments
     * @memberof org.ekstep.services.metaService
     */
    suggestVocabulary: function(data, callback){
        this.postFromService(this.vocabularyURL() + this.getConfig('suggestVocabularyUrl','/v3/term/suggest'),data, this.requestHeaders, callback); 
    },

    /**
     * Get config items from vocabulary api 
     * @param  {Function} callback returns error and response as arguments
     * @memberof org.ekstep.services.metaService
     */
    createVocabulary: function(data, callback){
        this.postFromService(this.vocabularyURL() + this.getConfig('createVocabularUrl','/v3/term/create'),data, this.requestHeaders, callback);
    },
    /**
     * Get Categorys based on framework
     * @param  {Function} callback returns error and response as arguments
     * @memberof org.ekstep.services.metaService
     */
    getCategorys: function(framework, callback){
        this.getFromService(this.frameworkURL() + this.getConfig('getCategorysUrl','/v3/read/') + framework, this.requestHeaders, callback);
    },
    /**
     * Get framework based on channel
     * @param  {Function} callback returns error and response as arguments
     * @memberof org.ekstep.services.metaService
     */
    getFrameworks: function(channel, callback){
        this.getFromService(this.channelURL() + this.getConfig('getFrameworksUrl','/v3/read/') + channel, this.requestHeaders, callback);
    },
    /**
     * Get config items from pageAssemble api 
     * @param  {Function} callback returns error and response as arguments
     * @memberof org.ekstep.services.metaService
     */
    getPageAssemble: function(data, callback){
        this.postFromService(this.pageAssembleUrl() + this.getConfig('pageAssembleUrl','/v1/page/assemble'), data, this.requestHeaders, callback);
    }

}));

/**
 * 
 * Language service helps to get languages and wordnet data.
 * @class org.ekstep.services.languageService
 * @author Santhosh Vasabhaktula <santhosh@ilimi.in>
 * 
 */
org.ekstep.services.languageService = new(org.ekstep.services.iService.extend({
    /** 
     * @member {string} learningURL
     * @memberof org.ekstep.services.languageService
     */
    learningURL: function() {
        return this.getBaseURL() + this.getAPISlug() + this.getConfig('learningEndPoint', '/learning');
    },
    /** 
     * @member {string} languageURL
     * @memberof org.ekstep.services.languageService
     */
    languageURL: function() { 
        return this.getBaseURL() + this.getAPISlug() + this.getConfig('languageEndPoint', '/language');
    },
    /** 
     * @member {object} wordHeaders
     * @memberof org.ekstep.services.languageService
     */
    wordHeaders: {
        "headers": {
            "Content-Type": "application/json",
            "Authorization": "Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiI5OGNlN2RmNmNkOTk0YWQ5YjZlYTRjNDJlNmVjYjY5MCJ9.rtr4188EwDYZywtP7S9uuv1LsivoucFxOvJFDCWvq0Y"
        }
    },
    /**
     * Get all list of languages
     * @param  {Function} callback returns error and response as arguments
     * @memberof org.ekstep.services.languageService
     */
    getLanguages: function(callback) {
        this.getFromService(this.languageURL() + this.getConfig('languageListUrl', '/v3/list'), this.requestHeaders, callback);
    },
    /**
     * Get all list of vowel available in selected language
     * @param  {string}   language eg. en, hi etc.
     * @param  {Function} callback returns error and response as arguments
     * @memberof org.ekstep.services.languageService
     */
    getVowel: function(language, callback) {
        this.getFromService(this.languageURL() + this.getConfig('vowelGetUrl', '/v3/varnas/vowels/list') + "?language_id=" + language, this.requestHeaders, callback);
    },
    /**
     * Get all list of consonant available in selected language
     * @param  {string}   language eg. en, hi etc.
     * @param  {Function} callback returns error and response as arguments
     * @memberof org.ekstep.services.languageService
     */
    getConsonant: function(language, callback) {
        this.getFromService(this.languageURL() + this.getConfig('consonantListUrl', '/v3/varnas/consonants/list') + "?language_id=" + language, this.requestHeaders, callback);
    },
    /**
     * Get all avalible words in given content
     * @param  {object}   data     request object contains filters, objectType, exists etc
     * @param  {Function} callback returns error and response as arguments
     * @memberof org.ekstep.services.languageService
     */
    getWords: function(data, callback) {
        this.postFromService(this.languageURL() + this.getConfig('wordsGetUrl', '/v3/search'), data, this.wordHeaders, callback);
    },
    /**
     * Get types of word. eg. Nouns, verbs etc 
     * @param  {Function} callback returns error and response as arguments
     * @memberof org.ekstep.services.languageService
     */
    getWordDefinition: function(callback) {
        this.getFromService(this.learningURL() + this.getConfig('word_definition_url', '/taxonomy/en/definition/Word'), this.requestHeaders, callback);
    },
    /**
     * Get all avalible keywords in given content
     * @param  {object}   data     request object
     * @param  {Function} callback returns error and response as arguments
     * @memberof org.ekstep.services.languageService
     */
    getKeyWords: function(data, callback) {
        this.postFromService(this.languageURL() + this.getConfig('keywordsGetUrl', '/v3/tools/parser'), data, this.requestHeaders, callback);
    },
    /**
    * Transliterates english text to specified language and invokes a callback
    * @param {Object} data - object containing english text and array of languages
    * @param {Function} callback - Callback when api call returns
    * @return {void}
    */
    getTransliteration: function(data, callback) {
        this.postFromService(this.languageURL() + this.getConfig('transliterateGetUrl', '/v3/tools/transliterate') + "?lemma=" + data.text + "&languages="+ data.languages.toString() , {"request": {}}, this.requestHeaders, callback);
    },
    /**
     * Translates word in provided languages
     * @param {Object} req contain requested data
     * @param {Function} callback, callback function
     */
    getTranslation:  function(data, callback) {
        this.postFromService(this.languageURL() + this.getConfig('translateGetUrl', '/v3/tools/translate') + "?language_id="+ data.wordLang + '&lemma=' + data.word + '&languages=' + data.languages, {"request": {}}, this.requestHeaders, callback);
    },
    /**
     * GetSyllables split word into letters
     * @param {Object} req contain requested data
     * @param {Function} callback, callback function
     */
    getSyllables: function(data, callback) {
        this.postFromService(this.languageURL() + '/v3/varnas/syllables/list', data, this.requestHeaders, callback);
    }
}));

/**
 * Search service provides capability to search content(activities, question etc.) from  composite search API.
 * 
 * @class org.ekstep.services.searchService
 * @author Santhosh Vasabhaktula <santhosh@ilimi.in>
 */
org.ekstep.services.searchService = new(org.ekstep.services.iService.extend({
    /** 
     * @member {string} searchURL
     * @memberof org.ekstep.services.searchService
     */
    searchURL: function() {
        return this.getBaseURL() + this.getAPISlug() + this.getConfig('compositeEndPoint', '/composite');
    },
    initService: function() {},
    /**
     * Search method helps to get the content from search API
     * @param  {object}   request  request object will take all request parameters of search API
     * @param  {Function} callback returns error and response as arguments
     * @memberof org.ekstep.services.searchService
     */
    search: function(request, callback) {
        if(!_.isEmpty(this.getConfig('searchCriteria'))){
            request.request = _.merge(this.getConfig('searchCriteria'), request.request);
        };
        this.postFromService(this.searchURL() + this.getConfig('searchUrl', '/v3/search'), request, this.requestHeaders, callback);
    }
}));
/**
 * Service to get DIAL & Link codes
 * 
 * @class org.ekstep.services.dialcodeService
 * @author Kartheek Palla <kartheekp@ilimi.in>
 */
org.ekstep.services.dialcodeService = new(org.ekstep.services.iService.extend({
    /** 
     * @member {string} dialcodeURL
     * @memberof org.ekstep.services.dialcodeService
     */
    dialcodeURL: function() {
        return this.getBaseURL() + this.getAPISlug() + this.getConfig('dialcodeEndPoint', '/dialcode');
    },
    /** 
     * @member {string} contentURL
     * @memberof org.ekstep.services.dialcodeService
     */
    dialcodelinkURL: function() {
        return this.getBaseURL() + this.getAPISlug() + this.getConfig('dialcodeEndPoint', '/content/v3/dialcode');
    },
    /**
     * Get all DIAL codes
     * @param  {Function} callback returns error and response as arguments
     * @memberof org.ekstep.services.dialcodeService
     */
    getAllDialCodes: function(channel, request, callback){
        this.postFromService(this.dialcodeURL() + this.getConfig('getAllDialcodes','/v3/search'), request, this.setChannelInHeader(channel), callback);
    },
    /**
     * retrieves the DIAL code
     * @param  {Function} callback returns error and response as arguments
     * @memberof org.ekstep.services.dialcodeService
     */
    getlDialCode: function(channel, dialCode, callback) {
        if (dialCode) {
            this.get(this.dialcodeURL() + this.getConfig('dialCodeReadUrl', '/v3/read/') + dialCode , this.setChannelInHeader(channel), callback);
        } else {
            callback('dialCode id is required to get dialCode details', undefined);
        }
    },
     /**
     * link dial code to content
     * @param  {Function} callback returns error and response as arguments
     * @memberof org.ekstep.services.dialcodeService
     */
    dialcodeLink: function(channel, request, callback){
        this.postFromService(this.dialcodelinkURL() + this.getConfig('dialcodeLink','/link'), request, this.setChannelInHeader(channel), callback);
    },
    /**
     * set channel in requestHeaders
     * @memberof org.ekstep.services.dialcodeService
     */
    setChannelInHeader: function(channel){
        var headersObj = _.cloneDeep(this.requestHeaders);
        headersObj.headers['X-Channel-Id'] = channel;
        return headersObj;
    }
}));
/**
 * @author Harish kumar Gangula<harishg@ilimi.in>
 */
org.ekstep.pluginframework.iRepo = Class.extend({
    discoverManifest: function(pluginId, pluginVer, callback) {
    	callback(undefined, undefined);
    },
    resolveResource: function(pluginId, pluginVer, resource) {}
});

/**
 * @author Harish kumar Gangula<harishg@ilimi.in>
 */
org.ekstep.pluginframework.publishedRepo = new(org.ekstep.pluginframework.iRepo.extend({
    id: "published",
    discoverManifest: function(pluginId, pluginVer, callback, publishedTime) {
        var instance = this;
        org.ekstep.pluginframework.resourceManager.loadResource(this.resolveResource(pluginId, pluginVer, "manifest.json"), "json", function(err, response) {
            callback(undefined, { "manifest": response, "repo": instance });
        }, publishedTime);
    },
    resolveResource: function(id, ver, resource) {        
    	return org.ekstep.pluginframework.config.pluginRepo + "/" + id + "-" + ver + "/" + resource;
    }
}));
org.ekstep.pluginframework.resourceManager.addRepo(org.ekstep.pluginframework.publishedRepo);
/* Font Face Observer v2.0.13 - © Bram Stein. License: BSD-3-Clause */(function(){'use strict';var f,g=[];function l(a){g.push(a);1==g.length&&f()}function m(){for(;g.length;)g[0](),g.shift()}f=function(){setTimeout(m)};function n(a){this.a=p;this.b=void 0;this.f=[];var b=this;try{a(function(a){q(b,a)},function(a){r(b,a)})}catch(c){r(b,c)}}var p=2;function t(a){return new n(function(b,c){c(a)})}function u(a){return new n(function(b){b(a)})}function q(a,b){if(a.a==p){if(b==a)throw new TypeError;var c=!1;try{var d=b&&b.then;if(null!=b&&"object"==typeof b&&"function"==typeof d){d.call(b,function(b){c||q(a,b);c=!0},function(b){c||r(a,b);c=!0});return}}catch(e){c||r(a,e);return}a.a=0;a.b=b;v(a)}}
function r(a,b){if(a.a==p){if(b==a)throw new TypeError;a.a=1;a.b=b;v(a)}}function v(a){l(function(){if(a.a!=p)for(;a.f.length;){var b=a.f.shift(),c=b[0],d=b[1],e=b[2],b=b[3];try{0==a.a?"function"==typeof c?e(c.call(void 0,a.b)):e(a.b):1==a.a&&("function"==typeof d?e(d.call(void 0,a.b)):b(a.b))}catch(h){b(h)}}})}n.prototype.g=function(a){return this.c(void 0,a)};n.prototype.c=function(a,b){var c=this;return new n(function(d,e){c.f.push([a,b,d,e]);v(c)})};
function w(a){return new n(function(b,c){function d(c){return function(d){h[c]=d;e+=1;e==a.length&&b(h)}}var e=0,h=[];0==a.length&&b(h);for(var k=0;k<a.length;k+=1)u(a[k]).c(d(k),c)})}function x(a){return new n(function(b,c){for(var d=0;d<a.length;d+=1)u(a[d]).c(b,c)})};window.Promise||(window.Promise=n,window.Promise.resolve=u,window.Promise.reject=t,window.Promise.race=x,window.Promise.all=w,window.Promise.prototype.then=n.prototype.c,window.Promise.prototype["catch"]=n.prototype.g);}());

(function(){function l(a,b){document.addEventListener?a.addEventListener("scroll",b,!1):a.attachEvent("scroll",b)}function m(a){document.body?a():document.addEventListener?document.addEventListener("DOMContentLoaded",function c(){document.removeEventListener("DOMContentLoaded",c);a()}):document.attachEvent("onreadystatechange",function k(){if("interactive"==document.readyState||"complete"==document.readyState)document.detachEvent("onreadystatechange",k),a()})};function r(a){this.a=document.createElement("div");this.a.setAttribute("aria-hidden","true");this.a.appendChild(document.createTextNode(a));this.b=document.createElement("span");this.c=document.createElement("span");this.h=document.createElement("span");this.f=document.createElement("span");this.g=-1;this.b.style.cssText="max-width:none;display:inline-block;position:absolute;height:100%;width:100%;overflow:scroll;font-size:16px;";this.c.style.cssText="max-width:none;display:inline-block;position:absolute;height:100%;width:100%;overflow:scroll;font-size:16px;";
this.f.style.cssText="max-width:none;display:inline-block;position:absolute;height:100%;width:100%;overflow:scroll;font-size:16px;";this.h.style.cssText="display:inline-block;width:200%;height:200%;font-size:16px;max-width:none;";this.b.appendChild(this.h);this.c.appendChild(this.f);this.a.appendChild(this.b);this.a.appendChild(this.c)}
function t(a,b){a.a.style.cssText="max-width:none;min-width:20px;min-height:20px;display:inline-block;overflow:hidden;position:absolute;width:auto;margin:0;padding:0;top:-999px;white-space:nowrap;font-synthesis:none;font:"+b+";"}function y(a){var b=a.a.offsetWidth,c=b+100;a.f.style.width=c+"px";a.c.scrollLeft=c;a.b.scrollLeft=a.b.scrollWidth+100;return a.g!==b?(a.g=b,!0):!1}function z(a,b){function c(){var a=k;y(a)&&a.a.parentNode&&b(a.g)}var k=a;l(a.b,c);l(a.c,c);y(a)};function A(a,b){var c=b||{};this.family=a;this.style=c.style||"normal";this.weight=c.weight||"normal";this.stretch=c.stretch||"normal"}var B=null,C=null,E=null,F=null;function G(){if(null===C)if(J()&&/Apple/.test(window.navigator.vendor)){var a=/AppleWebKit\/([0-9]+)(?:\.([0-9]+))(?:\.([0-9]+))/.exec(window.navigator.userAgent);C=!!a&&603>parseInt(a[1],10)}else C=!1;return C}function J(){null===F&&(F=!!document.fonts);return F}
function K(){if(null===E){var a=document.createElement("div");try{a.style.font="condensed 100px sans-serif"}catch(b){}E=""!==a.style.font}return E}function L(a,b){return[a.style,a.weight,K()?a.stretch:"","100px",b].join(" ")}
A.prototype.load=function(a,b){var c=this,k=a||"BESbswy",q=0,D=b||3E3,H=(new Date).getTime();return new Promise(function(a,b){if(J()&&!G()){var M=new Promise(function(a,b){function e(){(new Date).getTime()-H>=D?b():document.fonts.load(L(c,'"'+c.family+'"'),k).then(function(c){1<=c.length?a():setTimeout(e,25)},function(){b()})}e()}),N=new Promise(function(a,c){q=setTimeout(c,D)});Promise.race([N,M]).then(function(){clearTimeout(q);a(c)},function(){b(c)})}else m(function(){function u(){var b;if(b=-1!=
f&&-1!=g||-1!=f&&-1!=h||-1!=g&&-1!=h)(b=f!=g&&f!=h&&g!=h)||(null===B&&(b=/AppleWebKit\/([0-9]+)(?:\.([0-9]+))/.exec(window.navigator.userAgent),B=!!b&&(536>parseInt(b[1],10)||536===parseInt(b[1],10)&&11>=parseInt(b[2],10))),b=B&&(f==v&&g==v&&h==v||f==w&&g==w&&h==w||f==x&&g==x&&h==x)),b=!b;b&&(d.parentNode&&d.parentNode.removeChild(d),clearTimeout(q),a(c))}function I(){if((new Date).getTime()-H>=D)d.parentNode&&d.parentNode.removeChild(d),b(c);else{var a=document.hidden;if(!0===a||void 0===a)f=e.a.offsetWidth,
g=n.a.offsetWidth,h=p.a.offsetWidth,u();q=setTimeout(I,50)}}var e=new r(k),n=new r(k),p=new r(k),f=-1,g=-1,h=-1,v=-1,w=-1,x=-1,d=document.createElement("div");d.dir="ltr";t(e,L(c,"sans-serif"));t(n,L(c,"serif"));t(p,L(c,"monospace"));d.appendChild(e.a);d.appendChild(n.a);d.appendChild(p.a);document.body.appendChild(d);v=e.a.offsetWidth;w=n.a.offsetWidth;x=p.a.offsetWidth;I();z(e,function(a){f=a;u()});t(e,L(c,'"'+c.family+'",sans-serif'));z(n,function(a){g=a;u()});t(n,L(c,'"'+c.family+'",serif'));
z(p,function(a){h=a;u()});t(p,L(c,'"'+c.family+'",monospace'))})})};"object"===typeof module?module.exports=A:(window.FontFaceObserver=A,window.FontFaceObserver.prototype.load=A.prototype.load);}());
var detectClient = function() {

        var nAgt = navigator.userAgent;
        var browserName = navigator.appName;
        var fullVersion = '' + parseFloat(navigator.appVersion);
        var nameOffset, verOffset, ix;

        // In Opera
        /* istanbul ignore next. Cannot test this as the test cases runs in phatomjs browser */
        if ((verOffset = nAgt.indexOf("Opera")) != -1) {
            browserName = "opera";
            fullVersion = nAgt.substring(verOffset + 6);
            if ((verOffset = nAgt.indexOf("Version")) != -1)
                fullVersion = nAgt.substring(verOffset + 8);
        }
        // In MSIE
        else if ((verOffset = nAgt.indexOf("MSIE")) != -1) {
            browserName = "IE";
            fullVersion = nAgt.substring(verOffset + 5);
        }
        // In Chrome
        else if ((verOffset = nAgt.indexOf("Chrome")) != -1) {
            browserName = "chrome";
            fullVersion = nAgt.substring(verOffset + 7);
        }
        // In Safari
        else if ((verOffset = nAgt.indexOf("Safari")) != -1) {
            browserName = "safari";
            fullVersion = nAgt.substring(verOffset + 7);
            if ((verOffset = nAgt.indexOf("Version")) != -1)
                fullVersion = nAgt.substring(verOffset + 8);
        }
        // In Firefox
        else if ((verOffset = nAgt.indexOf("Firefox")) != -1) {
            browserName = "firefox";
            fullVersion = nAgt.substring(verOffset + 8);
        }

        // trim the fullVersion string at semicolon/space if present
        /* istanbul ignore next. Cannot test this as the test cases runs in phatomjs browser */
        if ((ix = fullVersion.indexOf(";")) != -1)
            fullVersion = fullVersion.substring(0, ix);
        /* istanbul ignore next. Cannot test this as the test cases runs in phatomjs browser */
        if ((ix = fullVersion.indexOf(" ")) != -1)
            fullVersion = fullVersion.substring(0, ix);

        return { browser: browserName, browserver: fullVersion, os: navigator.platform };
    }

/*
CryptoJS v3.1.2
code.google.com/p/crypto-js
(c) 2009-2013 by Jeff Mott. All rights reserved.
code.google.com/p/crypto-js/wiki/License
*/
var CryptoJS = CryptoJS || function(s, p) {
    var m = {},
        l = m.lib = {},
        n = function() {},
        r = l.Base = {
            extend: function(b) {
                n.prototype = this;
                var h = new n;
                b && h.mixIn(b);
                h.hasOwnProperty("init") || (h.init = function() {
                    h.$super.init.apply(this, arguments)
                });
                h.init.prototype = h;
                h.$super = this;
                return h
            },
            create: function() {
                var b = this.extend();
                b.init.apply(b, arguments);
                return b
            },
            init: function() {},
            mixIn: function(b) {
                for (var h in b) b.hasOwnProperty(h) && (this[h] = b[h]);
                b.hasOwnProperty("toString") && (this.toString = b.toString)
            },
            clone: function() {
                return this.init.prototype.extend(this)
            }
        },
        q = l.WordArray = r.extend({
            init: function(b, h) {
                b = this.words = b || [];
                this.sigBytes = h != p ? h : 4 * b.length
            },
            toString: function(b) {
                return (b || t).stringify(this)
            },
            concat: function(b) {
                var h = this.words,
                    a = b.words,
                    j = this.sigBytes;
                b = b.sigBytes;
                this.clamp();
                if (j % 4)
                    for (var g = 0; g < b; g++) h[j + g >>> 2] |= (a[g >>> 2] >>> 24 - 8 * (g % 4) & 255) << 24 - 8 * ((j + g) % 4);
                else if (65535 < a.length)
                    for (g = 0; g < b; g += 4) h[j + g >>> 2] = a[g >>> 2];
                else h.push.apply(h, a);
                this.sigBytes += b;
                return this
            },
            clamp: function() {
                var b = this.words,
                    h = this.sigBytes;
                b[h >>> 2] &= 4294967295 <<
                    32 - 8 * (h % 4);
                b.length = s.ceil(h / 4)
            },
            clone: function() {
                var b = r.clone.call(this);
                b.words = this.words.slice(0);
                return b
            },
            random: function(b) {
                for (var h = [], a = 0; a < b; a += 4) h.push(4294967296 * s.random() | 0);
                return new q.init(h, b)
            }
        }),
        v = m.enc = {},
        t = v.Hex = {
            stringify: function(b) {
                var a = b.words;
                b = b.sigBytes;
                for (var g = [], j = 0; j < b; j++) {
                    var k = a[j >>> 2] >>> 24 - 8 * (j % 4) & 255;
                    g.push((k >>> 4).toString(16));
                    g.push((k & 15).toString(16))
                }
                return g.join("")
            },
            parse: function(b) {
                for (var a = b.length, g = [], j = 0; j < a; j += 2) g[j >>> 3] |= parseInt(b.substr(j,
                    2), 16) << 24 - 4 * (j % 8);
                return new q.init(g, a / 2)
            }
        },
        a = v.Latin1 = {
            stringify: function(b) {
                var a = b.words;
                b = b.sigBytes;
                for (var g = [], j = 0; j < b; j++) g.push(String.fromCharCode(a[j >>> 2] >>> 24 - 8 * (j % 4) & 255));
                return g.join("")
            },
            parse: function(b) {
                for (var a = b.length, g = [], j = 0; j < a; j++) g[j >>> 2] |= (b.charCodeAt(j) & 255) << 24 - 8 * (j % 4);
                return new q.init(g, a)
            }
        },
        u = v.Utf8 = {
            stringify: function(b) {
                try {
                    return decodeURIComponent(escape(a.stringify(b)))
                } catch (g) {
                    throw Error("Malformed UTF-8 data");
                }
            },
            parse: function(b) {
                return a.parse(unescape(encodeURIComponent(b)))
            }
        },
        g = l.BufferedBlockAlgorithm = r.extend({
            reset: function() {
                this._data = new q.init;
                this._nDataBytes = 0
            },
            _append: function(b) {
                "string" == typeof b && (b = u.parse(b));
                this._data.concat(b);
                this._nDataBytes += b.sigBytes
            },
            _process: function(b) {
                var a = this._data,
                    g = a.words,
                    j = a.sigBytes,
                    k = this.blockSize,
                    m = j / (4 * k),
                    m = b ? s.ceil(m) : s.max((m | 0) - this._minBufferSize, 0);
                b = m * k;
                j = s.min(4 * b, j);
                if (b) {
                    for (var l = 0; l < b; l += k) this._doProcessBlock(g, l);
                    l = g.splice(0, b);
                    a.sigBytes -= j
                }
                return new q.init(l, j)
            },
            clone: function() {
                var b = r.clone.call(this);
                b._data = this._data.clone();
                return b
            },
            _minBufferSize: 0
        });
    l.Hasher = g.extend({
        cfg: r.extend(),
        init: function(b) {
            this.cfg = this.cfg.extend(b);
            this.reset()
        },
        reset: function() {
            g.reset.call(this);
            this._doReset()
        },
        update: function(b) {
            this._append(b);
            this._process();
            return this
        },
        finalize: function(b) {
            b && this._append(b);
            return this._doFinalize()
        },
        blockSize: 16,
        _createHelper: function(b) {
            return function(a, g) {
                return (new b.init(g)).finalize(a)
            }
        },
        _createHmacHelper: function(b) {
            return function(a, g) {
                return (new k.HMAC.init(b,
                    g)).finalize(a)
            }
        }
    });
    var k = m.algo = {};
    return m
}(Math);
(function(s) {
    function p(a, k, b, h, l, j, m) {
        a = a + (k & b | ~k & h) + l + m;
        return (a << j | a >>> 32 - j) + k
    }

    function m(a, k, b, h, l, j, m) {
        a = a + (k & h | b & ~h) + l + m;
        return (a << j | a >>> 32 - j) + k
    }

    function l(a, k, b, h, l, j, m) {
        a = a + (k ^ b ^ h) + l + m;
        return (a << j | a >>> 32 - j) + k
    }

    function n(a, k, b, h, l, j, m) {
        a = a + (b ^ (k | ~h)) + l + m;
        return (a << j | a >>> 32 - j) + k
    }
    for (var r = CryptoJS, q = r.lib, v = q.WordArray, t = q.Hasher, q = r.algo, a = [], u = 0; 64 > u; u++) a[u] = 4294967296 * s.abs(s.sin(u + 1)) | 0;
    q = q.MD5 = t.extend({
        _doReset: function() {
            this._hash = new v.init([1732584193, 4023233417, 2562383102, 271733878])
        },
        _doProcessBlock: function(g, k) {
            for (var b = 0; 16 > b; b++) {
                var h = k + b,
                    w = g[h];
                g[h] = (w << 8 | w >>> 24) & 16711935 | (w << 24 | w >>> 8) & 4278255360
            }
            var b = this._hash.words,
                h = g[k + 0],
                w = g[k + 1],
                j = g[k + 2],
                q = g[k + 3],
                r = g[k + 4],
                s = g[k + 5],
                t = g[k + 6],
                u = g[k + 7],
                v = g[k + 8],
                x = g[k + 9],
                y = g[k + 10],
                z = g[k + 11],
                A = g[k + 12],
                B = g[k + 13],
                C = g[k + 14],
                D = g[k + 15],
                c = b[0],
                d = b[1],
                e = b[2],
                f = b[3],
                c = p(c, d, e, f, h, 7, a[0]),
                f = p(f, c, d, e, w, 12, a[1]),
                e = p(e, f, c, d, j, 17, a[2]),
                d = p(d, e, f, c, q, 22, a[3]),
                c = p(c, d, e, f, r, 7, a[4]),
                f = p(f, c, d, e, s, 12, a[5]),
                e = p(e, f, c, d, t, 17, a[6]),
                d = p(d, e, f, c, u, 22, a[7]),
                c = p(c, d, e, f, v, 7, a[8]),
                f = p(f, c, d, e, x, 12, a[9]),
                e = p(e, f, c, d, y, 17, a[10]),
                d = p(d, e, f, c, z, 22, a[11]),
                c = p(c, d, e, f, A, 7, a[12]),
                f = p(f, c, d, e, B, 12, a[13]),
                e = p(e, f, c, d, C, 17, a[14]),
                d = p(d, e, f, c, D, 22, a[15]),
                c = m(c, d, e, f, w, 5, a[16]),
                f = m(f, c, d, e, t, 9, a[17]),
                e = m(e, f, c, d, z, 14, a[18]),
                d = m(d, e, f, c, h, 20, a[19]),
                c = m(c, d, e, f, s, 5, a[20]),
                f = m(f, c, d, e, y, 9, a[21]),
                e = m(e, f, c, d, D, 14, a[22]),
                d = m(d, e, f, c, r, 20, a[23]),
                c = m(c, d, e, f, x, 5, a[24]),
                f = m(f, c, d, e, C, 9, a[25]),
                e = m(e, f, c, d, q, 14, a[26]),
                d = m(d, e, f, c, v, 20, a[27]),
                c = m(c, d, e, f, B, 5, a[28]),
                f = m(f, c,
                    d, e, j, 9, a[29]),
                e = m(e, f, c, d, u, 14, a[30]),
                d = m(d, e, f, c, A, 20, a[31]),
                c = l(c, d, e, f, s, 4, a[32]),
                f = l(f, c, d, e, v, 11, a[33]),
                e = l(e, f, c, d, z, 16, a[34]),
                d = l(d, e, f, c, C, 23, a[35]),
                c = l(c, d, e, f, w, 4, a[36]),
                f = l(f, c, d, e, r, 11, a[37]),
                e = l(e, f, c, d, u, 16, a[38]),
                d = l(d, e, f, c, y, 23, a[39]),
                c = l(c, d, e, f, B, 4, a[40]),
                f = l(f, c, d, e, h, 11, a[41]),
                e = l(e, f, c, d, q, 16, a[42]),
                d = l(d, e, f, c, t, 23, a[43]),
                c = l(c, d, e, f, x, 4, a[44]),
                f = l(f, c, d, e, A, 11, a[45]),
                e = l(e, f, c, d, D, 16, a[46]),
                d = l(d, e, f, c, j, 23, a[47]),
                c = n(c, d, e, f, h, 6, a[48]),
                f = n(f, c, d, e, u, 10, a[49]),
                e = n(e, f, c, d,
                    C, 15, a[50]),
                d = n(d, e, f, c, s, 21, a[51]),
                c = n(c, d, e, f, A, 6, a[52]),
                f = n(f, c, d, e, q, 10, a[53]),
                e = n(e, f, c, d, y, 15, a[54]),
                d = n(d, e, f, c, w, 21, a[55]),
                c = n(c, d, e, f, v, 6, a[56]),
                f = n(f, c, d, e, D, 10, a[57]),
                e = n(e, f, c, d, t, 15, a[58]),
                d = n(d, e, f, c, B, 21, a[59]),
                c = n(c, d, e, f, r, 6, a[60]),
                f = n(f, c, d, e, z, 10, a[61]),
                e = n(e, f, c, d, j, 15, a[62]),
                d = n(d, e, f, c, x, 21, a[63]);
            b[0] = b[0] + c | 0;
            b[1] = b[1] + d | 0;
            b[2] = b[2] + e | 0;
            b[3] = b[3] + f | 0
        },
        _doFinalize: function() {
            var a = this._data,
                k = a.words,
                b = 8 * this._nDataBytes,
                h = 8 * a.sigBytes;
            k[h >>> 5] |= 128 << 24 - h % 32;
            var l = s.floor(b /
                4294967296);
            k[(h + 64 >>> 9 << 4) + 15] = (l << 8 | l >>> 24) & 16711935 | (l << 24 | l >>> 8) & 4278255360;
            k[(h + 64 >>> 9 << 4) + 14] = (b << 8 | b >>> 24) & 16711935 | (b << 24 | b >>> 8) & 4278255360;
            a.sigBytes = 4 * (k.length + 1);
            this._process();
            a = this._hash;
            k = a.words;
            for (b = 0; 4 > b; b++) h = k[b], k[b] = (h << 8 | h >>> 24) & 16711935 | (h << 24 | h >>> 8) & 4278255360;
            return a
        },
        clone: function() {
            var a = t.clone.call(this);
            a._hash = this._hash.clone();
            return a
        }
    });
    r.MD5 = t._createHelper(q);
    r.HmacMD5 = t._createHmacHelper(q)
})(Math);
/**
 * Telemetry V3 Library
 * @author Akash Gupta <Akash.Gupta@tarento.com>
 */

var EkTelemetry = (function() {
    this.ektelemetry = function() {};
    var instance = function() {};
    var telemetryInstance = this;
    this.ektelemetry.initialized = false;
    this.ektelemetry.config = undefined;
    this.ektelemetry._version = "3.0";
    dispatcher = undefined;

    this.startTime = 0;
    this._defaultValue = {
        pdata: {
            id: "in.ekstep",
            ver: "1.0",
            pid: ""
        },
        channel: "in.ekstep",
        uid: "anonymous",
        did: "",
        authtoken: "",
        sid: "",
        batchsize: 20,
        host: "https://action.ekstep.in",
        endpoint: "/data/v3/telemetry",
        tags: [],
        cdata: [],
        apislug: "/action"
    },
    this.deviceSpecRequiredFields = ["os","make","id","mem","idisk","edisk","scrn","camera","cpu","sims","cap"],
    this.userAgentRequiredFields = ["agent","ver","system","platform","raw"],
    this.objectRequiredFields = ["id","type","ver"],
    this.targetRequiredFields = ["id","type","ver"],
    this.pluginRequiredFields = ["id","ver"],
    this.visitRequiredFields = ["objid","objtype"],
    this.questionRequiredFields = ["id","maxscore","exlength","desc","title"],
    this.pdataRequiredFields = ["id"],
    this.targetObjectRequiredFields = ["type","id"],

    this.ektelemetry.start = function(config, contentId, contentVer, data) {
        if (EkTelemetry.initialized) {
            console.log("Telemetry is already initialized..");
            return;
        }
        if (!instance.hasRequiredData(data, ["type"])) {
            console.error('Invalid start data');
            return;
        }
        if (data.dspec && !instance.checkRequiredField(data.dspec, telemetryInstance.deviceSpecRequiredFields)) {
            console.error('Invalid device spec')
            return;
        }
        if (data.uaspec && !instance.checkRequiredField(data.uaspec, telemetryInstance.userAgentRequiredFields)) {
            console.error('Invalid user agent spec')
            return;
        }
        data.duration = data.duration || (new Date()).getTime();
        
        if (instance.init(config, contentId, contentVer, data.type)) {
            var startEventObj = instance.getEvent('START', data);
            instance._dispatch(startEventObj)

            // Required to calculate the time spent of content while generating OE_END
            EkTelemetry.startTime = startEventObj.ets;
            return startEventObj;
        }
    }

    this.ektelemetry.end = function(data) {
        if (!EkTelemetry.initialized) {
            console.log("Telemetry is not initialized, Please start telemetry first");
            return;
        }
        if (!instance.hasRequiredData(data, ["type"])) {
            console.error('Invalid end data. Required fields are missing.', data);
            return;
        }
        data.duration = ((new Date()).getTime() - EkTelemetry.startTime)
        instance._dispatch(instance.getEvent('END', data));
        EkTelemetry.initialized = false;
    }

    this.ektelemetry.impression = function(data) {
        if (undefined == data.pageid || undefined == data.type || undefined == data.uri) {
            console.error('Invalid impression data. Required fields are missing.', data);
            return;
        }
        if (data.visits && !instance.hasRequiredData(data.visits, telemetryInstance.visitRequiredFields)) {
            console.error('Invalid visits spec')
            return;
        }
        instance._dispatch(instance.getEvent('IMPRESSION', data));
    }

    this.ektelemetry.interact = function(data) {
        if (!instance.hasRequiredData(data, ["type", "id"])) {
            console.error('Invalid interact data');
            return;
        }
        if (data.target && !instance.checkRequiredField(data.target, telemetryInstance.targetRequiredFields)) {
            console.error('Invalid target spec')
            return;
        }
        if (data.plugin && !instance.checkRequiredField(data.plugin, telemetryInstance.pluginRequiredFields)) {
            console.error('Invalid plugin spec')
            return;
        }

        instance._dispatch(instance.getEvent('INTERACT', data));
    }

    this.ektelemetry.assess = function(data) {
        if (!instance.hasRequiredData(data, ["item", "pass", "score", "resvalues", "duration"])) {
            console.error('Invalid assess data');
            return;
        }
        if (!instance.checkRequiredField(data.item, telemetryInstance.questionRequiredFields)) {
            console.error('Invalid question spec')
            return;
        }

        instance._dispatch(instance.getEvent('ASSESS', data));
    }

    this.ektelemetry.response = function(data) {
        if (!instance.hasRequiredData(data, ["target", "values", "type"])) {
            console.error('Invalid response data');
            return;
        }
        if (!instance.checkRequiredField(data.target, telemetryInstance.targetRequiredFields)) {
            console.error('Invalid target spec')
            return;
        }

        instance._dispatch(instance.getEvent('RESPONSE', data));
    }

    this.ektelemetry.interrupt = function(data) {
        if (!instance.hasRequiredData(data, ["type"])) {
            console.error('Invalid interrupt data');
            return;
        }

        instance._dispatch(instance.getEvent('INTERRUPT', data));
    }

    this.ektelemetry.feedback = function(data) {
        var eksData = {
            "rating": data.rating || '',
            "comments": data.comments || ''
        }
        instance._dispatch(instance.getEvent('FEEDBACK', eksData));
    }

    //Share
    this.ektelemetry.share = function(data) {
        if (!instance.hasRequiredData(data, ["items"])) {
            console.error('Invalid share data');
            return;
        }
        
        instance._dispatch(instance.getEvent('INTERRUPT', data));
    }

    this.ektelemetry.audit = function(data) {
        if (!instance.hasRequiredData(data, ["props"])) {
            console.error('Invalid audit data');
            return;
        }
        
        instance._dispatch(instance.getEvent('AUDIT', data));
    }

    this.ektelemetry.error = function(data) {
        if (!instance.hasRequiredData(data, ["err", "errtype", "stacktrace"])) {
            console.error('Invalid error data');
            return;
        }
        if (data.object && !instance.checkRequiredField(data.object, telemetryInstance.objectRequiredFields)) {
            console.error('Invalid object spec')
            return;
        }
        if (data.plugin && !instance.checkRequiredField(data.plugin, telemetryInstance.pluginRequiredFields)) {
            console.error('Invalid plugin spec')
            return;
        }

        instance._dispatch(instance.getEvent('ERROR', data));
    }

    this.ektelemetry.heartbeat = function(data) {
        instance._dispatch(instance.getEvent('HEARTBEAT', data));
    }

    this.ektelemetry.log = function(data) {
        if (!instance.hasRequiredData(data, ["type", "level", "message"])) {
            console.error('Invalid log data');
            return;
        }
        instance._dispatch(instance.getEvent('LOG', data));
    }

    this.ektelemetry.search = function(data) {
        if (!instance.hasRequiredData(data, ["query", "size", "topn"])) {
            console.error('Invalid search data');
            return;
        }
        
        instance._dispatch(instance.getEvent('SEARCH', data));
    }

    this.ektelemetry.metrics = function(data) {
        instance._dispatch(instance.getEvent('METRICS', data));
    }

    this.ektelemetry.exdata = function(data) {
        instance._dispatch(instance.getEvent('EXDATA', data));
    }

    this.ektelemetry.summary = function(data) {
        if (!instance.hasRequiredData(data, ["type", "starttime", "endtime", "timespent","pageviews","interactions"])) {
            console.error('Invalid summary data');
            return;
        }
        
        instance._dispatch(instance.getEvent('SUMMARY', data));
    }    

    instance.init = function(config, contentId, contentVer, type) {
        if (EkTelemetry.initialized) {
            console.log("Telemetry is already initialized..");
            return;
        }
        if (config.pdata && !instance.checkRequiredField(config.pdata, telemetryInstance.pdataRequiredFields)) {
            console.error('Invalid pdata spec in config')
            return;
        }
        if (config.object && !instance.checkRequiredField(config.object, telemetryInstance.targetObjectRequiredFields)) {
            console.error('Invalid target object spec in config')
            return;
        }

        var requiredData = Object.assign(config, { "contentId": contentId, "contentVer": contentVer, "type": type });

        if (!instance.hasRequiredData(requiredData, ["contentId", "contentVer", "pdata", "channel", "uid", "env"])) {
            console.error('Invalid start data');
            EkTelemetry.initialized = false;
            return EkTelemetry.initialized;
        }

        _defaultValue.gdata = {
            "id": contentId,
            "ver": contentVer
        }
        config.batchsize = config.batchsize ? (config.batchsize < 10 ? 10 : (config.batchsize > 1000 ? 1000 : config.batchsize)) : _defaultValue.batchsize;
        EkTelemetry.config = Object.assign(_defaultValue, config);
        EkTelemetry.initialized = true;
        dispatcher = EkTelemetry.config.dispatcher ? EkTelemetry.config.dispatcher : libraryDispatcher;
        return EkTelemetry.initialized;
    }

    instance._dispatch = function(message) {
        if(message){
            message.mid = message.eid + ':' + CryptoJS.MD5(JSON.stringify(message)).toString();
            dispatcher.dispatch(message);
        }
    }

    instance.getEvent = function(eventId, data) {
        if(EkTelemetry.config){
            var eventObj = {
                "eid": eventId,
                "ets": (new Date()).getTime(),
                "ver": EkTelemetry._version,
                "mid": '',
                "actor": {
                    "id": EkTelemetry.config.uid,
                    "type": 'User'
                },
                "context": {
                    "channel": EkTelemetry.config.channel,
                    "pdata": EkTelemetry.config.pdata,
                    "env": EkTelemetry.config.env,
                    "sid": EkTelemetry.config.sid,
                    "did": EkTelemetry.config.did,
                    "cdata": EkTelemetry.config.cdata, //TODO: No correlation data as of now. Needs to be sent by portal in context
                    "rollup": EkTelemetry.config.rollup || {}
                },
                "object": EkTelemetry.config.object,
                "tags": EkTelemetry.config.tags,
                "edata": data
            }
            return eventObj;
        }
    }

    // instance.addEvent = function(telemetryEvent) {
    //     if (EkTelemetry.initialized) {
    //         telemetryEvent.mid = telemetryEvent.eid + '_' + CryptoJS.MD5(JSON.stringify(telemetryEvent)).toString();
    //         var customEvent = new CustomEvent('TelemetryEvent', { detail: telemetryEvent });
    //         console.log("Telemetry Event ", telemetryEvent);
    //         document.dispatchEvent(customEvent);
    //     } else {
    //         console.log("Telemetry is not initialized. Please start Telemetry to log events.");
    //     }
    // }

    instance.hasRequiredData = function(data, mandatoryFields) {
        var isValid = true;
        var checkValidation = function(data, mandatoryFields) {
            mandatoryFields.forEach(function(key) {
                if (data) {
                    if (!data.hasOwnProperty(key)) {
                        isValid = false;
                        return;             // stopping loop if even single obj is incorrect
                    }
                } else {
                    isValid = false
                    return
                }
            });
        }
        if (Array.isArray(data)) {
            data.forEach(function(obj){
                checkValidation(obj, mandatoryFields);
            })
            return isValid
        } else {
            checkValidation(data, mandatoryFields);
            return isValid
        }
    }

    instance.checkRequiredField = function(data, defaultKeys) {
        var returnValue = true;
        defaultKeys.forEach(function(key) {
            if (!data.hasOwnProperty(key)) {
                returnValue = false
            }
        })
        return returnValue;
    }

    // For device which dont support ECMAScript 6
    instance.objectAssign = function() {
        Object.assign = function(target) {
            'use strict';
            if (target == null) {
                throw new TypeError('Cannot convert undefined or null to object');
            }

            target = Object(target);
            for (var index = 1; index < arguments.length; index++) {
                var source = arguments[index];
                if (source != null) {
                    for (var key in source) {
                        if (Object.prototype.hasOwnProperty.call(source, key)) {
                            target[key] = source[key];
                        }
                    }
                }
            }
            return target;
        }
    }

    if (typeof Object.assign != 'function') {
        instance.objectAssign();
    }

    return this.ektelemetry;
})();

var libraryDispatcher = {
    dispatch: function(event){
        var customEvent = new CustomEvent('TelemetryEvent', { detail: event });
        console.log("Telemetry Event ", event);
        document.dispatchEvent(customEvent);
    }
};
/**
 * This is responsible for syncing of Telemetry
 * @class TelemetrySyncManager
 * @author Krushanu Mohapatra <Krushanu.Mohapatra@tarento.com>
 */

var TelemetrySyncManager = {

    /**
    * This is the telemetry data for the perticular stage.
    * @member {object} _teleData
    * @memberof TelemetryPlugin
    */
    _teleData: [],
    init: function(){
        var instance = this;
        document.addEventListener('TelemetryEvent', this.sendTelemetry);
    },
    sendTelemetry: function(event) {
        var Telemetry = EkTelemetry || Telemetry;
        var telemetryEvent = event.detail;
        var instance = TelemetrySyncManager;
        instance._teleData.push(telemetryEvent);
        if((telemetryEvent.eid.toUpperCase() == "END") || (instance._teleData.length >= Telemetry.config.batchsize)) {
            var telemetryData = instance._teleData;
            var telemetryObj = {
                "id": "ekstep.telemetry",
                "ver": Telemetry._version,
                "ets": (new Date()).getTime(),
                "events": telemetryData
            };
            var headersParam = {};
            if ('undefined' != typeof Telemetry.config.authtoken)
                headersParam["Authorization"] = 'Bearer ' + Telemetry.config.authtoken;

            var fullPath = Telemetry.config.host + Telemetry.config.apislug + Telemetry.config.endpoint;
            headersParam['dataType'] = 'json';
            headersParam["Content-Type"] = "application/json";
            jQuery.ajax({
                url: fullPath,
                type: "POST",
                headers: headersParam,
                data: JSON.stringify(telemetryObj)
            }).done(function(resp) {
                instance._teleData = [];
                console.log("Telemetry API success", resp);
            }).fail(function(error, textStatus, errorThrown) {
                if (error.status == 403) {
                    console.error("Authentication error: ", error);
                } else {
                    console.log("Error while Telemetry sync to server: ", error);
                }
            });
        }
    }
}
TelemetrySyncManager.init();
!function(e,t,r){"use strict";"function"==typeof window.define&&window.define.amd?window.define(r):"undefined"!=typeof module&&module.exports?module.exports=r():t.exports?t.exports=r():t.Fingerprint2=r()}(0,this,function(){"use strict";var e=function(t){if(!(this instanceof e))return new e(t);this.options=this.extend(t,{swfContainerId:"fingerprintjs2",swfPath:"flash/compiled/FontList.swf",detectScreenOrientation:!0,sortPluginsFor:[/palemoon/i],userDefinedFonts:[]}),this.nativeForEach=Array.prototype.forEach,this.nativeMap=Array.prototype.map};return e.prototype={extend:function(e,t){if(null==e)return t;for(var r in e)null!=e[r]&&t[r]!==e[r]&&(t[r]=e[r]);return t},get:function(e){var t=this,r={data:[],addPreprocessedComponent:function(e){var i=e.value;"function"==typeof t.options.preprocessor&&(i=t.options.preprocessor(e.key,i)),r.data.push({key:e.key,value:i})}};r=this.userAgentKey(r),r=this.languageKey(r),r=this.colorDepthKey(r),r=this.deviceMemoryKey(r),r=this.pixelRatioKey(r),r=this.hardwareConcurrencyKey(r),r=this.screenResolutionKey(r),r=this.availableScreenResolutionKey(r),r=this.timezoneOffsetKey(r),r=this.sessionStorageKey(r),r=this.localStorageKey(r),r=this.indexedDbKey(r),r=this.addBehaviorKey(r),r=this.openDatabaseKey(r),r=this.cpuClassKey(r),r=this.platformKey(r),r=this.doNotTrackKey(r),r=this.pluginsKey(r),r=this.canvasKey(r),r=this.webglKey(r),r=this.webglVendorAndRendererKey(r),r=this.adBlockKey(r),r=this.hasLiedLanguagesKey(r),r=this.hasLiedResolutionKey(r),r=this.hasLiedOsKey(r),r=this.hasLiedBrowserKey(r),r=this.touchSupportKey(r),r=this.customEntropyFunction(r),this.fontsKey(r,function(r){var i=[];t.each(r.data,function(e){var t=e.value;t&&"function"==typeof t.join&&(t=t.join(";")),i.push(t)});var n=t.x64hash128(i.join("~~~"),31);return e(n,r.data)})},customEntropyFunction:function(e){return"function"==typeof this.options.customFunction&&e.addPreprocessedComponent({key:"custom",value:this.options.customFunction()}),e},userAgentKey:function(e){return this.options.excludeUserAgent||e.addPreprocessedComponent({key:"user_agent",value:this.getUserAgent()}),e},getUserAgent:function(){return navigator.userAgent},languageKey:function(e){return this.options.excludeLanguage||e.addPreprocessedComponent({key:"language",value:navigator.language||navigator.userLanguage||navigator.browserLanguage||navigator.systemLanguage||""}),e},colorDepthKey:function(e){return this.options.excludeColorDepth||e.addPreprocessedComponent({key:"color_depth",value:window.screen.colorDepth||-1}),e},deviceMemoryKey:function(e){return this.options.excludeDeviceMemory||e.addPreprocessedComponent({key:"device_memory",value:this.getDeviceMemory()}),e},getDeviceMemory:function(){return navigator.deviceMemory||-1},pixelRatioKey:function(e){return this.options.excludePixelRatio||e.addPreprocessedComponent({key:"pixel_ratio",value:this.getPixelRatio()}),e},getPixelRatio:function(){return window.devicePixelRatio||""},screenResolutionKey:function(e){return this.options.excludeScreenResolution?e:this.getScreenResolution(e)},getScreenResolution:function(e){var t;return t=this.options.detectScreenOrientation&&window.screen.height>window.screen.width?[window.screen.height,window.screen.width]:[window.screen.width,window.screen.height],e.addPreprocessedComponent({key:"resolution",value:t}),e},availableScreenResolutionKey:function(e){return this.options.excludeAvailableScreenResolution?e:this.getAvailableScreenResolution(e)},getAvailableScreenResolution:function(e){var t;return window.screen.availWidth&&window.screen.availHeight&&(t=this.options.detectScreenOrientation?window.screen.availHeight>window.screen.availWidth?[window.screen.availHeight,window.screen.availWidth]:[window.screen.availWidth,window.screen.availHeight]:[window.screen.availHeight,window.screen.availWidth]),void 0!==t&&e.addPreprocessedComponent({key:"available_resolution",value:t}),e},timezoneOffsetKey:function(e){return this.options.excludeTimezoneOffset||e.addPreprocessedComponent({key:"timezone_offset",value:(new Date).getTimezoneOffset()}),e},sessionStorageKey:function(e){return!this.options.excludeSessionStorage&&this.hasSessionStorage()&&e.addPreprocessedComponent({key:"session_storage",value:1}),e},localStorageKey:function(e){return!this.options.excludeSessionStorage&&this.hasLocalStorage()&&e.addPreprocessedComponent({key:"local_storage",value:1}),e},indexedDbKey:function(e){return!this.options.excludeIndexedDB&&this.hasIndexedDB()&&e.addPreprocessedComponent({key:"indexed_db",value:1}),e},addBehaviorKey:function(e){return!this.options.excludeAddBehavior&&document.body&&document.body.addBehavior&&e.addPreprocessedComponent({key:"add_behavior",value:1}),e},openDatabaseKey:function(e){return!this.options.excludeOpenDatabase&&window.openDatabase&&e.addPreprocessedComponent({key:"open_database",value:1}),e},cpuClassKey:function(e){return this.options.excludeCpuClass||e.addPreprocessedComponent({key:"cpu_class",value:this.getNavigatorCpuClass()}),e},platformKey:function(e){return this.options.excludePlatform||e.addPreprocessedComponent({key:"navigator_platform",value:this.getNavigatorPlatform()}),e},doNotTrackKey:function(e){return this.options.excludeDoNotTrack||e.addPreprocessedComponent({key:"do_not_track",value:this.getDoNotTrack()}),e},canvasKey:function(e){return!this.options.excludeCanvas&&this.isCanvasSupported()&&e.addPreprocessedComponent({key:"canvas",value:this.getCanvasFp()}),e},webglKey:function(e){return!this.options.excludeWebGL&&this.isWebGlSupported()&&e.addPreprocessedComponent({key:"webgl",value:this.getWebglFp()}),e},webglVendorAndRendererKey:function(e){return!this.options.excludeWebGLVendorAndRenderer&&this.isWebGlSupported()&&e.addPreprocessedComponent({key:"webgl_vendor",value:this.getWebglVendorAndRenderer()}),e},adBlockKey:function(e){return this.options.excludeAdBlock||e.addPreprocessedComponent({key:"adblock",value:this.getAdBlock()}),e},hasLiedLanguagesKey:function(e){return this.options.excludeHasLiedLanguages||e.addPreprocessedComponent({key:"has_lied_languages",value:this.getHasLiedLanguages()}),e},hasLiedResolutionKey:function(e){return this.options.excludeHasLiedResolution||e.addPreprocessedComponent({key:"has_lied_resolution",value:this.getHasLiedResolution()}),e},hasLiedOsKey:function(e){return this.options.excludeHasLiedOs||e.addPreprocessedComponent({key:"has_lied_os",value:this.getHasLiedOs()}),e},hasLiedBrowserKey:function(e){return this.options.excludeHasLiedBrowser||e.addPreprocessedComponent({key:"has_lied_browser",value:this.getHasLiedBrowser()}),e},fontsKey:function(e,t){return this.options.excludeJsFonts?this.flashFontsKey(e,t):this.jsFontsKey(e,t)},flashFontsKey:function(e,t){return this.options.excludeFlashFonts?t(e):this.hasSwfObjectLoaded()&&this.hasMinFlashInstalled()?void 0===this.options.swfPath?t(e):void this.loadSwfAndDetectFonts(function(r){e.addPreprocessedComponent({key:"swf_fonts",value:r.join(";")}),t(e)}):t(e)},jsFontsKey:function(e,t){var r=this;return setTimeout(function(){var i=["monospace","sans-serif","serif"],n=["Andale Mono","Arial","Arial Black","Arial Hebrew","Arial MT","Arial Narrow","Arial Rounded MT Bold","Arial Unicode MS","Bitstream Vera Sans Mono","Book Antiqua","Bookman Old Style","Calibri","Cambria","Cambria Math","Century","Century Gothic","Century Schoolbook","Comic Sans","Comic Sans MS","Consolas","Courier","Courier New","Garamond","Geneva","Georgia","Helvetica","Helvetica Neue","Impact","Lucida Bright","Lucida Calligraphy","Lucida Console","Lucida Fax","LUCIDA GRANDE","Lucida Handwriting","Lucida Sans","Lucida Sans Typewriter","Lucida Sans Unicode","Microsoft Sans Serif","Monaco","Monotype Corsiva","MS Gothic","MS Outlook","MS PGothic","MS Reference Sans Serif","MS Sans Serif","MS Serif","MYRIAD","MYRIAD PRO","Palatino","Palatino Linotype","Segoe Print","Segoe Script","Segoe UI","Segoe UI Light","Segoe UI Semibold","Segoe UI Symbol","Tahoma","Times","Times New Roman","Times New Roman PS","Trebuchet MS","Verdana","Wingdings","Wingdings 2","Wingdings 3"];r.options.extendedJsFonts&&(n=n.concat(["Abadi MT Condensed Light","Academy Engraved LET","ADOBE CASLON PRO","Adobe Garamond","ADOBE GARAMOND PRO","Agency FB","Aharoni","Albertus Extra Bold","Albertus Medium","Algerian","Amazone BT","American Typewriter","American Typewriter Condensed","AmerType Md BT","Andalus","Angsana New","AngsanaUPC","Antique Olive","Aparajita","Apple Chancery","Apple Color Emoji","Apple SD Gothic Neo","Arabic Typesetting","ARCHER","ARNO PRO","Arrus BT","Aurora Cn BT","AvantGarde Bk BT","AvantGarde Md BT","AVENIR","Ayuthaya","Bandy","Bangla Sangam MN","Bank Gothic","BankGothic Md BT","Baskerville","Baskerville Old Face","Batang","BatangChe","Bauer Bodoni","Bauhaus 93","Bazooka","Bell MT","Bembo","Benguiat Bk BT","Berlin Sans FB","Berlin Sans FB Demi","Bernard MT Condensed","BernhardFashion BT","BernhardMod BT","Big Caslon","BinnerD","Blackadder ITC","BlairMdITC TT","Bodoni 72","Bodoni 72 Oldstyle","Bodoni 72 Smallcaps","Bodoni MT","Bodoni MT Black","Bodoni MT Condensed","Bodoni MT Poster Compressed","Bookshelf Symbol 7","Boulder","Bradley Hand","Bradley Hand ITC","Bremen Bd BT","Britannic Bold","Broadway","Browallia New","BrowalliaUPC","Brush Script MT","Californian FB","Calisto MT","Calligrapher","Candara","CaslonOpnface BT","Castellar","Centaur","Cezanne","CG Omega","CG Times","Chalkboard","Chalkboard SE","Chalkduster","Charlesworth","Charter Bd BT","Charter BT","Chaucer","ChelthmITC Bk BT","Chiller","Clarendon","Clarendon Condensed","CloisterBlack BT","Cochin","Colonna MT","Constantia","Cooper Black","Copperplate","Copperplate Gothic","Copperplate Gothic Bold","Copperplate Gothic Light","CopperplGoth Bd BT","Corbel","Cordia New","CordiaUPC","Cornerstone","Coronet","Cuckoo","Curlz MT","DaunPenh","Dauphin","David","DB LCD Temp","DELICIOUS","Denmark","DFKai-SB","Didot","DilleniaUPC","DIN","DokChampa","Dotum","DotumChe","Ebrima","Edwardian Script ITC","Elephant","English 111 Vivace BT","Engravers MT","EngraversGothic BT","Eras Bold ITC","Eras Demi ITC","Eras Light ITC","Eras Medium ITC","EucrosiaUPC","Euphemia","Euphemia UCAS","EUROSTILE","Exotc350 Bd BT","FangSong","Felix Titling","Fixedsys","FONTIN","Footlight MT Light","Forte","FrankRuehl","Fransiscan","Freefrm721 Blk BT","FreesiaUPC","Freestyle Script","French Script MT","FrnkGothITC Bk BT","Fruitger","FRUTIGER","Futura","Futura Bk BT","Futura Lt BT","Futura Md BT","Futura ZBlk BT","FuturaBlack BT","Gabriola","Galliard BT","Gautami","Geeza Pro","Geometr231 BT","Geometr231 Hv BT","Geometr231 Lt BT","GeoSlab 703 Lt BT","GeoSlab 703 XBd BT","Gigi","Gill Sans","Gill Sans MT","Gill Sans MT Condensed","Gill Sans MT Ext Condensed Bold","Gill Sans Ultra Bold","Gill Sans Ultra Bold Condensed","Gisha","Gloucester MT Extra Condensed","GOTHAM","GOTHAM BOLD","Goudy Old Style","Goudy Stout","GoudyHandtooled BT","GoudyOLSt BT","Gujarati Sangam MN","Gulim","GulimChe","Gungsuh","GungsuhChe","Gurmukhi MN","Haettenschweiler","Harlow Solid Italic","Harrington","Heather","Heiti SC","Heiti TC","HELV","Herald","High Tower Text","Hiragino Kaku Gothic ProN","Hiragino Mincho ProN","Hoefler Text","Humanst 521 Cn BT","Humanst521 BT","Humanst521 Lt BT","Imprint MT Shadow","Incised901 Bd BT","Incised901 BT","Incised901 Lt BT","INCONSOLATA","Informal Roman","Informal011 BT","INTERSTATE","IrisUPC","Iskoola Pota","JasmineUPC","Jazz LET","Jenson","Jester","Jokerman","Juice ITC","Kabel Bk BT","Kabel Ult BT","Kailasa","KaiTi","Kalinga","Kannada Sangam MN","Kartika","Kaufmann Bd BT","Kaufmann BT","Khmer UI","KodchiangUPC","Kokila","Korinna BT","Kristen ITC","Krungthep","Kunstler Script","Lao UI","Latha","Leelawadee","Letter Gothic","Levenim MT","LilyUPC","Lithograph","Lithograph Light","Long Island","Lydian BT","Magneto","Maiandra GD","Malayalam Sangam MN","Malgun Gothic","Mangal","Marigold","Marion","Marker Felt","Market","Marlett","Matisse ITC","Matura MT Script Capitals","Meiryo","Meiryo UI","Microsoft Himalaya","Microsoft JhengHei","Microsoft New Tai Lue","Microsoft PhagsPa","Microsoft Tai Le","Microsoft Uighur","Microsoft YaHei","Microsoft Yi Baiti","MingLiU","MingLiU_HKSCS","MingLiU_HKSCS-ExtB","MingLiU-ExtB","Minion","Minion Pro","Miriam","Miriam Fixed","Mistral","Modern","Modern No. 20","Mona Lisa Solid ITC TT","Mongolian Baiti","MONO","MoolBoran","Mrs Eaves","MS LineDraw","MS Mincho","MS PMincho","MS Reference Specialty","MS UI Gothic","MT Extra","MUSEO","MV Boli","Nadeem","Narkisim","NEVIS","News Gothic","News GothicMT","NewsGoth BT","Niagara Engraved","Niagara Solid","Noteworthy","NSimSun","Nyala","OCR A Extended","Old Century","Old English Text MT","Onyx","Onyx BT","OPTIMA","Oriya Sangam MN","OSAKA","OzHandicraft BT","Palace Script MT","Papyrus","Parchment","Party LET","Pegasus","Perpetua","Perpetua Titling MT","PetitaBold","Pickwick","Plantagenet Cherokee","Playbill","PMingLiU","PMingLiU-ExtB","Poor Richard","Poster","PosterBodoni BT","PRINCETOWN LET","Pristina","PTBarnum BT","Pythagoras","Raavi","Rage Italic","Ravie","Ribbon131 Bd BT","Rockwell","Rockwell Condensed","Rockwell Extra Bold","Rod","Roman","Sakkal Majalla","Santa Fe LET","Savoye LET","Sceptre","Script","Script MT Bold","SCRIPTINA","Serifa","Serifa BT","Serifa Th BT","ShelleyVolante BT","Sherwood","Shonar Bangla","Showcard Gothic","Shruti","Signboard","SILKSCREEN","SimHei","Simplified Arabic","Simplified Arabic Fixed","SimSun","SimSun-ExtB","Sinhala Sangam MN","Sketch Rockwell","Skia","Small Fonts","Snap ITC","Snell Roundhand","Socket","Souvenir Lt BT","Staccato222 BT","Steamer","Stencil","Storybook","Styllo","Subway","Swis721 BlkEx BT","Swiss911 XCm BT","Sylfaen","Synchro LET","System","Tamil Sangam MN","Technical","Teletype","Telugu Sangam MN","Tempus Sans ITC","Terminal","Thonburi","Traditional Arabic","Trajan","TRAJAN PRO","Tristan","Tubular","Tunga","Tw Cen MT","Tw Cen MT Condensed","Tw Cen MT Condensed Extra Bold","TypoUpright BT","Unicorn","Univers","Univers CE 55 Medium","Univers Condensed","Utsaah","Vagabond","Vani","Vijaya","Viner Hand ITC","VisualUI","Vivaldi","Vladimir Script","Vrinda","Westminster","WHITNEY","Wide Latin","ZapfEllipt BT","ZapfHumnst BT","ZapfHumnst Dm BT","Zapfino","Zurich BlkEx BT","Zurich Ex BT","ZWAdobeF"])),n=n.concat(r.options.userDefinedFonts);var a=document.getElementsByTagName("body")[0],o=document.createElement("div"),s=document.createElement("div"),d={},l={},h=function(){var e=document.createElement("span");return e.style.position="absolute",e.style.left="-9999px",e.style.fontSize="72px",e.style.lineHeight="normal",e.innerHTML="mmmmmmmmmmlli",e},c=function(e){for(var t=!1,r=0;r<i.length;r++)if(t=e[r].offsetWidth!==d[i[r]]||e[r].offsetHeight!==l[i[r]])return t;return t},u=function(){for(var e=[],t=0,r=i.length;t<r;t++){var n=h();n.style.fontFamily=i[t],o.appendChild(n),e.push(n)}return e}();a.appendChild(o);for(var g=0,p=i.length;g<p;g++)d[i[g]]=u[g].offsetWidth,l[i[g]]=u[g].offsetHeight;var m=function(){for(var e,t,r,a={},o=0,d=n.length;o<d;o++){for(var l=[],c=0,u=i.length;c<u;c++){var g=(e=n[o],t=i[c],r=void 0,(r=h()).style.fontFamily="'"+e+"',"+t,r);s.appendChild(g),l.push(g)}a[n[o]]=l}return a}();a.appendChild(s);for(var f=[],S=0,T=n.length;S<T;S++)c(m[n[S]])&&f.push(n[S]);a.removeChild(s),a.removeChild(o),e.addPreprocessedComponent({key:"js_fonts",value:f}),t(e)},1)},pluginsKey:function(e){return this.options.excludePlugins||(this.isIE()?this.options.excludeIEPlugins||e.addPreprocessedComponent({key:"ie_plugins",value:this.getIEPlugins()}):e.addPreprocessedComponent({key:"regular_plugins",value:this.getRegularPlugins()})),e},getRegularPlugins:function(){var e=[];if(navigator.plugins)for(var t=0,r=navigator.plugins.length;t<r;t++)navigator.plugins[t]&&e.push(navigator.plugins[t]);return this.pluginsShouldBeSorted()&&(e=e.sort(function(e,t){return e.name>t.name?1:e.name<t.name?-1:0})),this.map(e,function(e){var t=this.map(e,function(e){return[e.type,e.suffixes].join("~")}).join(",");return[e.name,e.description,t].join("::")},this)},getIEPlugins:function(){var e=[];if(Object.getOwnPropertyDescriptor&&Object.getOwnPropertyDescriptor(window,"ActiveXObject")||"ActiveXObject"in window){e=this.map(["AcroPDF.PDF","Adodb.Stream","AgControl.AgControl","DevalVRXCtrl.DevalVRXCtrl.1","MacromediaFlashPaper.MacromediaFlashPaper","Msxml2.DOMDocument","Msxml2.XMLHTTP","PDF.PdfCtrl","QuickTime.QuickTime","QuickTimeCheckObject.QuickTimeCheck.1","RealPlayer","RealPlayer.RealPlayer(tm) ActiveX Control (32-bit)","RealVideo.RealVideo(tm) ActiveX Control (32-bit)","Scripting.Dictionary","SWCtl.SWCtl","Shell.UIHelper","ShockwaveFlash.ShockwaveFlash","Skype.Detection","TDCCtl.TDCCtl","WMPlayer.OCX","rmocx.RealPlayer G2 Control","rmocx.RealPlayer G2 Control.1"],function(e){try{return new window.ActiveXObject(e),e}catch(e){return null}})}return navigator.plugins&&(e=e.concat(this.getRegularPlugins())),e},pluginsShouldBeSorted:function(){for(var e=!1,t=0,r=this.options.sortPluginsFor.length;t<r;t++){var i=this.options.sortPluginsFor[t];if(navigator.userAgent.match(i)){e=!0;break}}return e},touchSupportKey:function(e){return this.options.excludeTouchSupport||e.addPreprocessedComponent({key:"touch_support",value:this.getTouchSupport()}),e},hardwareConcurrencyKey:function(e){return this.options.excludeHardwareConcurrency||e.addPreprocessedComponent({key:"hardware_concurrency",value:this.getHardwareConcurrency()}),e},hasSessionStorage:function(){try{return!!window.sessionStorage}catch(e){return!0}},hasLocalStorage:function(){try{return!!window.localStorage}catch(e){return!0}},hasIndexedDB:function(){try{return!!window.indexedDB}catch(e){return!0}},getHardwareConcurrency:function(){return navigator.hardwareConcurrency?navigator.hardwareConcurrency:"unknown"},getNavigatorCpuClass:function(){return navigator.cpuClass?navigator.cpuClass:"unknown"},getNavigatorPlatform:function(){return navigator.platform?navigator.platform:"unknown"},getDoNotTrack:function(){return navigator.doNotTrack?navigator.doNotTrack:navigator.msDoNotTrack?navigator.msDoNotTrack:window.doNotTrack?window.doNotTrack:"unknown"},getTouchSupport:function(){var e=0,t=!1;void 0!==navigator.maxTouchPoints?e=navigator.maxTouchPoints:void 0!==navigator.msMaxTouchPoints&&(e=navigator.msMaxTouchPoints);try{document.createEvent("TouchEvent"),t=!0}catch(e){}return[e,t,"ontouchstart"in window]},getCanvasFp:function(){var e=[],t=document.createElement("canvas");t.width=2e3,t.height=200,t.style.display="inline";var r=t.getContext("2d");return r.rect(0,0,10,10),r.rect(2,2,6,6),e.push("canvas winding:"+(!1===r.isPointInPath(5,5,"evenodd")?"yes":"no")),r.textBaseline="alphabetic",r.fillStyle="#f60",r.fillRect(125,1,62,20),r.fillStyle="#069",this.options.dontUseFakeFontInCanvas?r.font="11pt Arial":r.font="11pt no-real-font-123",r.fillText("Cwm fjordbank glyphs vext quiz, \ud83d\ude03",2,15),r.fillStyle="rgba(102, 204, 0, 0.2)",r.font="18pt Arial",r.fillText("Cwm fjordbank glyphs vext quiz, \ud83d\ude03",4,45),r.globalCompositeOperation="multiply",r.fillStyle="rgb(255,0,255)",r.beginPath(),r.arc(50,50,50,0,2*Math.PI,!0),r.closePath(),r.fill(),r.fillStyle="rgb(0,255,255)",r.beginPath(),r.arc(100,50,50,0,2*Math.PI,!0),r.closePath(),r.fill(),r.fillStyle="rgb(255,255,0)",r.beginPath(),r.arc(75,100,50,0,2*Math.PI,!0),r.closePath(),r.fill(),r.fillStyle="rgb(255,0,255)",r.arc(75,75,75,0,2*Math.PI,!0),r.arc(75,75,25,0,2*Math.PI,!0),r.fill("evenodd"),t.toDataURL&&e.push("canvas fp:"+t.toDataURL()),e.join("~")},getWebglFp:function(){var e,t=function(t){return e.clearColor(0,0,0,1),e.enable(e.DEPTH_TEST),e.depthFunc(e.LEQUAL),e.clear(e.COLOR_BUFFER_BIT|e.DEPTH_BUFFER_BIT),"["+t[0]+", "+t[1]+"]"};if(!(e=this.getWebglCanvas()))return null;var r=[],i=e.createBuffer();e.bindBuffer(e.ARRAY_BUFFER,i);var n=new Float32Array([-.2,-.9,0,.4,-.26,0,0,.732134444,0]);e.bufferData(e.ARRAY_BUFFER,n,e.STATIC_DRAW),i.itemSize=3,i.numItems=3;var a=e.createProgram(),o=e.createShader(e.VERTEX_SHADER);e.shaderSource(o,"attribute vec2 attrVertex;varying vec2 varyinTexCoordinate;uniform vec2 uniformOffset;void main(){varyinTexCoordinate=attrVertex+uniformOffset;gl_Position=vec4(attrVertex,0,1);}"),e.compileShader(o);var s=e.createShader(e.FRAGMENT_SHADER);e.shaderSource(s,"precision mediump float;varying vec2 varyinTexCoordinate;void main() {gl_FragColor=vec4(varyinTexCoordinate,0,1);}"),e.compileShader(s),e.attachShader(a,o),e.attachShader(a,s),e.linkProgram(a),e.useProgram(a),a.vertexPosAttrib=e.getAttribLocation(a,"attrVertex"),a.offsetUniform=e.getUniformLocation(a,"uniformOffset"),e.enableVertexAttribArray(a.vertexPosArray),e.vertexAttribPointer(a.vertexPosAttrib,i.itemSize,e.FLOAT,!1,0,0),e.uniform2f(a.offsetUniform,1,1),e.drawArrays(e.TRIANGLE_STRIP,0,i.numItems);try{r.push(e.canvas.toDataURL())}catch(e){}r.push("extensions:"+(e.getSupportedExtensions()||[]).join(";")),r.push("webgl aliased line width range:"+t(e.getParameter(e.ALIASED_LINE_WIDTH_RANGE))),r.push("webgl aliased point size range:"+t(e.getParameter(e.ALIASED_POINT_SIZE_RANGE))),r.push("webgl alpha bits:"+e.getParameter(e.ALPHA_BITS)),r.push("webgl antialiasing:"+(e.getContextAttributes().antialias?"yes":"no")),r.push("webgl blue bits:"+e.getParameter(e.BLUE_BITS)),r.push("webgl depth bits:"+e.getParameter(e.DEPTH_BITS)),r.push("webgl green bits:"+e.getParameter(e.GREEN_BITS)),r.push("webgl max anisotropy:"+function(e){var t=e.getExtension("EXT_texture_filter_anisotropic")||e.getExtension("WEBKIT_EXT_texture_filter_anisotropic")||e.getExtension("MOZ_EXT_texture_filter_anisotropic");if(t){var r=e.getParameter(t.MAX_TEXTURE_MAX_ANISOTROPY_EXT);return 0===r&&(r=2),r}return null}(e)),r.push("webgl max combined texture image units:"+e.getParameter(e.MAX_COMBINED_TEXTURE_IMAGE_UNITS)),r.push("webgl max cube map texture size:"+e.getParameter(e.MAX_CUBE_MAP_TEXTURE_SIZE)),r.push("webgl max fragment uniform vectors:"+e.getParameter(e.MAX_FRAGMENT_UNIFORM_VECTORS)),r.push("webgl max render buffer size:"+e.getParameter(e.MAX_RENDERBUFFER_SIZE)),r.push("webgl max texture image units:"+e.getParameter(e.MAX_TEXTURE_IMAGE_UNITS)),r.push("webgl max texture size:"+e.getParameter(e.MAX_TEXTURE_SIZE)),r.push("webgl max varying vectors:"+e.getParameter(e.MAX_VARYING_VECTORS)),r.push("webgl max vertex attribs:"+e.getParameter(e.MAX_VERTEX_ATTRIBS)),r.push("webgl max vertex texture image units:"+e.getParameter(e.MAX_VERTEX_TEXTURE_IMAGE_UNITS)),r.push("webgl max vertex uniform vectors:"+e.getParameter(e.MAX_VERTEX_UNIFORM_VECTORS)),r.push("webgl max viewport dims:"+t(e.getParameter(e.MAX_VIEWPORT_DIMS))),r.push("webgl red bits:"+e.getParameter(e.RED_BITS)),r.push("webgl renderer:"+e.getParameter(e.RENDERER)),r.push("webgl shading language version:"+e.getParameter(e.SHADING_LANGUAGE_VERSION)),r.push("webgl stencil bits:"+e.getParameter(e.STENCIL_BITS)),r.push("webgl vendor:"+e.getParameter(e.VENDOR)),r.push("webgl version:"+e.getParameter(e.VERSION));try{var d=e.getExtension("WEBGL_debug_renderer_info");d&&(r.push("webgl unmasked vendor:"+e.getParameter(d.UNMASKED_VENDOR_WEBGL)),r.push("webgl unmasked renderer:"+e.getParameter(d.UNMASKED_RENDERER_WEBGL)))}catch(e){}return e.getShaderPrecisionFormat?(r.push("webgl vertex shader high float precision:"+e.getShaderPrecisionFormat(e.VERTEX_SHADER,e.HIGH_FLOAT).precision),r.push("webgl vertex shader high float precision rangeMin:"+e.getShaderPrecisionFormat(e.VERTEX_SHADER,e.HIGH_FLOAT).rangeMin),r.push("webgl vertex shader high float precision rangeMax:"+e.getShaderPrecisionFormat(e.VERTEX_SHADER,e.HIGH_FLOAT).rangeMax),r.push("webgl vertex shader medium float precision:"+e.getShaderPrecisionFormat(e.VERTEX_SHADER,e.MEDIUM_FLOAT).precision),r.push("webgl vertex shader medium float precision rangeMin:"+e.getShaderPrecisionFormat(e.VERTEX_SHADER,e.MEDIUM_FLOAT).rangeMin),r.push("webgl vertex shader medium float precision rangeMax:"+e.getShaderPrecisionFormat(e.VERTEX_SHADER,e.MEDIUM_FLOAT).rangeMax),r.push("webgl vertex shader low float precision:"+e.getShaderPrecisionFormat(e.VERTEX_SHADER,e.LOW_FLOAT).precision),r.push("webgl vertex shader low float precision rangeMin:"+e.getShaderPrecisionFormat(e.VERTEX_SHADER,e.LOW_FLOAT).rangeMin),r.push("webgl vertex shader low float precision rangeMax:"+e.getShaderPrecisionFormat(e.VERTEX_SHADER,e.LOW_FLOAT).rangeMax),r.push("webgl fragment shader high float precision:"+e.getShaderPrecisionFormat(e.FRAGMENT_SHADER,e.HIGH_FLOAT).precision),r.push("webgl fragment shader high float precision rangeMin:"+e.getShaderPrecisionFormat(e.FRAGMENT_SHADER,e.HIGH_FLOAT).rangeMin),r.push("webgl fragment shader high float precision rangeMax:"+e.getShaderPrecisionFormat(e.FRAGMENT_SHADER,e.HIGH_FLOAT).rangeMax),r.push("webgl fragment shader medium float precision:"+e.getShaderPrecisionFormat(e.FRAGMENT_SHADER,e.MEDIUM_FLOAT).precision),r.push("webgl fragment shader medium float precision rangeMin:"+e.getShaderPrecisionFormat(e.FRAGMENT_SHADER,e.MEDIUM_FLOAT).rangeMin),r.push("webgl fragment shader medium float precision rangeMax:"+e.getShaderPrecisionFormat(e.FRAGMENT_SHADER,e.MEDIUM_FLOAT).rangeMax),r.push("webgl fragment shader low float precision:"+e.getShaderPrecisionFormat(e.FRAGMENT_SHADER,e.LOW_FLOAT).precision),r.push("webgl fragment shader low float precision rangeMin:"+e.getShaderPrecisionFormat(e.FRAGMENT_SHADER,e.LOW_FLOAT).rangeMin),r.push("webgl fragment shader low float precision rangeMax:"+e.getShaderPrecisionFormat(e.FRAGMENT_SHADER,e.LOW_FLOAT).rangeMax),r.push("webgl vertex shader high int precision:"+e.getShaderPrecisionFormat(e.VERTEX_SHADER,e.HIGH_INT).precision),r.push("webgl vertex shader high int precision rangeMin:"+e.getShaderPrecisionFormat(e.VERTEX_SHADER,e.HIGH_INT).rangeMin),r.push("webgl vertex shader high int precision rangeMax:"+e.getShaderPrecisionFormat(e.VERTEX_SHADER,e.HIGH_INT).rangeMax),r.push("webgl vertex shader medium int precision:"+e.getShaderPrecisionFormat(e.VERTEX_SHADER,e.MEDIUM_INT).precision),r.push("webgl vertex shader medium int precision rangeMin:"+e.getShaderPrecisionFormat(e.VERTEX_SHADER,e.MEDIUM_INT).rangeMin),r.push("webgl vertex shader medium int precision rangeMax:"+e.getShaderPrecisionFormat(e.VERTEX_SHADER,e.MEDIUM_INT).rangeMax),r.push("webgl vertex shader low int precision:"+e.getShaderPrecisionFormat(e.VERTEX_SHADER,e.LOW_INT).precision),r.push("webgl vertex shader low int precision rangeMin:"+e.getShaderPrecisionFormat(e.VERTEX_SHADER,e.LOW_INT).rangeMin),r.push("webgl vertex shader low int precision rangeMax:"+e.getShaderPrecisionFormat(e.VERTEX_SHADER,e.LOW_INT).rangeMax),r.push("webgl fragment shader high int precision:"+e.getShaderPrecisionFormat(e.FRAGMENT_SHADER,e.HIGH_INT).precision),r.push("webgl fragment shader high int precision rangeMin:"+e.getShaderPrecisionFormat(e.FRAGMENT_SHADER,e.HIGH_INT).rangeMin),r.push("webgl fragment shader high int precision rangeMax:"+e.getShaderPrecisionFormat(e.FRAGMENT_SHADER,e.HIGH_INT).rangeMax),r.push("webgl fragment shader medium int precision:"+e.getShaderPrecisionFormat(e.FRAGMENT_SHADER,e.MEDIUM_INT).precision),r.push("webgl fragment shader medium int precision rangeMin:"+e.getShaderPrecisionFormat(e.FRAGMENT_SHADER,e.MEDIUM_INT).rangeMin),r.push("webgl fragment shader medium int precision rangeMax:"+e.getShaderPrecisionFormat(e.FRAGMENT_SHADER,e.MEDIUM_INT).rangeMax),r.push("webgl fragment shader low int precision:"+e.getShaderPrecisionFormat(e.FRAGMENT_SHADER,e.LOW_INT).precision),r.push("webgl fragment shader low int precision rangeMin:"+e.getShaderPrecisionFormat(e.FRAGMENT_SHADER,e.LOW_INT).rangeMin),r.push("webgl fragment shader low int precision rangeMax:"+e.getShaderPrecisionFormat(e.FRAGMENT_SHADER,e.LOW_INT).rangeMax),r.join("~")):r.join("~")},getWebglVendorAndRenderer:function(){try{var e=this.getWebglCanvas(),t=e.getExtension("WEBGL_debug_renderer_info");return e.getParameter(t.UNMASKED_VENDOR_WEBGL)+"~"+e.getParameter(t.UNMASKED_RENDERER_WEBGL)}catch(e){return null}},getAdBlock:function(){var e=document.createElement("div");e.innerHTML="&nbsp;",e.className="adsbox";var t=!1;try{document.body.appendChild(e),t=0===document.getElementsByClassName("adsbox")[0].offsetHeight,document.body.removeChild(e)}catch(e){t=!1}return t},getHasLiedLanguages:function(){if(void 0!==navigator.languages)try{if(navigator.languages[0].substr(0,2)!==navigator.language.substr(0,2))return!0}catch(e){return!0}return!1},getHasLiedResolution:function(){return window.screen.width<window.screen.availWidth||window.screen.height<window.screen.availHeight},getHasLiedOs:function(){var e,t=navigator.userAgent.toLowerCase(),r=navigator.oscpu,i=navigator.platform.toLowerCase();if(e=t.indexOf("windows phone")>=0?"Windows Phone":t.indexOf("win")>=0?"Windows":t.indexOf("android")>=0?"Android":t.indexOf("linux")>=0?"Linux":t.indexOf("iphone")>=0||t.indexOf("ipad")>=0?"iOS":t.indexOf("mac")>=0?"Mac":"Other",("ontouchstart"in window||navigator.maxTouchPoints>0||navigator.msMaxTouchPoints>0)&&"Windows Phone"!==e&&"Android"!==e&&"iOS"!==e&&"Other"!==e)return!0;if(void 0!==r){if((r=r.toLowerCase()).indexOf("win")>=0&&"Windows"!==e&&"Windows Phone"!==e)return!0;if(r.indexOf("linux")>=0&&"Linux"!==e&&"Android"!==e)return!0;if(r.indexOf("mac")>=0&&"Mac"!==e&&"iOS"!==e)return!0;if((-1===r.indexOf("win")&&-1===r.indexOf("linux")&&-1===r.indexOf("mac"))!=("Other"===e))return!0}return i.indexOf("win")>=0&&"Windows"!==e&&"Windows Phone"!==e||((i.indexOf("linux")>=0||i.indexOf("android")>=0||i.indexOf("pike")>=0)&&"Linux"!==e&&"Android"!==e||((i.indexOf("mac")>=0||i.indexOf("ipad")>=0||i.indexOf("ipod")>=0||i.indexOf("iphone")>=0)&&"Mac"!==e&&"iOS"!==e||((-1===i.indexOf("win")&&-1===i.indexOf("linux")&&-1===i.indexOf("mac"))!=("Other"===e)||void 0===navigator.plugins&&"Windows"!==e&&"Windows Phone"!==e)))},getHasLiedBrowser:function(){var e,t=navigator.userAgent.toLowerCase(),r=navigator.productSub;if(("Chrome"===(e=t.indexOf("firefox")>=0?"Firefox":t.indexOf("opera")>=0||t.indexOf("opr")>=0?"Opera":t.indexOf("chrome")>=0?"Chrome":t.indexOf("safari")>=0?"Safari":t.indexOf("trident")>=0?"Internet Explorer":"Other")||"Safari"===e||"Opera"===e)&&"20030107"!==r)return!0;var i,n=eval.toString().length;if(37===n&&"Safari"!==e&&"Firefox"!==e&&"Other"!==e)return!0;if(39===n&&"Internet Explorer"!==e&&"Other"!==e)return!0;if(33===n&&"Chrome"!==e&&"Opera"!==e&&"Other"!==e)return!0;try{throw"a"}catch(e){try{e.toSource(),i=!0}catch(e){i=!1}}return!(!i||"Firefox"===e||"Other"===e)},isCanvasSupported:function(){var e=document.createElement("canvas");return!(!e.getContext||!e.getContext("2d"))},isWebGlSupported:function(){if(!this.isCanvasSupported())return!1;var e=this.getWebglCanvas();return!!window.WebGLRenderingContext&&!!e},isIE:function(){return"Microsoft Internet Explorer"===navigator.appName||!("Netscape"!==navigator.appName||!/Trident/.test(navigator.userAgent))},hasSwfObjectLoaded:function(){return void 0!==window.swfobject},hasMinFlashInstalled:function(){return window.swfobject.hasFlashPlayerVersion("9.0.0")},addFlashDivNode:function(){var e=document.createElement("div");e.setAttribute("id",this.options.swfContainerId),document.body.appendChild(e)},loadSwfAndDetectFonts:function(e){var t="___fp_swf_loaded";window[t]=function(t){e(t)};var r=this.options.swfContainerId;this.addFlashDivNode();var i={onReady:t};window.swfobject.embedSWF(this.options.swfPath,r,"1","1","9.0.0",!1,i,{allowScriptAccess:"always",menu:"false"},{})},getWebglCanvas:function(){var e=document.createElement("canvas"),t=null;try{t=e.getContext("webgl")||e.getContext("experimental-webgl")}catch(e){}return t||(t=null),t},each:function(e,t,r){if(null!==e)if(this.nativeForEach&&e.forEach===this.nativeForEach)e.forEach(t,r);else if(e.length===+e.length){for(var i=0,n=e.length;i<n;i++)if(t.call(r,e[i],i,e)==={})return}else for(var a in e)if(e.hasOwnProperty(a)&&t.call(r,e[a],a,e)==={})return},map:function(e,t,r){var i=[];return null==e?i:this.nativeMap&&e.map===this.nativeMap?e.map(t,r):(this.each(e,function(e,n,a){i[i.length]=t.call(r,e,n,a)}),i)},x64Add:function(e,t){e=[e[0]>>>16,65535&e[0],e[1]>>>16,65535&e[1]],t=[t[0]>>>16,65535&t[0],t[1]>>>16,65535&t[1]];var r=[0,0,0,0];return r[3]+=e[3]+t[3],r[2]+=r[3]>>>16,r[3]&=65535,r[2]+=e[2]+t[2],r[1]+=r[2]>>>16,r[2]&=65535,r[1]+=e[1]+t[1],r[0]+=r[1]>>>16,r[1]&=65535,r[0]+=e[0]+t[0],r[0]&=65535,[r[0]<<16|r[1],r[2]<<16|r[3]]},x64Multiply:function(e,t){e=[e[0]>>>16,65535&e[0],e[1]>>>16,65535&e[1]],t=[t[0]>>>16,65535&t[0],t[1]>>>16,65535&t[1]];var r=[0,0,0,0];return r[3]+=e[3]*t[3],r[2]+=r[3]>>>16,r[3]&=65535,r[2]+=e[2]*t[3],r[1]+=r[2]>>>16,r[2]&=65535,r[2]+=e[3]*t[2],r[1]+=r[2]>>>16,r[2]&=65535,r[1]+=e[1]*t[3],r[0]+=r[1]>>>16,r[1]&=65535,r[1]+=e[2]*t[2],r[0]+=r[1]>>>16,r[1]&=65535,r[1]+=e[3]*t[1],r[0]+=r[1]>>>16,r[1]&=65535,r[0]+=e[0]*t[3]+e[1]*t[2]+e[2]*t[1]+e[3]*t[0],r[0]&=65535,[r[0]<<16|r[1],r[2]<<16|r[3]]},x64Rotl:function(e,t){return 32===(t%=64)?[e[1],e[0]]:t<32?[e[0]<<t|e[1]>>>32-t,e[1]<<t|e[0]>>>32-t]:(t-=32,[e[1]<<t|e[0]>>>32-t,e[0]<<t|e[1]>>>32-t])},x64LeftShift:function(e,t){return 0===(t%=64)?e:t<32?[e[0]<<t|e[1]>>>32-t,e[1]<<t]:[e[1]<<t-32,0]},x64Xor:function(e,t){return[e[0]^t[0],e[1]^t[1]]},x64Fmix:function(e){return e=this.x64Xor(e,[0,e[0]>>>1]),e=this.x64Multiply(e,[4283543511,3981806797]),e=this.x64Xor(e,[0,e[0]>>>1]),e=this.x64Multiply(e,[3301882366,444984403]),e=this.x64Xor(e,[0,e[0]>>>1])},x64hash128:function(e,t){e=e||"",t=t||0;for(var r=e.length%16,i=e.length-r,n=[0,t],a=[0,t],o=[0,0],s=[0,0],d=[2277735313,289559509],l=[1291169091,658871167],h=0;h<i;h+=16)o=[255&e.charCodeAt(h+4)|(255&e.charCodeAt(h+5))<<8|(255&e.charCodeAt(h+6))<<16|(255&e.charCodeAt(h+7))<<24,255&e.charCodeAt(h)|(255&e.charCodeAt(h+1))<<8|(255&e.charCodeAt(h+2))<<16|(255&e.charCodeAt(h+3))<<24],s=[255&e.charCodeAt(h+12)|(255&e.charCodeAt(h+13))<<8|(255&e.charCodeAt(h+14))<<16|(255&e.charCodeAt(h+15))<<24,255&e.charCodeAt(h+8)|(255&e.charCodeAt(h+9))<<8|(255&e.charCodeAt(h+10))<<16|(255&e.charCodeAt(h+11))<<24],o=this.x64Multiply(o,d),o=this.x64Rotl(o,31),o=this.x64Multiply(o,l),n=this.x64Xor(n,o),n=this.x64Rotl(n,27),n=this.x64Add(n,a),n=this.x64Add(this.x64Multiply(n,[0,5]),[0,1390208809]),s=this.x64Multiply(s,l),s=this.x64Rotl(s,33),s=this.x64Multiply(s,d),a=this.x64Xor(a,s),a=this.x64Rotl(a,31),a=this.x64Add(a,n),a=this.x64Add(this.x64Multiply(a,[0,5]),[0,944331445]);switch(o=[0,0],s=[0,0],r){case 15:s=this.x64Xor(s,this.x64LeftShift([0,e.charCodeAt(h+14)],48));case 14:s=this.x64Xor(s,this.x64LeftShift([0,e.charCodeAt(h+13)],40));case 13:s=this.x64Xor(s,this.x64LeftShift([0,e.charCodeAt(h+12)],32));case 12:s=this.x64Xor(s,this.x64LeftShift([0,e.charCodeAt(h+11)],24));case 11:s=this.x64Xor(s,this.x64LeftShift([0,e.charCodeAt(h+10)],16));case 10:s=this.x64Xor(s,this.x64LeftShift([0,e.charCodeAt(h+9)],8));case 9:s=this.x64Xor(s,[0,e.charCodeAt(h+8)]),s=this.x64Multiply(s,l),s=this.x64Rotl(s,33),s=this.x64Multiply(s,d),a=this.x64Xor(a,s);case 8:o=this.x64Xor(o,this.x64LeftShift([0,e.charCodeAt(h+7)],56));case 7:o=this.x64Xor(o,this.x64LeftShift([0,e.charCodeAt(h+6)],48));case 6:o=this.x64Xor(o,this.x64LeftShift([0,e.charCodeAt(h+5)],40));case 5:o=this.x64Xor(o,this.x64LeftShift([0,e.charCodeAt(h+4)],32));case 4:o=this.x64Xor(o,this.x64LeftShift([0,e.charCodeAt(h+3)],24));case 3:o=this.x64Xor(o,this.x64LeftShift([0,e.charCodeAt(h+2)],16));case 2:o=this.x64Xor(o,this.x64LeftShift([0,e.charCodeAt(h+1)],8));case 1:o=this.x64Xor(o,[0,e.charCodeAt(h)]),o=this.x64Multiply(o,d),o=this.x64Rotl(o,31),o=this.x64Multiply(o,l),n=this.x64Xor(n,o)}return n=this.x64Xor(n,[0,e.length]),a=this.x64Xor(a,[0,e.length]),n=this.x64Add(n,a),a=this.x64Add(a,n),n=this.x64Fmix(n),a=this.x64Fmix(a),n=this.x64Add(n,a),a=this.x64Add(a,n),("00000000"+(n[0]>>>0).toString(16)).slice(-8)+("00000000"+(n[1]>>>0).toString(16)).slice(-8)+("00000000"+(a[0]>>>0).toString(16)).slice(-8)+("00000000"+(a[1]>>>0).toString(16)).slice(-8)}},e.VERSION="1.5.1",e});
/**
 * @author Santhosh Vasabhaktula <santhosh@ilimi.in>
 */
/* istanbul ignore next. Fabric extension - cannot be tested */
if(window.fabric) {
    window.fabric.Object.prototype.toObject = (function(toObject) {
        return function() {
            return window.fabric.util.object.extend(toObject.call(this), {
                meta: this.meta
            });
        };
    })(window.fabric.Object.prototype.toObject);
}

var content_editor = function() {};
content_editor.prototype.jQuery = window.$;
content_editor.prototype._ = window._;
window.org.ekstep.contenteditor = new content_editor();
content_editor = undefined;

window.ServiceConstants = {
    SEARCH_SERVICE: "search",
    POPUP_SERVICE: "popup",
    CONTENT_SERVICE: "content",
    ASSESSMENT_SERVICE: "assessment",
    LANGUAGE_SERVICE: "language",
    META_SERVICE: "meta",
    ASSET_SERVICE: "asset",
    TELEMETRY_SERVICE: "telemetry",
    DIALCODE_SERVICE: "dialcode"
}

window.ManagerConstants = {
    EVENT_MANAGER: "event",
    MEDIA_MANAGER: "media",
    PLUGIN_MANAGER: "plugin",
    RESOURCE_MANAGER: "resource",
    STAGE_MANAGER: "stage",
    TOOLBAR_MANAGER: "toolbar"
}
org.ekstep.contenteditor.config = {
    baseURL: '',
    apislug: '/action',
    build_number: 'BUILDNUMBER',
    pluginRepo: '/content-plugins',
    aws_s3_urls: ["https://s3.ap-south-1.amazonaws.com/ekstep-public-dev/", "https://ekstep-public-dev.s3-ap-south-1.amazonaws.com/"],
    plugins: [
        { "id": "org.ekstep.developer", "ver": "1.0", "type": "plugin" },
        { "id": "org.ekstep.ceheader", "ver": "1.0", "type": "plugin" },
        { "id": "org.ekstep.whatsnew", "ver": "1.0", "type": "plugin" },
        { "id": "org.ekstep.todo", "ver": "1.0", "type": "plugin" },        
        { "id": "org.ekstep.review", "ver": "1.0", "type": "plugin" },
        { "id": "org.ekstep.preview", "ver": "1.1", "type": "plugin" },
        { "id": "org.ekstep.editcontentmeta", "ver": "1.1", "type": "plugin" },
        { "id": "org.ekstep.quiz", "ver": "1.0", "type": "plugin" }
    ],
    corePluginsPackaged: true,
    dispatcher: "piwik",
    localDispatcherEndpoint: "/app/telemetry",
    previewURL: "/content/preview/preview.html"
}

org.ekstep.contenteditor.extendedConfig = {
    corePlugins: ["text", "audio", "div", "hotspot", "image", "shape", "scribble", "htext"],
    corePluginMapping: {
        "text": "org.ekstep.text", 
        "image": "org.ekstep.image", 
        "shape": "org.ekstep.shape",
        "stage": "org.ekstep.stage",
        "hotspot": "org.ekstep.hotspot",
        "scribble": "org.ekstep.scribblepad",
        "htext": "org.ekstep.text",
        "audio": "org.ekstep.audio"
    },
    useProxyForURL: false
}

org.ekstep.contenteditor.baseConfigManifest = [{
    "propertyName": "autoplay",
    "title": "Auto play",
    "description": "Set the element's playability",
    "dataType": "boolean",
    "required": true,
    "defaultValue": false
}, {
    "propertyName": "visible",
    "title": "Visible",
    "description": "Set the element's Visibility",
    "dataType": "boolean",
    "required": true,
    "defaultValue": true
}, {
    "propertyName": "stroke",
    "title": "Border Color",
    "description": "Set the border color for element",
    "dataType": "colorpicker",
    "required": true,
    "defaultValue": "rgba(255, 255, 255, 0)"
}]
/**
 * @author Santhosh Vasabhaktula <santhosh@ilimi.in>
 */

org.ekstep.contenteditor.init = function(context, config, $scope, $document, callback) {
    org.ekstep.contenteditor._mergeConfig(config);
    org.ekstep.contenteditor._initServices();
    org.ekstep.contenteditor.globalContext = context;
    org.ekstep.contenteditor.toolbarManager.setScope($scope);
    org.ekstep.contenteditor._loadDefaultPlugins(context, callback);
    //org.ekstep.contenteditor._backwardCompatibility();
}

org.ekstep.contenteditor._backwardCompatibility = function() {
    /* Deprecated variables */
    EkstepEditorAPI.apislug = org.ekstep.contenteditor.config.apislug;
    EkstepEditorAPI.baseURL = org.ekstep.contenteditor.config.baseURL;
    EkstepEditorAPI.absURL = org.ekstep.contenteditor.config.absURL;
    EkstepEditorAPI.globalContext = org.ekstep.contenteditor.globalContext;
}

org.ekstep.contenteditor._initServices = function() {
    org.ekstep.services.config = {
        baseURL: org.ekstep.contenteditor.config.baseURL,
        apislug: org.ekstep.contenteditor.config.apislug,
        searchCriteria: org.ekstep.contenteditor.config.searchCriteria || {} 
    }
    org.ekstep.pluginframework.initialize({
        env: 'editor',
        jQuery: org.ekstep.contenteditor.jQuery,
        pluginRepo: org.ekstep.contenteditor.config.pluginRepo,
        build_number: org.ekstep.contenteditor.config.build_number
    });
}

org.ekstep.contenteditor._mergeConfig = function(config) {
    config = config || {};
    // Override default config
    org.ekstep.contenteditor.config = _.assign(org.ekstep.contenteditor.config, config);
    // Set non overridable config
    org.ekstep.contenteditor.config = _.assign(org.ekstep.contenteditor.config, org.ekstep.contenteditor.extendedConfig);
}

org.ekstep.contenteditor._loadDefaultPlugins = function(context, callback) {    
    if (org.ekstep.contenteditor.config.corePluginsPackaged === true) org.ekstep.contenteditor.jQuery("body").append($("<script type='text/javascript' src='scripts/coreplugins.js?" + org.ekstep.contenteditor.config.build_number + "'>"));
    org.ekstep.pluginframework.eventManager.enableEvents = false;
    org.ekstep.pluginframework.pluginManager.loadAllPlugins(org.ekstep.contenteditor.config.plugins, undefined, function() {        
        org.ekstep.pluginframework.eventManager.enableEvents = true;
        callback();        
    });
}

// Prepare context and config data from url/parentwindow/window
// org.ekstep.contenteditor.window_context = {}
// org.ekstep.contenteditor.window_config = {}
// getWindowContext();
// getWindowConfig();
// 
org.ekstep.contenteditor.getWindowContext = function() {
    return org.ekstep.contenteditor.getParameterByName('context') || (window.parent ? window.parent.context : undefined) || window.context || {};
}

org.ekstep.contenteditor.getWindowConfig = function() {
    return org.ekstep.contenteditor.getParameterByName('config') || (window.parent ? window.parent.config : undefined) || window.config || {};
}

org.ekstep.contenteditor.getParameterByName = function(name, url) {
    if (!url) url = window.location.href;
    name = name.replace(/[\[\]]/g, "\\$&");
    var regex = new RegExp("[?&]" + name + "(=([^&#]*)|&|#|$)"),
        results = regex.exec(url);
    if (!results) return undefined;
    if (!results[2]) return undefined;
    var value = decodeURIComponent(results[2].replace(/\+/g, " "));
    return JSON.parse(value);
}

/**
 * The Content Editor API is the core interface of the plugins with the rest of the editor framework. It allows the plugins
 * to access the framework resources, launch popups, and handle events raised by the framework. Plugins should not call any
 * other framework classes directly.
 * 
 * @class org.ekstep.contenteditor.api
 * @author Santhosh Vasabhaktula <santhosh@ilimi.in>
 */
window.org.ekstep.contenteditor.api = {
    /**
     * Handle for JQuery. All plugins should use this instead of using '$' directly
     * 
     * @member {Object} jQuery
     * @memberof org.ekstep.contenteditor.api
     */
    jQuery: org.ekstep.contenteditor.jQuery,

    /**
     * Handle for Lodash Library. All plugins should use this instead of using '_' directly
     * 
     * @member {Object} _
     * @memberof org.ekstep.contenteditor.api
     */
    _: org.ekstep.contenteditor._,

    /**
     * Add an object to the context
     * 
     * @param {String} key   Key
     * @param {Object} value Value
     * @memberof org.ekstep.contenteditor.api
     */
    setContext: function(key, value) {
        org.ekstep.contenteditor.globalContext[key] = value;
    },

    /**
     * Get the context variable
     * 
     * @param  {String} key Key
     * @return {object}     Value
     * @memberof org.ekstep.contenteditor.api
     */
    getContext: function(key) {
        return org.ekstep.contenteditor.globalContext[key];
    },

    /**
     * Get all context attributes
     * @return {map} Map of key values
     */
    getAllContext: function() {
        return org.ekstep.contenteditor.globalContext;
    },

    /**
     * Add or update a configuration property
     * 
     * @param {String} key   Key
     * @param {Object} value Value
     * @memberof org.ekstep.contenteditor.api
     */
    setConfig: function(key, value) {
        org.ekstep.contenteditor.config[key] = value;
    },

    /**
     * Get the config variable
     * 
     * @param  {String} key Key
     * @return {object}     Value
     * @memberof org.ekstep.contenteditor.api
     */
    getConfig: function(key) {
        return org.ekstep.contenteditor.config[key];
    },

    /**
     * Get all config attributes
     * @return {map} Map of key values
     */
    getAllConfig: function() {
        return org.ekstep.contenteditor.config;
    },

    /**
     * Register an event listener callback function for the events raised by the framework.
     * @param type {string} name of the event (e.g. org.ekstep.quickstart:configure)
     * @param callback {function} callback function
     * @param scope {object} the scope of the callback (use this)
     * @memberof org.ekstep.contenteditor.api
     */
    addEventListener: function(type, callback, scope) {
        org.ekstep.pluginframework.eventManager.addEventListener(type, callback, scope);
    },

    /**
     * Fires an event to the framework, allowing other plugins who may have registered to receive the callback notification. All
     * communication between the framework and other plugins is via the events.
     * @param type {string} name of the event to fire (e.g. org.ekstep.quickstart:configure)
     * @param data {object} event data to carry along with the notification
     * @param target {object} the scope of the event (use this)
     * @memberof org.ekstep.contenteditor.api
     */
    dispatchEvent: function(type, data, target) {
        org.ekstep.pluginframework.eventManager.dispatchEvent(type, data, target);
    },

    /**
     * Remove an event listener to an event. Plugins should cleanup when they are removed.
     * @param type {string} name of the event registered with (e.g. org.ekstep.quickstart:configure)
     * @param callback {function} remove the callback function
     * @param scope {object} the scope of the event (use this)
     * @memberof org.ekstep.contenteditor.api
     */
    removeEventListener: function(type, callback, scope) {
        org.ekstep.pluginframework.eventManager.removeEventListener(type, callback, scope);
    },

    /**
     * Framework support to load plugin resources. When the resources are loaded, the callback is fired.
     * @param pluginId {string} id of the plugin requesting resource to be loaded
     * @param pluginVer {string} version of the plugin that is requesting the resource to be loaded
     * @param src {string} URL of the resource to be loaded
     * @param dataType {object} dataType of the resource (image, or audio)
     * @param callback {function} callback function whent he resource is available
     * @memberof org.ekstep.contenteditor.api
     */
    loadPluginResource: function(pluginId, pluginVer, src, dataType, callback) {
        org.ekstep.pluginframework.pluginManager.loadPluginResource(pluginId, pluginVer, src, dataType, callback);
    },

    /**
     * Returns the handle to the Angular services. The services can be used by plugisn to achieve
     * the functional calls or render custom views. Valid services are:
     *     popup - UI service to render popup
     *     content - Provides access to the content API (for loading templates and assets)
     *     assessment - Provides access to the assessment API (for loading questions)
     *     language - Provides access to the wordnet API (for loading words and aksharas)
     *     search - Provides access to search API (for search activities, question, domains)
     *     meta - Provides access to metadata API (for resource bundles, ordinals, definitions)
     *     asset - Provides access to the content API (for save assets)
     *     telemetry - Service to genarate and log telemetry events
     * @param serviceId {string} id of the service to return. Returns undefined if the id is invalid
     * @memberof org.ekstep.contenteditor.api
     */
    getService: function(serviceId) {
        var service = '';
        switch (serviceId) {
            case ServiceConstants.POPUP_SERVICE:
                service = org.ekstep.services.popupService;
                break;
            case ServiceConstants.CONTENT_SERVICE:
                service = org.ekstep.services.contentService;
                break;
            case ServiceConstants.ASSESSMENT_SERVICE:
                service = org.ekstep.services.assessmentService;
                break;
            case ServiceConstants.LANGUAGE_SERVICE:
                service = org.ekstep.services.languageService;
                break;
            case ServiceConstants.SEARCH_SERVICE:
                service = org.ekstep.services.searchService;
                break;
            case ServiceConstants.META_SERVICE:
                service = org.ekstep.services.metaService;
                break;
            case ServiceConstants.ASSET_SERVICE:
                service = org.ekstep.services.assetService;
                break;
            case ServiceConstants.TELEMETRY_SERVICE:
                service = org.ekstep.services.telemetryService;
                break;
            case ServiceConstants.DIALCODE_SERVICE:
                service = org.ekstep.services.dialcodeService;
                break;
        }
        return service;
    },

    /**
     * Returns the angular scope object for the plugins that need angular framework to render. The editor
     * uses Angular 2 and plugins must use this to access the scope instead of instantiating Angular by
     * themselves.
     * @memberof org.ekstep.contenteditor.api
     */
    getAngularScope: function() {
        return org.ekstep.contenteditor.toolbarManager.scope;
    },

    /**
     * Returns the HTML5 canvas for rendering on the editor. By default, the editor uses Fabric.js and recommends
     * the plugins to also use Fabric.js for rendering the WYSIWYG components on the editor canvas. However,
     * this method provides access to the underlying native HTML5 canvas if needed. For example, if your plugin
     * uses some other third-party graphics library for rendering.
     * @memberof org.ekstep.contenteditor.api
     */
    getCanvas: function() {
        return org.ekstep.contenteditor.stageManager.canvas;
    },

    /**
     * Retrns the current stage object to the plugin. Plugins might use this to query other objects on the
     * canvas or access other stage context.
     * @memberof org.ekstep.contenteditor.api
     */
    getCurrentStage: function() {
        return org.ekstep.contenteditor.stageManager.currentStage;
    },

    /**
     * Retrns the specified stage to the plugin. This can be used to build scenarios where a plugin might be
     * linking multiple stages together (e.g. when building navigation plugins).
     * @memberof org.ekstep.contenteditor.api
     */
    getStage: function(stageId) {
        return org.ekstep.contenteditor.stageManager.getStage(stageId);
    },

    /**
     * Refreshes the rendering of stages - plugins can request the stages to be refreshed if any change
     * has been made.
     * @memberof org.ekstep.contenteditor.api
     */
    refreshStages: function() {
        /* istanbul ignore next */
        org.ekstep.contenteditor.api.ngSafeApply(org.ekstep.contenteditor.api.getAngularScope(), function() { org.ekstep.contenteditor.toolbarManager.scope.stages = org.ekstep.contenteditor.stageManager.stages; });
    },

    /**
     * Returns the currently selected active object on the canvas. This can be used by plugins to provide
     * contextual support - e.g. show words for a given text object when the text is selected.
     * @memberof org.ekstep.contenteditor.api
     */
    getCurrentObject: function() {
        var activeObj = org.ekstep.contenteditor.stageManager.canvas.getActiveObject();
        if (!activeObj) return false;
        var pluginId = activeObj.id;
        return org.ekstep.contenteditor.api.getPluginInstance(pluginId);
    },

    /**
     * Returns the current group of selected objects. This is possible when a user does multi-select by
     * clicking on multiple objects or by panning on the canvas.
     * @memberof org.ekstep.contenteditor.api
     */
    getCurrentGroup: function() {
        if(org.ekstep.contenteditor.stageManager.canvas.getActiveGroup()){
        var plugins = org.ekstep.contenteditor.stageManager.canvas.getActiveGroup()._objects;
        var group = [];
        _.forEach(plugins, function(plugins, index) {
            var obj = org.ekstep.contenteditor.api.getPluginInstance(plugins.id);
            group.push(obj);
        });
        return group;
        }
    },

    /**
     * Retrns the current group on the fabric canvas. This provides access to the fabric object. If you
     * want to access the plugin instance that is currently selected, use getCurrentGroup() instead.
     * @memberof org.ekstep.contenteditor.api
     */
    getEditorGroup: function() {
        var group = org.ekstep.contenteditor.stageManager.canvas.getActiveGroup();
        return group;
    },

    /**
     * Retrns the current object on the fabric canvas. This provides access to the fabric object. If you
     * want to access the plugin instance that is currently selected, use getCurrentObject() instead.
     * @memberof org.ekstep.contenteditor.api
     */
    getEditorObject: function() {
        return org.ekstep.contenteditor.stageManager.canvas.getActiveObject();
    },

    /**
     * Notifies the framework to render the canvas once again. This can be done by the plugin when
     * its config or state is modified via the config views.
     * @memberof org.ekstep.contenteditor.api
     */
    render: function() {
        org.ekstep.contenteditor.stageManager.canvas.renderAll();
    },

    /**
     * Returns a plugin instance for the given plugin ID. Plugins can use this work with dependencies
     * or build plugins that enhance the behavior of other plugins.
     * @memberof org.ekstep.contenteditor.api
     */
    getPluginInstance: function(pluginId) {
        return org.ekstep.pluginframework.pluginManager.getPluginInstance(pluginId);
    },

    /**
     * Allows the plugins to request an update to the context menu when one or more objects are selected.
     * This can be used by a plugin to add more actions to the context menu - e.g. when a text is selected,
     * a word parser plugin can add context menu for spell check, or for adding word definition popups.
     * @param menu {object} Menu item to add - see the manifest for the structre of the menu item
     * @memberof org.ekstep.contenteditor.api
     */
    updateContextMenu: function(menu) {
        org.ekstep.contenteditor.toolbarManager.updateContextMenu([menu]);
    },

    /**
     * Allows the plugins to request an update to the context menu by supplying multiple menu items.
     * This can be used by a plugin to add more actions to the context menu - e.g. when a text is selected,
     * a word parser plugin can add context menu for spell check, or for adding word definition popups.
     * @param menu {array} Array of menu items to add - see the manifest for the structre of the menu item
     * @memberof org.ekstep.contenteditor.api
     */
    updateContextMenus: function(menus) {
        org.ekstep.contenteditor.toolbarManager.updateContextMenu(menus);
    },
    updateSidebarMenu: function(menu) {
        org.ekstep.contenteditor.sidebarManager.updateSidebarMenu(menu);        
    },
    /**
     * Allows the plugins to request loading and instantiating another plugin. This is useful when
     * a plugin depends upon other plugins - e.g. a wordpicker might dependend upon an asset picker.
     * @param id {string} Fully qualified plugin id to load and instantiate
     * @param data {object} Data to be passed during instantiation (initial state)
     * @param parent {object} Parent scope - use this
     * @param override {object} Any function overrides - e.g. you can override the handlers of the plugin
     * @see org.ekstep.composite-text-image-shape plugin for a sample of leveraging this.
     * @memberof org.ekstep.contenteditor.api
     */
    instantiatePlugin: function(id, data, parent, override) {
        return org.ekstep.pluginframework.pluginManager.invoke(id, data, parent, override);
    },

    /**
     * Plugins can instantiate a stage and add it to the content. This can be done by special plugins that
     * work at a stage level or cause multiple stages to be added based on the configuration.
     * @param stage {object} Stage to add to the content
     * @memberof org.ekstep.contenteditor.api
     */
    addStage: function(stage) {
        org.ekstep.contenteditor.stageManager.addStage(stage);
    },

    /**
     * Lookup for another plugin in the current plugin manager scope.
     * @param id {string} Plugin id to return. Undefined if the plugin has not been loaded.
     * @memberof org.ekstep.contenteditor.api
     */
    getPlugin: function(id) {
        return org.ekstep.pluginframework.pluginManager.plugins[id];
    },

    /**
     * Adds a plugin instance to the manager. This may be used when a plugin instantiates other plugins. The
     * newly instantiated plugins are added to the framework's registry, making them discoverable by others.
     * Useful for scenarios where plugins depend on others, or composite plugins.
     * @param pluginInstance {object} Plugin object instantiated by this plugin.
     * @memberof org.ekstep.contenteditor.api
     */
    addPluginInstance: function(pluginInstance) {
        org.ekstep.pluginframework.pluginManager.addPluginInstance(pluginInstance);
    },

    /**
     * Removes a plugin instance from the manager. Do this only if you instantiated the plugin using addPluginInstance()
     * @param pluginInstance {object} Plugin object instantiated by this plugin.
     * @memberof org.ekstep.contenteditor.api
     */
    removePluginInstance: function(pluginInstance) {
        org.ekstep.pluginframework.pluginManager.removePluginInstance(pluginInstance);
    },

    /**
     * Creates a deep copy of the given plugin object with an offset x and y position. This is useful when
     * you are building plugins that enable copy paste type functionality for example.
     * @param pluginInstance {object} Plugin object instantiated by this plugin.
     * @memberof org.ekstep.contenteditor.api
     */
    cloneInstance: function(plugin) {
        var data = plugin.getCopy();
        data = _.omit(data, ["id", "event"]);
        if (plugin.parent.id == org.ekstep.contenteditor.api.getCurrentStage().id) {
            data.x = data.x + 2;
            data.y = data.y + 2;
        }
        org.ekstep.contenteditor.api.instantiatePlugin(plugin.manifest.id, data, org.ekstep.contenteditor.api.getCurrentStage());
    },

    /**
     * Returns all stages in the current document. This could be useful when plugins work across stages
     * such as timers that work across stages or page number plugins. Using this, a plugin can get access to all
     * stages, and instantiate plugins on each stage.
     * @memberof org.ekstep.contenteditor.api
     */
    getAllStages: function() {
        return org.ekstep.contenteditor.stageManager.stages;
    },

    /**
     * Selector for plugins of a given type in the document. This can be used by plugins to discover other
     * instances of the same plugin, or other plugins that are compatible with this plugin. E.g. a wordnet
     * plugin might use this to discover all other text plugins in the content.
     * 
     * @param  {String} stage        Stage ID
     * @param  {Array} includeTypes Include plugins
     * @param  {Array} excludeTypes Exclude plugins
     * @param  {Array} excludeIds   Exclude specific plugin instances
     * @return {Array}              Array of plugin instances matching the given criteria
     * @memberof org.ekstep.contenteditor.api
     */
    getStagePluginInstances: function(stage, includeTypes, excludeTypes, excludeIds) {
        // TODO: Add logic to check if stage exists
        var instances = _.clone(org.ekstep.contenteditor.api.getStage(stage).children);
        if (includeTypes) {
            instances = _.filter(instances, function(obj) {
                return includeTypes.indexOf(obj.manifest.id) != -1;
            });
        }
        if (excludeTypes) {
            instances = _.filter(instances, function(obj) {
                return excludeTypes.indexOf(obj.manifest.id) == -1;
            });
        }
        if (excludeIds) {
            instances = _.filter(instances, function(obj) {
                return excludeIds.indexOf(obj.id) == -1;
            });
        }
        return instances;
    },

    /**
     * Get matching plugin instances. This function returns instances across all stages matching the given criteria
     * 
     * @param  {Array} includeTypes Include plugins
     * @param  {Array} excludeTypes Exclude plugins
     * @param  {Array} excludeIds   Exclude specific plugin instances
     * @return {Array}              Array of plugin instances matching the given criteria
     * @memberof org.ekstep.contenteditor.api
     */
    getPluginInstances: function(includeTypes, excludeTypes, excludeIds) {
        var instances = _.clone(org.ekstep.pluginframework.pluginManager.pluginInstances);
        if (includeTypes) {
            instances = _.filter(instances, function(obj) {
                return includeTypes.indexOf(obj.manifest.id) != -1;
            });
        }
        if (excludeTypes) {
            instances = _.filter(instances, function(obj) {
                return excludeTypes.indexOf(obj.manifest.id) == -1;
            });
        }
        if (excludeIds) {
            instances = _.filter(instances, function(obj) {
                return excludeIds.indexOf(obj.id) == -1;
            });
        }
        return instances;
    },

    /**
     * Allows plugins to load a media object that they may depend upon.
     * @param assetId {string} ID of the media asset to load
     * @memberof org.ekstep.contenteditor.api
     */
    getMedia: function(assetId) {
        return org.ekstep.contenteditor.mediaManager.getMedia(assetId);
    },

    /**
     * Get the media asset's reverse proxy URL
     * @param  {String} url Fully qualified URL
     * @return {String}     Reverse proxied URL
     * @memberof org.ekstep.contenteditor.api
     */
    getMediaReverseProxyURL: function(url) {
        return org.ekstep.contenteditor.mediaManager.getMediaOriginURL(url);
    },

    /**
     * API to load a plugin dynamically. Any plugin to be loaded should be ideally declared as dependency in the manifest.
     * 
     * @param  {String} pluginId      Plugin ID
     * @param  {String} pluginVersion Plugin Version
     * @memberof org.ekstep.contenteditor.api
     */
    loadPlugin: function(pluginId, pluginVersion, callback) {
        org.ekstep.pluginframework.pluginManager.loadPluginWithDependencies(pluginId, pluginVersion, "plugin", undefined, [], callback);
    },

    /**
     * Utility API to update the plugin dimenstions once any action like - move, resize etc are performed
     * 
     * @param  {Object} inst Plugin Instance
     * @memberof org.ekstep.contenteditor.api
     */
    updatePluginDimensions: function(inst) {
        inst.attributes.x = inst.editorObj.getLeft();
        inst.attributes.y = inst.editorObj.getTop();
        inst.attributes.w = inst.editorObj.getWidth() - inst.editorObj.getStrokeWidth();
        inst.attributes.h = inst.editorObj.getHeight() - inst.editorObj.getStrokeWidth();
        inst.attributes.rotate = inst.editorObj.getAngle();
        if (_.isFunction(inst.editorObj.getRx))
            inst.attributes.r = inst.editorObj.getRx();
    },
    ngSafeApply: function(scope, fn) {
        if (scope) scope.$safeApply(fn);
    },
    /**
     * API to load and initialize a plugin to the current stage
     * 
     * @param  {String} pluginId      Plugin ID
     * @param  {String} pluginVersion Plugin Version
     * @param  {Long} publishedTime   Plugin published timestamp (for cache busting)
     * @param {Class} parent          Parent for the plugin
     * @memberof org.ekstep.contenteditor.api
     */
    loadAndInitPlugin: function(pluginId, pluginVersion, publishedTime, parent) {
        parent = parent || this.getCurrentStage();
        org.ekstep.pluginframework.pluginManager.loadAndInitPlugin(pluginId, pluginVersion, publishedTime, parent);
    },

    /**
     * API to Resolve plugin resource URL. This API would resolve to the repo the plugin is loaded from.
     * 
     * @param  {String} pluginId      Plugin ID
     * @param  {String} pluginVersion Plugin Version
     * @param  {String} resource resource relative URL
     * @return {String}          Resolved URL
     * @memberof org.ekstep.contenteditor.api
     */
    resolvePluginResource: function (id, ver, resource) {
         return org.ekstep.pluginframework.pluginManager.resolvePluginResource(id, ver, resource);
    },

    /**
     * API to register for a keyboard command
     * 
     * @param  {String}   command  Key combination. For ex: ctrl+s, ctrl+c etc
     * @param  {Function} callback Callback to invoke when the key is pressed
     * @memberof org.ekstep.contenteditor.api
     */
    registerKeyboardCommand: function(command, callback) {
        org.ekstep.pluginframework.keyboardManager.registerKeyCombination(command, callback);
    },
    addResourceRepository: function(repo, position) {
        if (repo) org.ekstep.pluginframework.resourceManager.addRepo(repo, position);
    },
    showSidebarMenu: function(sidebarMenuId) {
        org.ekstep.contenteditor.sidebarManager.showSidebarMenu(sidebarMenuId)
    },
    getCurrentSidebarMenu: function() {
        return org.ekstep.contenteditor.sidebarManager.getCurrentMenu();
    }     
}

window.ecEditor = window.org.ekstep.contenteditor.api;
/**
 * The base plugin class that all editor plugins inherit from. It provides the common support contract for all plugins.
 * Plugins can override specific methods to change the behavior. The most common scenario would be to override the
 * implementation of fabric callback methods to detect interactivity on the canvas.
 *
 * @class org.ekstep.contenteditor.basePlugin
 * @author Santhosh Vasabhaktula <santhosh@ilimi.in>
 */
org.ekstep.contenteditor.basePlugin = Class.extend({
    id: undefined,
    parent: undefined,
    children: [],
    manifest: undefined,
    editorObj: undefined,
    editorData: undefined,
    data: undefined,
    attributes: { x: 0, y: 0, w: 0, h: 0, visible: true, editable: true },
    config: undefined,
    event: undefined,
    events: undefined,
    params: undefined,
    media: undefined,
    configManifest: undefined,

    /**
     * Initializes the plugin with the given manifest and parent object
     * @param manifest {object} Manifest details for this plugin
     * @param data {object} Init parameters for the plugin
     * @param parent {object} Parent plugin object that instantiated this
     * @constructor
     * @memberof org.ekstep.contenteditor.basePlugin
     */
    init: function(manifest, data, parent) {
        var instance = this;
        this.manifest = _.cloneDeep(manifest);
        if (arguments.length == 1) {
            this.registerMenu();
            this.initialize();
            org.ekstep.contenteditor.api.addEventListener(this.manifest.id + ":create", this.create, this);
            console.log(manifest.id + " plugin initialized");
        } else {
            this.editorObj = undefined, this.event = undefined, this.attributes = { x: 0, y: 0, w: 0, h: 0, visible: true }, this.params = undefined, this.data = undefined, this.media = undefined;
            this.editorData = data || {};
            this.children = [];
            this.id = this.editorData.id || UUID();
            this.parent = parent;
            this.config = { opacity: 100, strokeWidth: 1, stroke: "rgba(255, 255, 255, 0)", autoplay: false, visible: true };
        }
        this.configManifest = _.clone(org.ekstep.contenteditor.baseConfigManifest, true);
    },

    /**
     * Initializes the plugin by reading from ECML.
     * @private
     * @memberof org.ekstep.contenteditor.basePlugin
     */
    initPlugin: function() {
        this.fromECML(this.editorData);
        this.newInstance();
        this.postInit();
    },

    /**
     * Post init tasks for the plugin
     * @private
     * @memberof org.ekstep.contenteditor.basePlugin
     */
    postInit: function() {
        this.registerFabricEvents();
        if (this.editorObj) { this.editorObj.set({ id: this.id }); this.editorObj.setVisible(true); }
        if(_.has(this.manifest.editor, 'behaviour')) {
            if(!_.isUndefined(this.manifest.editor.behaviour.rotatable) && (this.manifest.editor.behaviour.rotatable === true)) {
                if (this.editorObj) { this.editorObj.hasRotatingPoint = true; }
            }
        }
        if (this.parent) this.parent.addChild(this);
        if (this.parent && this.parent.type !== 'stage') org.ekstep.contenteditor.api.dispatchEvent('object:modified', { id: this.id });
    },

    /**
     * Registers the menu for this plugin. By default, the base plugin handles the menu additions.
     * Child implementations can use this method to override and register additional menu items.
     * @memberof org.ekstep.contenteditor.basePlugin
     */
    registerMenu: function() {
        var instance = this;
        this.manifest.editor.menu = this.manifest.editor.menu || [];
        this.manifest.editor.sidebarMenu = this.manifest.editor.sidebarMenu || [];
        _.forEach(this.manifest.editor.menu, function(menu) {
            menu.iconImage = menu.iconImage ? instance.relativeURL(menu.iconImage) : menu.iconImage;
            if (menu.submenu) {
                _.forEach(menu.submenu, function(dd) {
                    dd.iconImage = dd.iconImage ? instance.relativeURL(dd.iconImage) : dd.iconImage;
                    dd.pluginId  = instance.manifest.id;
                    dd.pluginVer = instance.manifest.ver;
                });
            }
            if (menu.category === 'main') {
                org.ekstep.contenteditor.toolbarManager.registerMenu(menu, instance.manifest);
            } else if (menu.category === 'context') {
                org.ekstep.contenteditor.toolbarManager.registerContextMenu(menu, instance.manifest);
            }
        });

        _.forEach(instance.manifest.editor.sidebarMenu, function(sidebarMenu) {
            org.ekstep.contenteditor.sidebarManager.registerSidebarMenu(sidebarMenu, instance.manifest);
        });

        org.ekstep.contenteditor.sidebarManager.loadCustomTemplate(instance.manifest.id);

        _.forEach(instance.manifest.editor.header, function(header) {
            org.ekstep.contenteditor.headerManager.register(header, instance.manifest);
        });
    },

    /**
     * Returns relative URL for a particular asset. Plugins should use this method instead of
     * hard-coding the asset URLs.
     * @memberof org.ekstep.contenteditor.basePlugin
     */
    relativeURL: function(src) {
        return org.ekstep.contenteditor.api.resolvePluginResource(this.manifest.id, this.manifest.ver, src);
    },

    /**
     * Returns the type of this plugin (manifest ID)
     * @memberof org.ekstep.contenteditor.basePlugin
     */
    getType: function() {
        return this.manifest.id;
    },

    /**
     * Returns the version of this plugin (manifest ID)
     * @memberof org.ekstep.contenteditor.basePlugin
     */
    getVersion: function() {
        return this.manifest.ver;
    },

    /**
     * Registers listeners for Fabricjs events from the canvas. Child implementations should override
     * the actual callback methods instead of overriding this one.
     * @private
     * @memberof org.ekstep.contenteditor.basePlugin
     */
    registerFabricEvents: function() {
        if (this.editorObj) {
            this.editorObj.on({
                added: function(options, event) {
                    var inst = org.ekstep.contenteditor.api.getPluginInstance(this.id);
                    inst.added(inst, options, event);
                    if (inst.editorObj) {
                        org.ekstep.contenteditor.api.updatePluginDimensions(inst);
                    }
                },
                removed: function(options, event) {
                    var inst = org.ekstep.contenteditor.api.getPluginInstance(this.id);
                    inst.removed(inst, options, event);
                    _.forEach(inst.children, function(child, index) {
                        child.editorObj.remove();
                    });
                    inst.remove();
                },
                selected: function(options, event) {
                    var inst = org.ekstep.contenteditor.api.getPluginInstance(this.id);
                    inst.selected(inst, options, event)
                },
                deselected: function(options, event) {
                    var inst = org.ekstep.contenteditor.api.getPluginInstance(this.id);
                    inst.deselected(inst, options, event)
                },
                modified: function(options, event) {
                    var inst = org.ekstep.contenteditor.api.getPluginInstance(this.id);
                    /* istanbul ignore else. This cannot be reached */
                    if (inst.editorObj) {
                        org.ekstep.contenteditor.api.updatePluginDimensions(inst);
                    }
                    inst.changed(inst, options, event)
                },
                rotating: function(options, event) {
                    var inst = org.ekstep.contenteditor.api.getPluginInstance(this.id);
                    inst.rotating(inst, options, event)
                },
                scaling: function(options, event) {
                    var inst = org.ekstep.contenteditor.api.getPluginInstance(this.id);
                    inst.scaling(inst, options, event);
                },
                moving: function(options, event) {
                    var inst = org.ekstep.contenteditor.api.getPluginInstance(this.id);
                    inst.moving(inst, options, event)
                },
                skewing: function(options, event) {
                    var inst = org.ekstep.contenteditor.api.getPluginInstance(this.id);
                    inst.skewing(inst, options, event)
                }
            });
        }
    },

    /**
     * Helper method to load a given resource relative to the plugin.
     * @memberof org.ekstep.contenteditor.basePlugin
     */
    loadResource: function(src, dataType, cb) {
        org.ekstep.contenteditor.api.loadPluginResource(this.manifest.id, this.manifest.ver, src, dataType, cb);
    },

    /**
     * Removes the plugin from the stage. This can be used to perform self cleanup. If this method is called
     * from newInstance(), plugin won't be added to stage children.
     * @memberof org.ekstep.contenteditor.basePlugin
     */
    remove: function() {
        if (this.parent) {
            this.parent.removeChild(this);
            this.parent =  undefined; // if this method is called from newInstance(), plugin won't be added to stage children    
        }
        delete org.ekstep.pluginframework.pluginManager.pluginInstances[this.id];
    },

    /**
     * Creates the instance of the plugin when a new object is added to the canvas.
     * @private
     * @memberof org.ekstep.contenteditor.basePlugin
     */
    create: function(event, data) {
        org.ekstep.contenteditor.api.instantiatePlugin(this.manifest.id, _.clone(data), org.ekstep.contenteditor.stageManager.currentStage);
    },

    /**
     * Adds a child to this object. This can be useful for composite scenarios.
     * @memberof org.ekstep.contenteditor.basePlugin
     */
    addChild: function(plugin) {
        this.children.push(plugin);
    },

    /**
     * Removes a child from this plugin. Use this to dynamically manage composite children.
     * @memberof org.ekstep.contenteditor.basePlugin
     */
    removeChild: function(plugin) {
        this.children = _.reject(this.children, { id: plugin.id });
    },

    /**
     * Initialize the plugin when it is loaded. This is a no-op implementation and child classes must
     * provide the complete functional implementation.
     * @memberof org.ekstep.contenteditor.basePlugin
     */
    /* istanbul ignore next */initialize: function(data) {},

    /**
     * Instantiate an object of the plugin type. This is a no-op implementation and child classes must
     * provide the complete functional implementation.
     * @memberof org.ekstep.contenteditor.basePlugin
     */
    /* istanbul ignore next */newInstance: function(data) {},

    /**
     * Called when the plugin is added to the canvas. This is a no-op implementation and child classes must
     * provide the complete functional implementation.
     * @memberof org.ekstep.contenteditor.basePlugin
     */
    added: function(instance, options, event) {},

    /**
     * Called when the plugin is removed from the canvas. This is a no-op implementation and child classes must
     * provide the complete functional implementation.
     * @memberof org.ekstep.contenteditor.basePlugin
     */
    removed: function(instance, options, event) {},

    /**
     * Called when the object is selected on the canvas. This is a no-op implementation and child classes must
     * provide the complete functional implementation.
     * @memberof org.ekstep.contenteditor.basePlugin
     */
    selected: function(instance, options, event) {},

    /**
     * Called when the object loses focus on the canvas. This is a no-op implementation and child classes must
     * provide the complete functional implementation.
     * @memberof org.ekstep.contenteditor.basePlugin
     */
    deselected: function(instance, options, event) {},

    /**
     * Called when the object is modified (dragged, resized or rotated). This is a no-op implementation and child classes must
     * provide the complete functional implementation.
     * @memberof org.ekstep.contenteditor.basePlugin
     */
    changed: function(instance, options, event) {},

    /**
     * Called continuously while the object is rotating. This is a no-op implementation and child classes must
     * provide the complete functional implementation.
     * @memberof org.ekstep.contenteditor.basePlugin
     */
    rotating: function(instance, options, event) {},

    /**
     * Called continuously while the object is scaling. This is a no-op implementation and child classes must
     * provide the complete functional implementation.
     * @memberof org.ekstep.contenteditor.basePlugin
     */
    scaling: function(instance, options, event) {},

    /**
     * Called continuously while the object is being dragged. This is a no-op implementation and child classes must
     * provide the complete functional implementation.
     * @memberof org.ekstep.contenteditor.basePlugin
     */
    moving: function(instance, options, event) {},

    /**
     * Called continuously while the object is being skewed. This is a no-op implementation and child classes must
     * provide the complete functional implementation.
     * @memberof org.ekstep.contenteditor.basePlugin
     */
    skewing: function(instance, options, event) {},

    /**
     * Allows plugins to create a copy of the object. Default implementation just creates a clone. Child
     * classes can override the logic to customize how copy is done.
     * @memberof org.ekstep.contenteditor.basePlugin
     */
    doCopy: function() {
        return this.editorObj;
    },

    /**
     * Returns a copy of the object by converting it to ECML markup.
     * @private
     * @memberof org.ekstep.contenteditor.basePlugin
     */
    getCopy: function() {
        return this.toECML();
    },

    /**
     * Renders the plugin to canvas. Default implementation adds the editor fabric object to canvas.
     * Complex plugins and templates should override this if necessary.
     * @memberof org.ekstep.contenteditor.basePlugin
     */
    render: function(canvas) {
        if (this.editorObj) canvas.add(this.editorObj);
    },

    /**
     * Returns the metadata of the object. This is a no-op implementation. Child plugins should override
     * this method to return custom metadata.
     * @memberof org.ekstep.contenteditor.basePlugin
     */    
    /* istanbul ignore next */
    getMeta: function() {},

    /**
     * Utility method to convert canvas pixels to relative units. By design, all rendering must work with
     * relative units to allow content to be rendered on different types of devices with different pixel
     * ratios and density. Plugins must always use the relative units for rendering.
     * @memberof org.ekstep.contenteditor.basePlugin
     */
    pixelToPercent: function(obj) {
        obj.x = parseFloat(((obj.x / 720) * 100).toFixed(2));
        obj.y = parseFloat(((obj.y / 405) * 100).toFixed(2));
        obj.w = parseFloat(((obj.w / 720) * 100).toFixed(2));
        obj.h = parseFloat(((obj.h / 405) * 100).toFixed(2));
        obj.rotate = parseFloat(obj.rotate);
    },

    /**
     * Utility method to convert relative units to pixels on canvas. By design, all rendering must work with
     * relative units to allow content to be rendered on different types of devices with different pixel
     * ratios and density. Plugins must always use the relative units for rendering.
     * @memberof org.ekstep.contenteditor.basePlugin
     */
    percentToPixel: function(obj) {
        obj.x = obj.x * (720 / 100);
        obj.y = obj.y * (405 / 100);
        obj.w = obj.w * (720 / 100);
        obj.h = obj.h * (405 / 100);
        obj.rotate = obj.rotate;
    },

    /**
     * Sets the config for this object. Override this method to parse the config if necessary.
     * @memberof org.ekstep.contenteditor.basePlugin
     */
    setConfig: function(data) {
        this.config = data;
    },

    /**
     * Adds a given config key and value pair to the config for this plugin instance.
     * @memberof org.ekstep.contenteditor.basePlugin
     */
    addConfig: function(key, value) {
        if (_.isUndefined(this.config)) this.config = {};
        this.config[key] = value;
    },

    /**
     * Returns the config for this plugin. Child plugins should override this method to generate the
     * custom plugin JSON objects.
     * @memberof org.ekstep.contenteditor.basePlugin
     */
    getConfig: function() {
        return this.config;
    },

    /**
     * Returns the data that this plugin might set and use at runtime. As a best practice, plugins should
     * differentiate between config (e.g. rendering colors, font size, levels etc) and data (actual
     * word details to use).
     * @memberof org.ekstep.contenteditor.basePlugin
     */
    setData: function(data) {
        this.data = data;
    },

    /**
     * Returns the data for this plugin. Data includes actual drivers - such as the words in a word game
     * or questions in a quiz. Plugins should set their data is they want to differentiate from
     * the config.
     * @memberof org.ekstep.contenteditor.basePlugin
     */
    getData: function() {
        return this.data;
    },

    /**
     * Manages the ECML attributes for the plugins. This includes x,y,w,h and rotation related attributes
     * that are common to all plugins.
     * @private
     * @memberof org.ekstep.contenteditor.basePlugin
     */
    setAttributes: function(attr) {
        _.merge(this.attributes, attr);
    },

    /**
     * Returns the ECML attributes for the plugins. This includes x,y,w,h and rotation related attributes
     * that are common to all plugins.
     * @private
     * @memberof org.ekstep.contenteditor.basePlugin
     */
    getAttributes: function() {
        return _.omit(this.attributes, ['top', 'left', 'width', 'height']);
    },

    /**
     * Modigies the ECML attributes for the plugins. This includes x,y,w,h and rotation related attributes
     * that are common to all plugins.
     * @private
     * @memberof org.ekstep.contenteditor.basePlugin
     */
    setAttribute: function(key, value) {
        this.attributes[key] = value;
    },

    /**
     * Returns the individual ECML attribute for the plugins. This includes x,y,w,h and rotation related attributes
     * that are common to all plugins.
     * @param key {string} Attribute name
     * @private
     * @memberof org.ekstep.contenteditor.basePlugin
     */
    getAttribute: function(key) {
        return this.attributes[key];
    },

    /**
     * Adds a runtime event listener for this plugin. Plugins can respond to events on the renderer
     * such as stage entry, exit or results of evaluation.
     * @param event {object} Event object
     * @private
     * @memberof org.ekstep.contenteditor.basePlugin
     */
    addEvent: function(event) {        
        if (_.isUndefined(this.event)) this.event = [];
        if (_.isArray(this.event)) this.event.push(event)
        else this.event = [event];
    },

    /**
     * Returns the list of runtime events configured for this plugin. Plugins can respond to events on the renderer
     * such as stage entry, exit or results of evaluation.
     * @param event {object} Event object
     * @memberof org.ekstep.contenteditor.basePlugin
     */
    getEvents: function() {
        return this.event;
    },

    /**
     * Adds a runtime param - such as teacher instructions to the ECML output. Params are like shared variables
     * that can be used for evaluation across stages on the renderer.
     * @param key {string} Name of the runtime parameter
     * @param value {object} Data of the parameter
     * @memberof org.ekstep.contenteditor.basePlugin
     */
    addParam: function(key, value) {
        if (_.isUndefined(this.params)) this.params = {};
        this.params[key] = value;
    },

    /**
     * Removes a runtime param for this plugin.
     * @param key {string} Name of the param to remove.
     * @memberof org.ekstep.contenteditor.basePlugin
     */
    deleteParam: function(key){
        if(this.params) delete this.params[key];
    },

    /**
     * Returns the list of runtime params for this plugin.
     * @memberof org.ekstep.contenteditor.basePlugin
     */
    getParams: function() {
        return this.params;
    },

    /**
     * Returns the specified runtime parameter details. Note that the value of the parameter
     * is only available at runtime.
     * @param key {string} Name of the param to return.
     * @memberof org.ekstep.contenteditor.basePlugin
     */
    getParam: function(key) {
        return this.params ? this.params[key] : undefined;
    },

    /**
     * Adds media to the manifest of this plugin. You can add media such as images, audios, or even
     * other runtime dependencies such as JS, CSS and other plugin files. If you don't declare a
     * media, it will not be included in the content download archive.
     * @param media {object} Media to be included at runtime.
     * @memberof org.ekstep.contenteditor.basePlugin
     */
    addMedia: function(media) {
        if (_.isUndefined(this.media)) this.media = {};
        this.media[media.id] = media;
    },

    /**
     * Returns the media manifest of this plugin. You can add media such as images, audios, or even
     * other runtime dependencies such as JS, CSS and other plugin files. If you don't declare a
     * media, it will not be included in the content download archive.
     * @param media {object} Media to be included at runtime.
     * @memberof org.ekstep.contenteditor.basePlugin
     */
    getMedia: function() {
        return this.media;
    },

    /**
     * Returns the renderer dimensions for this plugin. This includes the x,y,w,h bounding box,
     * and the rotation of the object.
     * @memberof org.ekstep.contenteditor.basePlugin
     */
    getRendererDimensions: function() {
        var attr = this.getAttributes();
        var dims = {
            x: attr.x,
            y: attr.y,
            w: attr.w,
            h: attr.h,
            rotate: attr.rotate
        }
        this.pixelToPercent(dims);
        return dims;
    },

    /**
     * Generates and returns the ECML string for this plugin.
     * @private
     * @memberof org.ekstep.contenteditor.basePlugin
     */
    toECML: function() {
        if(this.editorObj) org.ekstep.contenteditor.api.updatePluginDimensions(this);
        var attr = _.clone(this.getAttributes());
        attr.id = this.id;
        this.pixelToPercent(attr);
        if (!_.isUndefined(this.getData())) {
            attr.data = {
                "__cdata": JSON.stringify(this.getData())
            };
        }
        if (!_.isUndefined(this.getConfig())) {
            attr.config = {
                "__cdata": JSON.stringify(this.getConfig())
            };
        }
        if (!_.isUndefined(this.getEvents())) {
            // attr.config = {
            //     "__cdata": JSON.stringify(this.getEvents())
            // };
            attr.event = this.getEvents();
        }
        if (!_.isUndefined(this.getParams())) {
            attr.param = [];
            _.forIn(this.getParams(), function(value, key) {
                attr.param.push({ name: key, value: value });
            });
        }
        return attr;
    },

    /**
     * Parses the ECML to construct this object.
     * @private
     * @param data {object} ECML to recontruct from
     * @memberof org.ekstep.contenteditor.basePlugin
     */
    fromECML: function(data) {
        var instance = this;
        this.attributes = data;
        if (!_.isUndefined(this.attributes.data)) {
            this.data = this.attributes.data.__cdata ? JSON.parse(this.attributes.data.__cdata) : this.attributes.data;
            delete this.attributes.data;
        }
        if (!_.isUndefined(this.attributes.config)) {
            this.config = this.attributes.config.__cdata ? JSON.parse(this.attributes.config.__cdata) : this.attributes.config;
            delete this.attributes.config;
        }
        if (!_.isUndefined(this.attributes.events)) {
            //this.events = JSON.parse(this.attributes.event.__cdata);
            delete this.attributes.events;
        }
        if (!_.isUndefined(this.attributes.event)) {
            //this.events = JSON.parse(this.attributes.event.__cdata);
            this.event = this.attributes.event;
            delete this.attributes.event;
        }
        if (!_.isUndefined(this.attributes.param)) {
            _.forEach(this.attributes.param, function(param) {
                instance.addParam(param.name, param.value);
            })
            delete this.attributes.param;
        }
        if (!_.isUndefined(this.attributes.asset)) {
            if (!_.isUndefined(this.attributes.assetMedia)) {
                instance.addMedia(this.attributes.assetMedia);
                delete this.attributes.assetMedia;
            } else {
                var media = org.ekstep.contenteditor.mediaManager.getMedia(this.attributes.asset);
                if (!_.isUndefined(media)) {
                    instance.addMedia(media);
                }
            }
        }
        this.percentToPixel(this.attributes);
    },

    /**
     * Utility function to conver the data of the object to Fabric properties - a simple variable
     * transformation that returns the corresponding fabric parameter names.
     * @param data {object} Data of the current plugin instance.
     * @memberof org.ekstep.contenteditor.basePlugin
     */
    convertToFabric: function(data) {
        var retData = _.clone(data);
        if (data.x) retData.left = data.x;
        if (data.y) retData.top = data.y;
        if (data.w) retData.width = data.w;
        if (data.h) retData.height = data.h;
        if (data.radius) retData.rx = data.radius;
        if (data.color) retData.fill = data.color;
        if (data.rotate) retData.angle = data.rotate;
        return retData;
    },
    getConfigManifest: function() {
        if (!this.manifest.editor.configManifest) { this.manifest.editor.configManifest = []; }
        var configManifest = this.manifest.editor.configManifest
        if (this.configManifest) {
            configManifest = _.uniqBy(_.clone(_.concat(this.manifest.editor.configManifest, this.configManifest),true),'propertyName');
        }
        if (!(this.manifest.editor.playable && this.manifest.editor.playable === true)) {
          _.remove(configManifest, function (cm) {return cm.propertyName === 'autoplay'})
        }
        return configManifest
    },

    /**
     * Allows a plugin to update the context menu when the plugin instance is selected. Plugins can use
     * this method to change any specific custom context menu actions.
     * @memberof org.ekstep.contenteditor.basePlugin
     */
    /* istanbul ignore next */
    updateContextMenu: function() {},

    /**
     * Plugins can override this to reset their configuration.
     * @memberof org.ekstep.contenteditor.basePlugin
     */    
    /* istanbul ignore next */
    reConfig: function() {},

    onConfigChange: function() {},

    /**
     * Called when the configuration is modified for the plugin. This is useful if the plugin
     * has to provide WYSIWYG feedback on the fabric canvas.
     * @param key {string} Config property name
     * @param value {string} Value of the config setting.
     * @memberof org.ekstep.contenteditor.basePlugin
     */
    _onConfigChange: function(key, value) {
        this.addConfig(key, value);
        var currentInstace = org.ekstep.contenteditor.api.getCurrentObject();
        if (currentInstace) {
            if (currentInstace.config === undefined) { currentInstace.config = {} }
            switch (key) {
                case 'opacity':
                    currentInstace.editorObj.setOpacity(value/100);
                    currentInstace.attributes.opacity = value/100;
                    currentInstace.config.opacity = value;
                    break;
                case 'strokeWidth':
                    value = parseInt(value);
                    currentInstace.editorObj.set('strokeWidth', value);
                    currentInstace.attributes['stroke-width'] = value;
                    currentInstace.attributes['strokeWidth'] = value;
                    currentInstace.config.strokeWidth = value;
                    break;
                case 'stroke':
                    currentInstace.editorObj.setStroke(value);
                    currentInstace.attributes.stroke = value;
                    currentInstace.config.stroke = value;
                    break;
                case 'autoplay':
                    currentInstace.attributes.autoplay = value;
                    currentInstace.config.autoplay = value;
                    break;
                case 'visible':
                    currentInstace.attributes.visible = value;
                    currentInstace.config.visible = value;
                    break;
            }
            org.ekstep.contenteditor.api.render();
            org.ekstep.contenteditor.api.dispatchEvent('object:modified', { target: org.ekstep.contenteditor.api.getEditorObject() });
        }
    },

    /**
     * Returns the help text for this plugin by reading the help markdown file. Plugins can override this
     * to return custom help.
     * @memberof org.ekstep.contenteditor.basePlugin
     */
    /* istanbul ignore next. test case failing */
    getHelp: function(cb) {        
        var helpText = "Help is not available."
        try {
            this.loadResource(this.manifest.editor.help.src, this.manifest.editor.help.dataType, function(err, help) {
                if (!err) {
                    helpText = help;
                    cb(helpText);
                }
            });
        } catch (e) {
            console.log(e)
            cb(helpText);
        }
    },

    /**
     * Returns the properties that editable for this plugin instance.
     * @private
     * @memberof org.ekstep.contenteditor.basePlugin
     */
    getProperties: function() {
        var props = _.omitBy(_.clone(this.attributes), _.isObject);
        props = _.omitBy(props, _.isNaN);
        this.pixelToPercent(props);
        return props;
    },

    /**
     * Renders the configuration view for this plugin. Default functionality is to launch the config
     * property editor. Plugins can override this method to change the way config is rendered.
     * @memberof org.ekstep.contenteditor.basePlugin
     */    
    /* istanbul ignore next */renderConfig: function() {},

    /**
     * Returns the manifest ID of this object
     * @memberof org.ekstep.contenteditor.basePlugin
     */
    getManifestId: function () {
      return (this.manifest.shortId || this.manifest.id);
    },

    /**
     * Returns the displayName of this object
     * @memberof org.ekstep.contenteditor.basePlugin
     */
    getDisplayName: function () {
         return (this.manifest.displayName || this.manifest.id);
    }
});

/**
 * @author Santhosh Vasabhaktula <santhosh@ilimi.in>
 */
org.ekstep.contenteditor.toolbarManager = new(Class.extend({
    menuItems: [],
    contextMenuItems: [],
    configMenuItems: [],
    scope: undefined,
    setScope: function(scope) {
        this.scope = scope;
    },
    registerMenu: function(menu, manifest) {
        if (!_.isObject(_.find(this.menuItems, { id: menu.id }))) {
            var menuCloneObj = _.cloneDeep(menu);
            menuCloneObj.pluginId = manifest.id;
            menuCloneObj.pluginVer = manifest.ver;
            this.menuItems.push(menuCloneObj);
        }
        if(this.scope) this.scope.refreshToolbar();
    },
    registerContextMenu: function(menu, manifest) {
        if (!_.isObject(_.find(this.contextMenuItems, { id: menu.id }))) {
            var menuCloneObj = _.cloneDeep(menu);
            menuCloneObj.pluginId = manifest.id;
            menuCloneObj.pluginVer = manifest.ver;
            this.contextMenuItems.push(menuCloneObj);
        }
        if(this.scope) this.scope.refreshToolbar();
    },
    resetContextMenu: function() {
        _.forEach(this.contextMenuItems, function(cmenu) {
            cmenu.state = 'HIDE';
            cmenu.selected = false;
        });
    },
    updateContextMenu: function(menus) {
        var instance = this;
        _.forEach(menus, function(cmenu) {
            instance._updateContextMenu(cmenu.id, cmenu);
        });
        /* istanbul ignore next. Angular functions cannot be tested now */
        org.ekstep.contenteditor.api.ngSafeApply(this.scope, function() {
            instance.scope.contextMenus = instance.contextMenuItems;
        });
        org.ekstep.contenteditor.jQuery(document).ready(function() {
            org.ekstep.contenteditor.jQuery(".ui.dropdown").dropdown();
            org.ekstep.contenteditor.jQuery(".popup-item").popup();
        });

    },
    _updateContextMenu: function(menuId, props) {
        //console.log('menu', menuId, 'props', props);
        var menu = _.find(this.contextMenuItems, { id: menuId });
        _.forIn(props, function(value, key) {
            if (key != 'data') {
                menu[key] = value;
                org.ekstep.pluginframework.eventManager.dispatchEvent(menuId + ':' + key, props.data);
            }
        });
    },
    getRegisterConfigMenu: function() {
        return this.configMenuItems;
    },
    cleanUp: function() {
        this.menuItems = [];
        this.contextMenus = [];
    }
}));

/**
 * @author Santhosh Vasabhaktula <santhosh@ilimi.in>
 */
org.ekstep.contenteditor.mediaManager = new(Class.extend({
    mediaMap: {},
    migratedMediaMap: {},
    addMedia: function(media) {
        if (_.isObject(media) && _.isString(media.id)) {
            this.mediaMap[media.id] = media;
        }
    },
    getMedia: function(asset) {
        return this.mediaMap[asset];
    },
    getMediaOriginURL: function(src) {
        var assetReverseProxyUrl = "/assets/public/";
        var replaceText = org.ekstep.contenteditor.config.baseURL + assetReverseProxyUrl;

        _.forEach(org.ekstep.contenteditor.config.aws_s3_urls, function(url){
            if(src.indexOf(url) !== -1){
                src = src.replace(url, replaceText);
            }
        });
        return src;
    },
    addToMigratedMedia: function(media) {
        if (_.isObject(media) && _.isString(media.id)) {
            this.migratedMediaMap[media.id] = media;
        }
    }
}));

org.ekstep.contenteditor.sidebarManager = new(Class.extend({
    loadNgModules: undefined,
    sidebarMenu: [],
    init: function() {
        this.setSidebarHeight();
    },
    initialize: function(config) {
        this.loadNgModules = config.loadNgModules;
        this.scope = config.scope
    },
    registerSidebarMenu: function(menu, manifest) {
        var instance = this;
        if (!_.isObject(_.find(this.sidebarMenu, { id: "sidebar:" + menu.id }))) {
            menu.onclick = menu.onclick || { id: "sidebar:" + menu.id };
            this.sidebarMenu.push(menu);
            this.loadSidebar(menu, manifest);
            ecEditor.addEventListener("sidebar:" + menu.id, function(event, data) {
                instance.showSidebarMenu(event.type.substring(event.type.indexOf(':') + 1));
            }, instance);
        }
    },
    loadSidebar: function(menu, manifest) {
        var instance = this;
        menu.state = menu.state || 'SHOW';
        if (menu.templateURL) {
            menu.templateURL = menu.templateURL + '?' + ecEditor.getConfig('build_number');
            menu.templateURL = org.ekstep.contenteditor.api.resolvePluginResource(manifest.id, manifest.ver, menu.templateURL);
            instance.loadNgModules(menu.templateURL);

            if (menu.controllerURL) {
                menu.controllerURL = menu.controllerURL + '?' + ecEditor.getConfig('build_number');
                menu.controllerURL = org.ekstep.contenteditor.api.resolvePluginResource(manifest.id, manifest.ver, menu.controllerURL);
                instance.loadNgModules(undefined, menu.controllerURL)
                    .then(function() {
                        instance.scope.addToSidebar(menu);
                    }, function() {
                        throw "unable to load controller :" + menu.controllerURL;
                    });
            } else {
                instance.scope.addToSidebar(menu);
            }
        };
    },
    loadCustomTemplate: function(pluginId) {
        var instance = this;
        var manifest = org.ekstep.pluginframework.pluginManager.getPluginManifest(pluginId);
        manifest.editor.configManifest = manifest.editor.configManifest || [];
        _.forEach(manifest.editor.configManifest, function(config) {
            if (config.type == "custom_template") {
                if (config.controllerURL) {
                    instance.loadNgModules(undefined, org.ekstep.contenteditor.api.resolvePluginResource(manifest.id, manifest.ver, config.controllerURL));
                }

                if (config.templateURL) {
                    var path = org.ekstep.contenteditor.api.resolvePluginResource(manifest.id, manifest.ver, config.templateURL);
                    org.ekstep.pluginframework.resourceManager.loadResource(path, 'HTML', function(err, data) {
                        if (err) throw "unable to load custom template";
                        if (data) config.template = data;
                    });
                }
            }
        });
    },
    updateSidebarMenu: function(menu) {
        var menuObject = _.find(this.sidebarMenu, { id: menu.id });
        _.forIn(menu, function(value, key) {
            if (key != 'id') menuObject[key] = value
        });
        this.scope.refreshSidebar();
    },
    getSidebarMenu: function() {
        return this.sidebarMenu;
    },
    setSidebarHeight: function() {
        var newheight = $(window).innerHeight() - 212;
        $('.sidebar-holder').css("height", newheight + "px");
    },
    getCurrentMenu: function() {
        return this.scope.configCategory.selected;
    },
    showSidebarMenu: function(sidebarMenuId) {        
        if (sidebarMenuId) {
            var menu = _.find(this.sidebarMenu, function(menu) {
                return menu.id === sidebarMenuId;
            });
            if (menu.state !== "HIDE") this.scope.configCategory.selected = sidebarMenuId;
            this.scope.refreshSidebar();
        }
    }
}));

org.ekstep.contenteditor.headerManager = new(Class.extend({
	registeredHeaders: [],
	initialize: function(config) {
        this.loadNgModules = config.loadNgModules;
        this.scope = config.scope
    },
    register: function(header, manifest) {
    	this.registeredHeaders.push({ id: manifest.id, header: header });
    	this.load(header, manifest);
    },
    load: function(header, manifest) {
        var instance = this;        
        if (header.templateURL) {
            header.templateURL = header.templateURL + '?' + ecEditor.getConfig('build_number');
            header.templateURL = org.ekstep.contenteditor.api.resolvePluginResource(manifest.id, manifest.ver, header.templateURL);
            instance.loadNgModules(header.templateURL);

            if (header.controllerURL) {
                header.controllerURL = header.controllerURL + '?' + ecEditor.getConfig('build_number');
                header.controllerURL = org.ekstep.contenteditor.api.resolvePluginResource(manifest.id, manifest.ver, header.controllerURL);
                instance.loadNgModules(undefined, header.controllerURL)
                    .then(function() {
                        instance.scope.addToHeader(header);
                    }, function() {
                        throw "unable to load controller :" + header.controllerURL;
                    });
            } else {
                instance.scope.addToHeader(header);
            }
        };
    }   
}));
/**
 * 
 * Popup service helps to show interactive popup modal/dialog window from plugin
 * 
 * @class org.ekstep.services.popupService
 * @author Sunil A S <sunils@ilimi.in>
 */
org.ekstep.services.popupService = new(org.ekstep.services.iService.extend({
    loadModules: undefined,
    openModal: undefined,
    initService: function(loadModuleFn, openModalFn) {
        this.loadModules = loadModuleFn;
        this.openModal = openModalFn;
    },
    /**
     *
     * loads HTML template and angular module 
     * @param templatePath {string} path to HTML template
     * @param controllerPath {string} path to angular module
     * @memberof org.ekstep.services.popupService
     */
    loadNgModules: function(templatePath, controllerPath) {
        templatePath = templatePath + '?' + ecEditor.getConfig('build_number');
        controllerPath = controllerPath + '?' + ecEditor.getConfig('build_number');
        if(this.loadModules) return this.loadModules(templatePath, controllerPath);
    },
    /**
     *
     * opens popup modal/dialog window
     * @param config {object} config object refers to ngDialog open method parameter. please refer [ngDialog docs]{@link https://github.com/likeastore/ngDialog#openoptions}
     * @param callback {function} pre close Callback 
     * @memberof org.ekstep.services.popupService
     */
    open: function(config, callback) {
        /* istanbul ignore else */
        if (this.openModal) {
            this.openModal(config, callback);
            org.ekstep.services.telemetryService.interact({ "type": "show", "subtype": "open", "target": "popup", "pluginid": "", "pluginver": '', "objectid": "", "stage": ecEditor.getCurrentStage().id });
        }
    }
}));

/*// toECML
//     1. For each stage
//         1. for each plugin
            1. generate ecml
            2. add media to manifest
            3. add plugin to plugins used
        2. generate ecml
        3. add media to manifest
        4. add thumbnail
// 2. ManifestGenerator - generate plugin and media manifest using pluginsUsed array
// 3. Merge the media manifest generated by stages with the media manifest generated by the manifest generator
// 4. If there is migrated media - merge the migrated media with manifest media

// Pre-condition. toECML would generate the pluginUsed array
*/

var _PM_ = org.ekstep.pluginframework.pluginManager;
var ManifestGenerator = new(Class.extend({
    visitedPlugins: {},
    pluginManifest: [],
    mediaManifest: [],
    compatibilityVersion: 0,
    reset: function() {
        this.visitedPlugins = {};
        this.pluginManifest = [];
        this.mediaManifest = [];
    },
    getPluginManifest: function() {
        return this.pluginManifest;
    },
    getMediaManifest: function() {
        return this.mediaManifest;
    },
    isVisited: function(pluginId) {
        return this.visitedPlugins[pluginId] ? true : false;
    },
    visit: function(pluginId) {
        this.visitedPlugins[pluginId] = true;
    },
    generate: function(pluginUsedArray) {
        this.reset();
        this._generate(pluginUsedArray);
    },
    _generate: function(pluginArray) {
        var instance = this;
        _.forEach(pluginArray, function(pluginId) {
            instance._generateManifest(pluginId);
        })
    },
    _generateManifest: function(pluginId) {
        if(!this.isVisited(pluginId)) {
            this.visit(pluginId);
            var manifest = _PM_.getPluginManifest(pluginId);
            if(!_.isUndefined(manifest)) {
                this._generatePluginManifest(manifest);
                this._generateMediaManifest(manifest);
            }
        }
    },
    _getDependencies: function(pluginManifest) {
        var depends = undefined;
        if(pluginManifest.dependencies && pluginManifest.dependencies.length > 0) {
            var dependencies = _.map(_.filter(pluginManifest.dependencies, function(dependency) {
                return ['all','renderer'].indexOf(dependency.scope) != -1;
            }), function(dep) { return dep.plugin });
            if(dependencies.length > 0) {
                depends = dependencies;
            }
        }
        return depends;
    },
    _generatePluginManifest: function(manifest) {
        var depends = this._getDependencies(manifest);
        var dependsStr = '';
        if(!_.isUndefined(depends) && depends.length > 0) {
            this._generate(depends);
            dependsStr = depends.join(',');    
        } 
        manifest.type = manifest.type || "plugin";
        if (manifest.renderer) this.pluginManifest.push({id: manifest.id, ver: manifest.ver, type: manifest.type, depends: dependsStr});       
    },
    _generateMediaManifest: function(manifest) {
        var instance = this;
        if(manifest.renderer) {
            if (manifest.renderer.compatibilityVersion && (manifest.renderer.compatibilityVersion > instance.compatibilityVersion)) instance.compatibilityVersion = manifest.renderer.compatibilityVersion;

            // Add js/css/custom plugin dependencies
            if(manifest.renderer.dependencies && manifest.renderer.dependencies.length > 0) {
                _.forEach(manifest.renderer.dependencies, function(dependency) {
                    instance.mediaManifest.push({
                        id: dependency.id || UUID(),
                        plugin: manifest.id,
                        ver: manifest.ver,
                        src: _PM_.resolvePluginResource(manifest.id, manifest.ver, dependency.src),
                        type: dependency.type
                    })
                });
            }
            // Add main renderer script file
            if(manifest.renderer.main) {
                instance.mediaManifest.push({
                    id: manifest.id,
                    plugin: manifest.id,
                    ver: manifest.ver,
                    src: _PM_.resolvePluginResource(manifest.id, manifest.ver, manifest.renderer.main),
                    type: 'plugin'
                });
            }
            // Add the manifest.json of the renderer plugin
            instance.mediaManifest.push({
                id: manifest.id + '_manifest',
                plugin: manifest.id,
                ver: manifest.ver,
                src: _PM_.resolvePluginResource(manifest.id, manifest.ver, 'manifest.json'),
                type: 'json'
            });
        }
    },
    getCompatibilityVersion: function() {
        if (this.compatibilityVersion) return this.compatibilityVersion;
        return;
    }
}));
/**
 *
 * Telemetry service helps to log telemetry events. Telemetry service generates below listed events
 * and logs to registered dispatchers.
 * <ol>
 *  <li> V2 =>  V3
 *  <li>CE_START => START
 *  <li>CE_API_CALL => LOG
 *  <li>CE_INTERACT => INTERACT
 *  <li>CE_PLUGIN_LIFECYCLE => INTERACT
 *  <li>CE_ERROR => ERROR
 *  <li>CE_END => END
 * </ol>
 *
 * @class org.ekstep.services.telemetryService
 * @author Santhosh Vasabhaktula <santhosh@ilimi.in>
 */
org.ekstep.services.telemetryService = new(org.ekstep.services.iService.extend({
    context: {},
    dispatchers: [],
    initialized: true,
    start_event: undefined,
    startEventData: undefined,
    contentLoadTime: 0,
    /**
     * Deperecated: V3 telemetry implementation
     * Initialize the service with context and dispatcher.     
     * @param context {object} context object can have uid, sid, context_id. 
     * context should have content id, otherwise telemetry service cannot be initialized.
     * @param dispatcher {string} There are 3 types of dispatcher available, anyone of dispatcher 
     * is allowed and same dispatcher is used throughout the editor session. 
     * <ol>
     *   <li>Local dispatcher - dev environment only, logs to file (telemetry.log) - value: "local"
     *   <li>piwik dispatcher - logs to piwik endpoint - value: "piwik"
     *   <li>console dispatcher - logs to client console, default dispatcher - value: undefined
     * </ol>
     * 
     * @memberof org.ekstep.services.telemetryService
     */
    initialize: function(context, dispatcher) {
        var instance = this;
        this.context = context;
        /* istanbul ignore else */
        if (this.context.cdata == undefined) {
            this.context.cdata = [];
        }
        if ((this.context.uid == undefined) || (this.context.sid == undefined) || (this.context.content_id == undefined)) {
            console.error('Unable to instantiate telemetry service');
            this.initialized = false;
        }
        this.addDispatcher(dispatcher);

        window.addEventListener('unload', /* istanbul ignore next */ function() {
            instance.end();
        });
        this.startEventData = { defaultPlugins: Object.keys(org.ekstep.pluginframework.pluginManager.plugins), loadtimes: {}, client: {} };
    },
    /**
     *
     * to populate data for start event (CE_START)  
     * @param autoplublish {boolean} if "true" logs the events through dispatcher. 
     * @returns {object} returns method chain. 
     * <ol>
     *   <li> <pre>getData()</pre>: return start event data
     *   <li> <pre>append(param, dataObj)</pre>: appends only "loadtimes" param of CE_START with dataObj(type: object). 
     * <ol> 
     * @memberof org.ekstep.services.telemetryService
     *
     */
    startEvent: function(autopublish) {
        var instance = this;
        return {
            duration: function(time){
                instance.contentLoadTime += parseInt(time);
                if (autopublish) instance.start();
            }
        }
    },
    /**
     *
     * returns dispatcher instance
     * @param dispatcherId {string}     
     * <ol>
     *   <li>Local dispatcher: value: "local"
     *   <li>piwik dispatcher: value: "piwik"
     *   <li>(default) console dispatcher: value: undefined 
     * </ol>
     * @returns dispatcher {object}
     * @memberof org.ekstep.services.telemetryService
     *
     */
    getDispatcher: function(dispatcherId) {
        switch (dispatcherId) {
            case "local":
                return org.ekstep.contenteditor.localDispatcher;
            case "piwik":
                return org.ekstep.contenteditor.piwikDispatcher;
            default:
                return org.ekstep.contenteditor.consoleDispatcher;
        }
    },
    /**
     * 
     * To add a dispatcher to the dispatcher registry
     * @param dispatcherId {string}
     * <ol>
     *   <li>Local dispatcher: value: "local"
     *   <li>piwik dispatcher: value: "piwik"
     *   <li>(default) console dispatcher: value: undefined 
     * </ol>
     * @memberof org.ekstep.services.telemetryService
     *
     */
    addDispatcher: function(dispatcherId) {
        var dispatcher = this.getDispatcher(dispatcherId);
        var dispatcherExist = this.dispatchers.find(function(obj) {
            return obj.type === dispatcher.type;
        });
        if (!dispatcherExist) this.dispatchers.push(dispatcher);
    },
    /**
     *
     * dispatch event to all registered dipatchers
     * @private
     * @param message {event} structured event
     * @memberof org.ekstep.services.telemetryService
     *
     */
    _dispatch: function(message) {
        if (this.initialized) {
            message.mid = 'CE:' + CryptoJS.MD5(JSON.stringify(message)).toString();
            _.forEach(this.dispatchers, function(dispatcher) {
                dispatcher.dispatch(message);
            });
        }
    },
    /**
     * Deperecated: V3 telemetry implementation
     * returns structured telemetry event for the given data
     * @param eventId {string} 
     * <ol>
     *  <li>CE_START
     *  <li>CE_API_CALL
     *  <li>CE_INTERACT
     *  <li>CE_PLUGIN_LIFECYCLE
     *  <li>CE_ERROR
     *  <li>CE_END
     * </ol>
     * @param data {object} telemetry data object specified for each telemetry event.
     * @memberof org.ekstep.services.telemetryService
     *
     */
    getEvent: function(eventId, data) {
        return {
            "eid": eventId,
            "mid": "",
            "ets": (new Date()).getTime(),
            "channel": this.context.channel,
            "ver": "2.1",
            "pdata": this.context.pdata,
            "cdata": this.context.cdata, //TODO: No correlation data as of now. Needs to be sent by portal in context
            "uid": this.context.uid, // uuid of the requester
            "context": { "sid": this.context.sid, "content_id": this.context.content_id },
            "rid": "", // Leave blank.
            "edata": { "eks": data },
            "etags": this.context.etags

        }
    },
    /**
     *
     * validates telemetry data with mandatory fields
     * @param data {object} telemetry data
     * @param mandatoryFields {array} required fields for the specific telemetry to validate
     * @memberof org.ekstep.services.telemetryService
     *
     */
    hasRequiredData: function(data, mandatoryFields) {
        var isValid = true;
        mandatoryFields.forEach(function(key) {
            if (!data.hasOwnProperty(key)) isValid = false;
        });
        return isValid;
    },
    interactRequiredFields: ["type", "subtype", "target", "pluginid", "pluginver", "objectid", "stage"],
    lifecycleRequiredFields: ["type", "pluginid", "pluginver", "objectid", "stage"],
    errorRequiredFields: ["env", "stage", "action", "err", "type", "data", "severity", "objectid", "objecttype"],
    apiCallRequiredFields: ["path", "method", "request", "response", "responseTime", "status", "uip"],
    /**
     *
     * dispatches interact event (CE_INTERACT)
     * @param data {object} interact event data
     * @memberof org.ekstep.services.telemetryService
     *
     */
    interact: function(data) {
        if(!(data.hasOwnProperty('type') && (data.hasOwnProperty('objectid') || data.hasOwnProperty('id')))){
            console.error('Invalid interact data');
            return;
        }
        var eventData = {
            "type": data.type,
            "id": data.id || data.objectid
        };
        // for V3 implementation
        if(data.extra)
            eventData.extra = data.extra;
        if(data.subtype)
            eventData.subtype = data.subtype;
        if(data.pageid || data.stage)
            eventData.pageid = data.pageid || data.stage;
        // converting plugin, tareget for v3 from v2 data 
        eventData.plugin = data.plugin ? data.plugin : { "id": data.pluginid, "ver": data.pluginver }
        if(data.target && _.isObject(data.target)){
            eventData.target = data.target;
        }else{
            // converting target for v3 from v2 data
            eventData.target = {
                "id": data.target,
                "ver": "",
                "type": ""
            }
        }
        EkTelemetry.interact(eventData);
    },
    /**
     *
     * dispatches impression event (CE_IMPRESSION)
     * @param data {object} impression event data
     * @memberof org.ekstep.services.telemetryService
     *
     */
    impression: function(data) {
        if(!(data.hasOwnProperty('type') && data.hasOwnProperty('pageid') && data.hasOwnProperty('uri'))) {
            console.error('Invalid impression data');
            return;
        }
        var eventData = {
            "type": data.type,
            "pageid": data.pageid,
            "uri": data.uri
        };
        if(data.subtype)
            eventData.subtype = data.subtype;
        if(data.visits)
            eventData.visits = data.visits;
        EkTelemetry.impression(eventData);
    },
    /**
     *
     * dispatches end event (CE_END)
     * @memberof org.ekstep.services.telemetryService
     *
     */
    end: function() {
        var editorConfig_mode = _.get(ecEditor.getConfig('editorConfig'), 'mode');
        var mode =  editorConfig_mode && (editorConfig_mode.toLowerCase() == 'read' ? 'view' : editorConfig_mode) || 'edit';
        EkTelemetry.end({
            "type": ecEditor.getConfig('editorType') || "content",
            "mode": mode.toLowerCase(), 
            "pageid": "main-page"
        });
    },
    /**
     *
     * dispatches plugin lifecycle event (CE_PLUGIN_LIFECYCLE)
     * @param data {object} plugin lifecycle event data
     * @memberof org.ekstep.services.telemetryService
     *
     */
    pluginLifeCycle: function(data) {
        if(!(data.hasOwnProperty('type') && (data.hasOwnProperty('objectid') || data.hasOwnProperty('id')))){
            console.error('Invalid plugin lifecycle event data');
            return;
        }
        this.interact(data);
    },
    /**
     *
     * dispatches error event (CE_ERROR)
     * @param data {object} error event data
     * @memberof org.ekstep.services.telemetryService
     *
     */
    error: function(data) {
        if(!(data.hasOwnProperty('err') && (data.hasOwnProperty('type') || data.hasOwnProperty('errtype')) && (data.hasOwnProperty('data') || data.hasOwnProperty('stacktrace')))){
            console.error('Invalid error data');
            return;
        }
        var eventData = {
            "err": data.err && data.err.toString(),
            "errtype": data.type || data.errtype,
            "stacktrace": data.data || data.stacktrace
        }
        // for V3 implementation
        if(data.pageid || data.stage)
            eventData.pageid = data.stage || data.pageid;
        if(data.plugin)
            eventData.plugin = data.plugin;
        eventData.object = data.object ? data.object : { "id": data.objectid, "type": data.objecttype };
        EkTelemetry.error(eventData);
    },
    /**
     *
     * dispatches start event (CE_START)
     * @memberof org.ekstep.services.telemetryService
     *
     */
    start: function(durartion) {
        var instance = this;
        var fp = new Fingerprint2();
        var pdata = ecEditor.getContext('pdata') ? ecEditor.getContext('pdata') : {id: "in.ekstep", ver: "1.0"};
        var env = ecEditor.getContext('env') || 'contenteditor';
        if (env) {
            switch (env) {
                case 'genericeditor':
                case 'contenteditor':
                    env = env;
                    break;
                default:
                    env = 'collectioneditor';
                    break;
            }
        }
        pdata.pid = pdata.pid ? pdata.pid + '.' + env : env;
        ecEditor.setContext('pdata', pdata);
        var pkgVersion = ecEditor.getService('content').getContentMeta(org.ekstep.contenteditor.api.getContext('contentId')).pkgVersion
        var config = {
            uid: ecEditor.getContext('uid'),
            sid: ecEditor.getContext('sid'),
            channel: ecEditor.getContext('channel') || "in.ekstep",
            pdata: pdata,
            env: ecEditor.getContext('env') || "contenteditor",
            dispatcer: org.ekstep.contenteditor.config.dispatcher,
            object: {
                id: ecEditor.getContext('contentId'),
                type: "Content",
                ver:  !_.isUndefined(pkgVersion) ? pkgVersion.toString() : "0"
            },
            dispatcher: instance.getDispatcher(org.ekstep.contenteditor.config.dispatcher),
            rollup: ecEditor.getContext('rollup') || {}
        };

        if (ecEditor.getContext('tags')) {
            config.tags = ecEditor.getContext('tags');
        } else {
            config.tags =  _.flattenDeep(_.values(ecEditor.getContext('etags')));
        }
        if(ecEditor.getContext('did')){
            config.did = ecEditor.getContext('did');
            instance.logStartAndImpression(config, durartion);
        }else{
            fp.get(function(result) {
                config.did = result.toString();
                instance.logStartAndImpression(config, durartion);
            });
        }
        window.addEventListener('unload', /* istanbul ignore next */ function() {
            instance.end();
        });
    },
    logStartAndImpression: function(config, duration){
        var instance = this;
        var editorConfig_mode = _.get(ecEditor.getConfig('editorConfig'), 'mode');
        var mode =  editorConfig_mode && (editorConfig_mode.toLowerCase() == 'read' ? 'view' : editorConfig_mode) || 'edit';
        EkTelemetry.start(config, org.ekstep.contenteditor.api.getContext('contentId'), "", { 
            "uaspec": instance.detectClient(),
            "type": ecEditor.getConfig('editorType') || "content",
            "mode": mode.toLowerCase(),
            "duration": duration,
            "pageid": "main-page"
        });
        EkTelemetry.impression({
            type: mode,
            pageid: ecEditor.getContext('env') || "contenteditor",
            uri: encodeURIComponent(location.href)
        });
    },
    /**
     *
     * dispatches api call event (CE_API_CALL)
     * @param data {object} api call event data
     * @memberof org.ekstep.services.telemetryService
     *
     */
    apiCall: function(data) {
        if (!this.hasRequiredData(data, this.apiCallRequiredFields)) {
            console.error('Invalid api call data');
            return;
        }
        if(!data.level){    
            if(data.status ==='error'){
                data.level = 'ERROR';
                data.message = 'Unable to fetch!';
            }else{
                data.level = 'INFO'
                data.message = ''
            }
        }
        var eventData = {
            "type": "api_call",
            "level": data.level,
            "message": data.message,
            "params": [data],
            "pageid": data.stage || data.pageid || ecEditor.getContext('env') || ""
        }
        EkTelemetry.log(eventData);
    },
    /**
     *
     * dispatches log event
     * @param data {object} log event data
     * @memberof org.ekstep.services.telemetryService
     *
     */
    log: function(data){
        if (!this.hasRequiredData(data, ["type", "level", "message"])) {
            console.error('Invalid log data');
            return;
        }
        var eventData = {
            "type": data.type,
            "level": data.level,
            "message": data.message
        }
        // for V3 implementation
        if(data.pageid || data.stage)
            eventData.pageid = data.stage || data.pageid;
        if(data.params)
            eventData.params = data.params;
        EkTelemetry.log(eventData);
    },
    /**
     *
     * returns client machine info such as OS, browser, browser version
     * @memberof org.ekstep.services.telemetryService
     *
     */
    detectClient: function() {

        var nAgt = navigator.userAgent;
        var browserName = navigator.appName;
        var fullVersion = '' + parseFloat(navigator.appVersion);
        var nameOffset, verOffset, ix;

        // In Opera
        /* istanbul ignore next. Cannot test this as the test cases runs in phatomjs browser */
        if ((verOffset = nAgt.indexOf("Opera")) != -1) {
            browserName = "opera";
            fullVersion = nAgt.substring(verOffset + 6);
            if ((verOffset = nAgt.indexOf("Version")) != -1)
                fullVersion = nAgt.substring(verOffset + 8);
        }
        // In MSIE
        else if ((verOffset = nAgt.indexOf("MSIE")) != -1) {
            browserName = "IE";
            fullVersion = nAgt.substring(verOffset + 5);
        }
        // In Chrome
        else if ((verOffset = nAgt.indexOf("Chrome")) != -1) {
            browserName = "chrome";
            fullVersion = nAgt.substring(verOffset + 7);
        }
        // In Safari
        else if ((verOffset = nAgt.indexOf("Safari")) != -1) {
            browserName = "safari";
            fullVersion = nAgt.substring(verOffset + 7);
            if ((verOffset = nAgt.indexOf("Version")) != -1)
                fullVersion = nAgt.substring(verOffset + 8);
        }
        // In Firefox
        else if ((verOffset = nAgt.indexOf("Firefox")) != -1) {
            browserName = "firefox";
            fullVersion = nAgt.substring(verOffset + 8);
        }

        // trim the fullVersion string at semicolon/space if present
        /* istanbul ignore next. Cannot test this as the test cases runs in phatomjs browser */
        if ((ix = fullVersion.indexOf(";")) != -1)
            fullVersion = fullVersion.substring(0, ix);
        /* istanbul ignore next. Cannot test this as the test cases runs in phatomjs browser */
        if ((ix = fullVersion.indexOf(" ")) != -1)
            fullVersion = fullVersion.substring(0, ix);
        
        return { agent: browserName, ver: fullVersion, system: navigator.platform, platform: "", raw:  navigator.userAgent};
    }
}));

org.ekstep.contenteditor.IDispatcher = Class.extend({
    init: function() {
        this.initDispatcher();
    },
    initDispatcher: function() {throw 'Subclass should implement initDispatcher'},
    dispatch: function(event) {throw 'Subclass should implement dispatch'}
});
org.ekstep.contenteditor.consoleDispatcher = new(org.ekstep.contenteditor.IDispatcher.extend({
    type: "consoleDispatcher",
    initDispatcher: function() {},
    dispatch: function(event) {
        console.log(event);
    }
}));

org.ekstep.contenteditor.localDispatcher = new(org.ekstep.contenteditor.IDispatcher.extend({
    type: "localDispatcher",
    initDispatcher: function() {},
    dispatch: function(event) {        
        event = (typeof event === "string") ? event : JSON.stringify(event);
        org.ekstep.contenteditor.jQuery.ajax({
            type: 'POST',
            url: org.ekstep.contenteditor.config.localDispatcherEndpoint,
            data: {event: event},
            success: function(res) {}
        });
    }
}));

org.ekstep.contenteditor.piwikDispatcher = new(org.ekstep.contenteditor.IDispatcher.extend({
    type: "piwikDispatcher",
    piwikEndPoint: function() {
        return org.ekstep.contenteditor.config.baseURL + "/piwik/piwik.php";
    },
    idsite: 1,
    initDispatcher: function() {},
    dispatch: function(event) {
        if (!event) return;

        try {
            event = (typeof event === "string") ? event : JSON.stringify(event);
            /* istanbul ignore next. Cannot test jquery post */
            org.ekstep.contenteditor.jQuery.post(this.piwikEndPoint(), 'idsite=' + this.idsite + '&url=' + org.ekstep.contenteditor.config.absURL + location.pathname + '&e_c=ContentEditor&e_a=' + event + '&rec=1', function() {
            })
            .fail(function() {
                console.log("error: while piwik dispatch");
            });
        } catch (e) {
            console.log('error: piwik event cannot be stringify', e);
        }
    }
}));

/**
 * @author Sunil A S <sunils@ilimi.in>
 */
/* istanbul ignore next. Fabric extension - cannot be tested */

var generic_editor = function() {};
generic_editor.prototype.jQuery = window.$;
generic_editor.prototype._ = window._;
window.org.ekstep.genericeditor = new generic_editor();

window.ServiceConstants.GENERIC_EDITOR_SERVICE = "genericeditor";
org.ekstep.contenteditor.config = _.assign(org.ekstep.contenteditor.config, {
	pluginRepo: '/content-plugins',
    plugins: [
        { "id": "org.ekstep.sunbirdcommonheader", "ver": "1.1", "type": "plugin" },
        { "id": "org.ekstep.metadata", "ver": "1.0", "type": "plugin" },
        { "id": "org.ekstep.sunbirdmetadata", "ver": "1.0", "type": "plugin" },
        { "id": "org.ekstep.editcontentmeta", "ver": "1.1", "type": "plugin" }
    ]
});
window.org.ekstep.genericeditor.api = _.assign(org.ekstep.contenteditor.api, {
    initEditor: function(config, cb) {
        var startTime = Date.now();   
        var gcPlugins = [
            { "id": "org.ekstep.genericeditorpreview", "ver": "1.1", "type": "plugin" },        
            { "id": "org.ekstep.genericeditorsidebar", "ver": "1.0", "type": "plugin" }];
        gcPlugins = _.concat(gcPlugins, ecEditor.getConfig('genericeditorPlugins'));     
        org.ekstep.pluginframework.pluginManager.loadAllPlugins(gcPlugins, undefined, function () {
            org.ekstep.services.telemetryService.start((new Date()).getTime() - startTime);
            if (cb) cb();    
        });        
    },
    /**
     * Returns the handle to the Angular services. The services can be used by plugisn to achieve
     * the functional calls or render custom views. Valid services are:
     *     popup - UI service to render popup
     *     content - Provides access to the content API (for loading templates and assets)
     *     assessment - Provides access to the assessment API (for loading questions)
     *     language - Provides access to the wordnet API (for loading words and aksharas)
     *     search - Provides access to search API (for search activities, question, domains)
     *     meta - Provides access to metadata API (for resource bundles, ordinals, definitions)
     *     asset - Provides access to the content API (for save assets)
     *     telemetry - Service to genarate and log telemetry events
     * @param serviceId {string} id of the service to return. Returns undefined if the id is invalid
     * @memberof org.ekstep.contenteditor.api
     */
    getService: function(serviceId) {
        var service = '';
        switch (serviceId) {
            case ServiceConstants.POPUP_SERVICE:
                service = org.ekstep.services.popupService;
                break;
            case ServiceConstants.CONTENT_SERVICE:
                service = org.ekstep.services.contentService;
                break;
            case ServiceConstants.ASSESSMENT_SERVICE:
                service = org.ekstep.services.assessmentService;
                break;
            case ServiceConstants.LANGUAGE_SERVICE:
                service = org.ekstep.services.languageService;
                break;
            case ServiceConstants.SEARCH_SERVICE:
                service = org.ekstep.services.searchService;
                break;
            case ServiceConstants.META_SERVICE:
                service = org.ekstep.services.metaService;
                break;
            case ServiceConstants.ASSET_SERVICE:
                service = org.ekstep.services.assetService;
                break;
            case ServiceConstants.TELEMETRY_SERVICE:
                service = org.ekstep.services.telemetryService;
                break;
        }
        return service;
    },

    getCurrentStage: function() {
        return {};
    }
});

window.ecEditor = window.org.ekstep.genericeditor.api;
/**
 * The base plugin class that all collection editor plugins inherit from. It provides the common support contract for all plugins.
 * Plugins can override specific methods to change the behavior.
 *
 * @class org.ekstep.genericeditor.basePlugin
 * @author Santhosh Vasabhaktula <sunils@ilimi.in>
 */
org.ekstep.genericeditor.basePlugin = Class.extend({
    id: undefined,
    parent: undefined,
    children: [],
    manifest: undefined,
    editorData: undefined,
    data: undefined,
    /**
     * Initializes the plugin with the given manifest and parent object
     * @param manifest {object} Manifest details for this plugin
     * @param data {object} Init parameters for the plugin
     * @param parent {object} Parent plugin object that instantiated this
     * @constructor
     * @memberof org.ekstep.genericeditor.basePlugin
     */
    init: function(manifest, data, parent) {
        var instance = this;
        this.manifest = _.cloneDeep(manifest);
        if (arguments.length == 1) {
            this.registerMenu();
            this.initialize();
            org.ekstep.contenteditor.api.addEventListener(this.manifest.id + ":create", this.create, this);
            console.log(manifest.id + " plugin initialized");
        } else {
            this.data = undefined,
            this.editorData = data || {};
            this.children = [];
            this.id = this.editorData.id || UUID();
            this.parent = parent;            
        }
    },

    /**
     * Initializes the plugin.
     * @private
     * @memberof org.ekstep.genericeditor.basePlugin
     */
    initPlugin: function() {        
        this.newInstance();
        this.postInit();
    },

    /**
     * Post init tasks for the plugin
     * @private
     * @memberof org.ekstep.genericeditor.basePlugin
     */
    postInit: function() {                
        if (this.parent) this.parent.addChild(this);        
    },

    /**
     * Registers the menu for this plugin. By default, the base plugin handles the menu additions.
     * Child implementations can use this method to override and register additional menu items.
     * @memberof org.ekstep.genericeditor.basePlugin
     */
    registerMenu: function() {
        var instance = this;
        _.forEach(instance.manifest.editor.header, function(header) {
            org.ekstep.contenteditor.headerManager.register(header, instance.manifest);
        });

        _.forEach(instance.manifest.editor.container, function(container) {
            org.ekstep.contenteditor.containerManager.register(container, instance.manifest);
        });

        _.forEach(instance.manifest.editor.canvasarea, function(canvas) {
            org.ekstep.contenteditor.canvasManager.register(canvas, instance.manifest);
        });

        _.forEach(instance.manifest.editor.sidebarMenu, function(sidebarMenu) {
            org.ekstep.contenteditor.sidebarManager.registerSidebarMenu(sidebarMenu, instance.manifest);
        });
    },

    /**
     * Returns relative URL for a particular asset. Plugins should use this method instead of
     * hard-coding the asset URLs.
     * @memberof org.ekstep.genericeditor.basePlugin
     */
    relativeURL: function(src) {
        return org.ekstep.contenteditor.api.resolvePluginResource(this.manifest.id, this.manifest.ver, src);
    },

    /**
     * Returns the type of this plugin (manifest ID)
     * @memberof org.ekstep.genericeditor.basePlugin
     */
    getType: function() {
        return this.manifest.id;
    },

    /**
     * Returns the version of this plugin (manifest ID)
     * @memberof org.ekstep.genericeditor.basePlugin
     */
    getVersion: function() {
        return this.manifest.ver;
    },
    /**
     * Helper method to load a given resource relative to the plugin.
     * @memberof oorg.ekstep.genericeditor.basePlugin
     */
    loadResource: function(src, dataType, cb) {
        org.ekstep.contenteditor.api.loadPluginResource(this.manifest.id, this.manifest.ver, src, dataType, cb);
    },

    /**
     * Removes the plugin from the stage. This can be used to perform self cleanup. If this method is called
     * from newInstance(), plugin won't be added to stage children.
     * @memberof org.ekstep.genericeditor.basePlugin
     */
    remove: function() {
        if (this.parent) {
            this.parent.removeChild(this);
            this.parent =  undefined; // if this method is called from newInstance(), plugin won't be added to stage children    
        }
        delete org.ekstep.pluginframework.pluginManager.pluginInstances[this.id];
    },

    /**
     * Creates the instance of the plugin when a new object is added to the canvas.
     * @private
     * @memberof org.ekstep.genericeditor.basePlugin
     */
    create: function(event, data, parent) {        
        org.ekstep.contenteditor.api.instantiatePlugin(this.manifest.id, _.clone(data), parent);
    },

    /**
     * Adds a child to this object. This can be useful for composite scenarios.
     * @memberof org.ekstep.genericeditor.basePlugin
     */
    addChild: function(plugin) {
        this.children.push(plugin);
    },

    /**
     * Removes a child from this plugin. Use this to dynamically manage composite children.
     * @memberof org.ekstep.genericeditor.basePlugin
     */
    removeChild: function(plugin) {
        this.children = _.reject(this.children, { id: plugin.id });
    },

    /**
     * Initialize the plugin when it is loaded. This is a no-op implementation and child classes must
     * provide the complete functional implementation.
     * @memberof org.ekstep.genericeditor.basePlugin
     */
    /* istanbul ignore next */initialize: function(data) {},

    /**
     * Instantiate an object of the plugin type. This is a no-op implementation and child classes must
     * provide the complete functional implementation.
     * @memberof org.ekstep.genericeditor.basePlugin
     */
    /* istanbul ignore next */newInstance: function(data) {},
    /**
     * Returns the data that this plugin might set and use at runtime. As a best practice, plugins should
     * differentiate between config (e.g. rendering colors, font size, levels etc) and data (actual
     * word details to use).
     * @memberof org.ekstep.genericeditor.basePlugin
     */
    setData: function(data) {
        this.data = data;
    },

    /**
     * Returns the data for this plugin. Data includes actual drivers - such as the words in a word game
     * or questions in a quiz. Plugins should set their data is they want to differentiate from
     * the config.
     * @memberof org.ekstep.genericeditor.basePlugin
     */
    getData: function() {
        return this.data;
    },
    /**
     * Returns the help text for this plugin by reading the help markdown file. Plugins can override this
     * to return custom help.
     * @memberof org.ekstep.genericeditor.basePlugin
     */
    /* istanbul ignore next. test case failing */
    getHelp: function(cb) {        
        var helpText = "Help is not available."
        try {
            this.loadResource(this.manifest.editor.help.src, this.manifest.editor.help.dataType, function(err, help) {
                if (!err) {
                    helpText = help;
                    cb(helpText);
                }
            });
        } catch (e) {
            console.log(e)
            cb(helpText);
        }
    },
    getManifestId: function () {
      return (this.manifest.shortId || this.manifest.id);
    },

    /**
     * Returns the displayName of this object
     * @memberof org.ekstep.genericeditor.basePlugin
     */
    getDisplayName: function () {
         return (this.manifest.displayName || this.manifest.id);
    }
});

org.ekstep.contenteditor.containerManager = new(Class.extend({
	registeredContainer: [],
	initialize: function(config) {
        this.loadNgModules = config.loadNgModules;
        this.scope = config.scope
    },
    register: function(container, manifest) {
    	this.registeredContainer.push({ id: manifest.id, container: container });
    	this.load(container, manifest);
    },
    load: function(container, manifest) {
        var instance = this;        
        if (container.templateURL) {
            container.templateURL = org.ekstep.contenteditor.api.resolvePluginResource(manifest.id, manifest.ver, container.templateURL);
            instance.loadNgModules(container.templateURL);

            if (container.controllerURL) {
                container.controllerURL = org.ekstep.contenteditor.api.resolvePluginResource(manifest.id, manifest.ver, container.controllerURL);
                instance.loadNgModules(undefined, container.controllerURL)
                    .then(function() {
                        instance.scope.addToContainer(container);
                    }, function() {
                        throw "unable to load controller :" + container.controllerURL;
                    });
            } else {
                instance.scope.addToContainer(container);
            }
        };
    }   
}));
org.ekstep.contenteditor.canvasManager = new(Class.extend({
	registeredcanvas: [],
	initialize: function(config) {
        this.loadNgModules = config.loadNgModules;
        this.scope = config.scope
    },
    register: function(canvas, manifest) {
    	this.registeredcanvas.push({ id: manifest.id, canvas: canvas });
    	this.load(canvas, manifest);
    },
    load: function(canvas, manifest) {
        var instance = this;        
        if (canvas.templateURL) {
            canvas.templateURL = org.ekstep.contenteditor.api.resolvePluginResource(manifest.id, manifest.ver, canvas.templateURL);
            instance.loadNgModules(canvas.templateURL);

            if (canvas.controllerURL) {
                canvas.controllerURL = org.ekstep.contenteditor.api.resolvePluginResource(manifest.id, manifest.ver, canvas.controllerURL);
                instance.loadNgModules(undefined, canvas.controllerURL)
                    .then(function() {
                        instance.scope.addToCanvasArea(canvas);
                    }, function() {
                        throw "unable to load controller :" + canvas.controllerURL;
                    });
            } else {
                instance.scope.addToCanvasArea(canvas);
            }
        };
    }   
}));
/**
 * @author Santhosh Vasabhaktula <santhosh@ilimi.in>
 */
'use strict';

angular.module('editorApp', ['ngDialog', 'oc.lazyLoad', 'Scope.safeApply']).config(['$locationProvider', function($locationProvider) {
    $locationProvider.html5Mode({
        enabled: true,
        requireBase: false
    });
}]);
angular.module('editorApp').controller('popupController', ['ngDialog', '$ocLazyLoad', function(ngDialog, $ocLazyLoad) {
    function loadNgModules(templatePath, controllerPath) {
        return $ocLazyLoad.load([
            { type: 'html', path: templatePath },
            { type: 'js', path: controllerPath }
        ]);
    };

    function openModal(config, callback) {
        if (config && callback) config.preCloseCallback = callback;
        if (config) ngDialog.open(config);
    };
    org.ekstep.contenteditor.api.getService('popup').initService(loadNgModules, openModal);
}]);
angular.module('editorApp').controller('MainCtrl', ['$scope', '$ocLazyLoad', '$location',
    function($scope, $ocLazyLoad, $location) { 

        $scope.loadNgModules = function(templatePath, controllerPath) {
            var files = [];
            if (templatePath) files.push({ type: 'html', path: templatePath });
            if (controllerPath) files.push({ type: 'js', path: controllerPath });
            if (files.length) return $ocLazyLoad.load(files)
        };  

        org.ekstep.contenteditor.containerManager.initialize({loadNgModules: $scope.loadNgModules, scope: $scope });        

        // container scope starts
        $scope.editorContainer = undefined;
        $scope.addToContainer = function(container) {
            $scope.editorContainer = container;
            $scope.$safeApply();            
        }
        // container scope ends

        document.title = 'Generic-Editor';

        /** Initialize base editor */
        var context = org.ekstep.contenteditor.getWindowContext();
        context.uid = context.user ? context.user.id : context.uid;
        context.etags = context.etags || {};
        context.etags.app = context.app || context.etags.app || [];
        context.etags.partner = context.partner || context.etags.partner || [];
        context.etags.dims = context.dims || context.etags.dims || [];
        
        var config = org.ekstep.contenteditor.getWindowConfig();
        config.absURL = $location.protocol() + '://' + $location.host() + ':' + $location.port() // Required

        config.genericeditorPlugins = config.plugins || org.ekstep.contenteditor.config.plugins;
        config.plugins = [        
            { "id": "org.ekstep.genericeditor", "ver": "1.1", "type": "plugin" }
        ]
        org.ekstep.contenteditor.init(context, config, $scope, undefined, function() {
            $scope.contentService = org.ekstep.contenteditor.api.getService(ServiceConstants.CONTENT_SERVICE);            
            $scope.popupService = org.ekstep.contenteditor.api.getService(ServiceConstants.POPUP_SERVICE);            
        });           
    }
]);

angular.module('editorApp').directive('compilehtml', ['$compile', function($compile) {
    return {
        restrict: 'A',
        replace: true,        
        link: function(scope, ele, attrs) {
            scope.$watch(attrs.compilehtml, function(html) {
                ele.html(html);
                $compile(ele.contents())(scope);
            });           
        }
    };
}]);
